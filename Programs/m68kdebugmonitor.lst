680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 05 Mar 2024      Time: 13:42:28          Source: C:\M68KV6.0 - 800BY480\PROGRAMS\M68KDEBUGMONITOR.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ;StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  05AA 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  2896      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  2260      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include "DebugMonitor.h"
                     471   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     472   ; //#define StartOfExceptionVectorTable 0x08030000
                     473   ; #define StartOfExceptionVectorTable 0x0B000000
                     474   ; // use 0C000000 for dram or hex 08040000 for sram
                     475   ; //#define TopOfStack 0x08040000
                     476   ; #define TopOfStack 0x0C000000
                     477   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     478   ; unsigned int i, x, y, z, PortA_Count;
                     479   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     480   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     481   ; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
                     482   ; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
                     483   ; unsigned int PC, SSP, USP ;
                     484   ; unsigned short int SR;
                     485   ; // Breakpoint variables
                     486   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     487   ; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
                     488   ; unsigned int BreakPointSetOrCleared[8] ;
                     489   ; unsigned int InstructionSize ;
                     490   ; // watchpoint variables
                     491   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     492   ; unsigned int WatchPointSetOrCleared[8] ;
                     493   ; char WatchPointString[8][100] ;
                     494   ; // for disassembly of program
                     495   ; char    Instruction[100] ;
                     496   ; char    TempString[100] ;
                     497   ; /************************************************************************************
                     498   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     499   ; ************************************************************************************/
                     500   ; void Wait1ms(void)
                     501   ; {
                     502   _Wait1ms:
00000932  2F02       503          move.l    D2,-(A7)
                     504   ; long int  i ;
                     505   ; for(i = 0; i < 1000; i ++)
00000934  4282       506          clr.l     D2
                     507   Wait1ms_1:
00000936  0C82 0000  508          cmp.l     #1000,D2
0000093A  03E8      
0000093C  6C04       509          bge.s     Wait1ms_3
0000093E  5282       510          addq.l    #1,D2
00000940  60F4       511          bra       Wait1ms_1
                     512   Wait1ms_3:
00000942  241F       513          move.l    (A7)+,D2
00000944  4E75       514          rts
                     515   ; ;
                     516   ; }
                     517   ; /************************************************************************************
                     518   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     519   ; **************************************************************************************/
                     520   ; void Wait3ms(void)
                     521   ; {
                     522   _Wait3ms:
00000946  2F02       523          move.l    D2,-(A7)
                     524   ; int i ;
                     525   ; for(i = 0; i < 3; i++)
00000948  4282       526          clr.l     D2
                     527   Wait3ms_1:
0000094A  0C82 0000  528          cmp.l     #3,D2
0000094E  0003      
00000950  6C08       529          bge.s     Wait3ms_3
                     530   ; Wait1ms() ;
00000952  4EB8 0932  531          jsr       _Wait1ms
00000956  5282       532          addq.l    #1,D2
00000958  60F0       533          bra       Wait3ms_1
                     534   Wait3ms_3:
0000095A  241F       535          move.l    (A7)+,D2
0000095C  4E75       536          rts
                     537   ; }
                     538   ; /*********************************************************************************************
                     539   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     540   ; *********************************************************************************************/
                     541   ; void Init_LCD(void)
                     542   ; {
                     543   _Init_LCD:
                     544   ; LCDcommand = (char)(0x0c) ;
0000095E  13FC 000C  545          move.b    #12,4194336
00000962  0040 0020 
                     546   ; Wait3ms() ;
00000966  4EB8 0946  547          jsr       _Wait3ms
                     548   ; LCDcommand = (char)(0x38) ;
0000096A  13FC 0038  549          move.b    #56,4194336
0000096E  0040 0020 
                     550   ; Wait3ms() ;
00000972  4EB8 0946  551          jsr       _Wait3ms
00000976  4E75       552          rts
                     553   ; }
                     554   ; /******************************************************************************
                     555   ; *subroutine to output a single character held in d1 to the LCD display
                     556   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     557   ; *current cursor position
                     558   ; *******************************************************************************/
                     559   ; void Outchar(int c)
                     560   ; {
                     561   _Outchar:
00000978  4E56 0000  562          link      A6,#0
                     563   ; LCDdata = (char)(c);
0000097C  202E 0008  564          move.l    8(A6),D0
00000980  13C0 0040  565          move.b    D0,4194338
00000984  0022      
                     566   ; Wait1ms() ;
00000986  4EB8 0932  567          jsr       _Wait1ms
0000098A  4E5E       568          unlk      A6
0000098C  4E75       569          rts
                     570   ; }
                     571   ; /**********************************************************************************
                     572   ; *subroutine to output a message at the current cursor position of the LCD display
                     573   ; ************************************************************************************/
                     574   ; void OutMess(char *theMessage)
                     575   ; {
                     576   _OutMess:
0000098E  4E56 FFFC  577          link      A6,#-4
                     578   ; char c ;
                     579   ; while((c = *theMessage++) != (char)(0))
                     580   OutMess_1:
00000992  206E 0008  581          move.l    8(A6),A0
00000996  52AE 0008  582          addq.l    #1,8(A6)
0000099A  1D50 FFFF  583          move.b    (A0),-1(A6)
0000099E  1010       584          move.b    (A0),D0
000009A0  6712       585          beq.s     OutMess_3
                     586   ; Outchar(c) ;
000009A2  122E FFFF  587          move.b    -1(A6),D1
000009A6  4881       588          ext.w     D1
000009A8  48C1       589          ext.l     D1
000009AA  2F01       590          move.l    D1,-(A7)
000009AC  4EB8 0978  591          jsr       _Outchar
000009B0  584F       592          addq.w    #4,A7
000009B2  60DE       593          bra       OutMess_1
                     594   OutMess_3:
000009B4  4E5E       595          unlk      A6
000009B6  4E75       596          rts
                     597   ; }
                     598   ; /******************************************************************************
                     599   ; *subroutine to clear the line by issuing 24 space characters
                     600   ; *******************************************************************************/
                     601   ; void Clearln(void)
                     602   ; {
                     603   _Clearln:
000009B8  2F02       604          move.l    D2,-(A7)
                     605   ; unsigned char i ;
                     606   ; for(i = 0; i < 24; i ++)
000009BA  4202       607          clr.b     D2
                     608   Clearln_1:
000009BC  0C02 0018  609          cmp.b     #24,D2
000009C0  640E       610          bhs.s     Clearln_3
                     611   ; Outchar(' ') ;  /* write a space char to the LCD display */
000009C2  4878 0020  612          pea       32
000009C6  4EB8 0978  613          jsr       _Outchar
000009CA  584F       614          addq.w    #4,A7
000009CC  5202       615          addq.b    #1,D2
000009CE  60EC       616          bra       Clearln_1
                     617   Clearln_3:
000009D0  241F       618          move.l    (A7)+,D2
000009D2  4E75       619          rts
                     620   ; }
                     621   ; /******************************************************************************
                     622   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     623   ; *******************************************************************************/
                     624   ; void Oline0(char *theMessage)
                     625   ; {
                     626   _Oline0:
000009D4  4E56 0000  627          link      A6,#0
                     628   ; LCDcommand = (char)(0x80) ;
000009D8  13FC 0080  629          move.b    #128,4194336
000009DC  0040 0020 
                     630   ; Wait3ms();
000009E0  4EB8 0946  631          jsr       _Wait3ms
                     632   ; Clearln() ;
000009E4  4EB8 09B8  633          jsr       _Clearln
                     634   ; LCDcommand = (char)(0x80) ;
000009E8  13FC 0080  635          move.b    #128,4194336
000009EC  0040 0020 
                     636   ; Wait3ms() ;
000009F0  4EB8 0946  637          jsr       _Wait3ms
                     638   ; OutMess(theMessage) ;
000009F4  2F2E 0008  639          move.l    8(A6),-(A7)
000009F8  4EB8 098E  640          jsr       _OutMess
000009FC  584F       641          addq.w    #4,A7
000009FE  4E5E       642          unlk      A6
00000A00  4E75       643          rts
                     644   ; }
                     645   ; /******************************************************************************
                     646   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     647   ; *******************************************************************************/
                     648   ; void Oline1(char *theMessage)
                     649   ; {
                     650   _Oline1:
00000A02  4E56 0000  651          link      A6,#0
                     652   ; LCDcommand = (char)(0xC0) ;
00000A06  13FC 00C0  653          move.b    #192,4194336
00000A0A  0040 0020 
                     654   ; Wait3ms();
00000A0E  4EB8 0946  655          jsr       _Wait3ms
                     656   ; Clearln() ;
00000A12  4EB8 09B8  657          jsr       _Clearln
                     658   ; LCDcommand = (char)(0xC0) ;
00000A16  13FC 00C0  659          move.b    #192,4194336
00000A1A  0040 0020 
                     660   ; Wait3ms() ;
00000A1E  4EB8 0946  661          jsr       _Wait3ms
                     662   ; OutMess(theMessage) ;
00000A22  2F2E 0008  663          move.l    8(A6),-(A7)
00000A26  4EB8 098E  664          jsr       _OutMess
00000A2A  584F       665          addq.w    #4,A7
00000A2C  4E5E       666          unlk      A6
00000A2E  4E75       667          rts
                     668   ; }
                     669   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     670   ; {
                     671   _InstallExceptionHandler:
00000A30  4E56 FFFC  672          link      A6,#-4
                     673   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A34  2D7C 0B00  674          move.l    #184549376,-4(A6)
00000A38  0000 FFFC 
                     675   ; RamVectorAddress[level] = (long int *)(function_ptr);
00000A3C  206E FFFC  676          move.l    -4(A6),A0
00000A40  202E 000C  677          move.l    12(A6),D0
00000A44  E588       678          lsl.l     #2,D0
00000A46  21AE 0008  679          move.l    8(A6),0(A0,D0.L)
00000A4A  0800      
00000A4C  4E5E       680          unlk      A6
00000A4E  4E75       681          rts
                     682   ; }
                     683   ; void TestLEDS(void)
                     684   ; {
                     685   _TestLEDS:
00000A50  48E7 3000  686          movem.l   D2/D3,-(A7)
                     687   ; int delay ;
                     688   ; unsigned char count = 0 ;
00000A54  4202       689          clr.b     D2
                     690   ; while(1)    {
                     691   TestLEDS_1:
                     692   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f)) ;
00000A56  1002       693          move.b    D2,D0
00000A58  E908       694          lsl.b     #4,D0
00000A5A  1202       695          move.b    D2,D1
00000A5C  C23C 000F  696          and.b     #15,D1
00000A60  D001       697          add.b     D1,D0
00000A62  13C0 0040  698          move.b    D0,4194326
00000A66  0016      
00000A68  13C0 0040  699          move.b    D0,4194324
00000A6C  0014      
00000A6E  13C0 0040  700          move.b    D0,4194322
00000A72  0012      
00000A74  13C0 0040  701          move.b    D0,4194320
00000A78  0010      
00000A7A  13C0 0040  702          move.b    D0,4194310
00000A7E  0006      
00000A80  13C0 0040  703          move.b    D0,4194308
00000A84  0004      
00000A86  13C0 0040  704          move.b    D0,4194306
00000A8A  0002      
00000A8C  13C0 0040  705          move.b    D0,4194304
00000A90  0000      
                     706   ; for(delay = 0; delay < 200000; delay ++)
00000A92  4283       707          clr.l     D3
                     708   TestLEDS_4:
00000A94  0C83 0003  709          cmp.l     #200000,D3
00000A98  0D40      
00000A9A  6C04       710          bge.s     TestLEDS_6
00000A9C  5283       711          addq.l    #1,D3
00000A9E  60F4       712          bra       TestLEDS_4
                     713   TestLEDS_6:
                     714   ; ;
                     715   ; count ++;
00000AA0  5202       716          addq.b    #1,D2
00000AA2  60B2       717          bra       TestLEDS_1
                     718   ; }
                     719   ; }
                     720   ; void SwitchTest(void)
                     721   ; {
                     722   _SwitchTest:
00000AA4  48E7 3020  723          movem.l   D2/D3/A2,-(A7)
00000AA8  45F9 0000  724          lea       _printf.L,A2
00000AAC  551E      
                     725   ; int i, switches = 0 ;
00000AAE  4283       726          clr.l     D3
                     727   ; printf("\r\n") ;
00000AB0  4879 0000  728          pea       @m68kde~2_1.L
00000AB4  5E6E      
00000AB6  4E92       729          jsr       (A2)
00000AB8  584F       730          addq.w    #4,A7
                     731   ; while(1)    {
                     732   SwitchTest_1:
                     733   ; switches = (PortB << 8) | (PortA) ;
00000ABA  1039 0040  734          move.b    4194306,D0
00000ABE  0002      
00000AC0  C0BC 0000  735          and.l     #255,D0
00000AC4  00FF      
00000AC6  E188       736          lsl.l     #8,D0
00000AC8  1239 0040  737          move.b    4194304,D1
00000ACC  0000      
00000ACE  C2BC 0000  738          and.l     #255,D1
00000AD2  00FF      
00000AD4  8081       739          or.l      D1,D0
00000AD6  2600       740          move.l    D0,D3
                     741   ; printf("\rSwitches SW[7-0] = ") ;
00000AD8  4879 0000  742          pea       @m68kde~2_2.L
00000ADC  5E72      
00000ADE  4E92       743          jsr       (A2)
00000AE0  584F       744          addq.w    #4,A7
                     745   ; for( i = (int)(0x00000080); i > 0; i = i >> 1)  {
00000AE2  243C 0000  746          move.l    #128,D2
00000AE6  0080      
                     747   SwitchTest_4:
00000AE8  0C82 0000  748          cmp.l     #0,D2
00000AEC  0000      
00000AEE  6F20       749          ble.s     SwitchTest_6
                     750   ; if((switches & i) == 0)
00000AF0  2003       751          move.l    D3,D0
00000AF2  C082       752          and.l     D2,D0
00000AF4  660C       753          bne.s     SwitchTest_7
                     754   ; printf("0") ;
00000AF6  4879 0000  755          pea       @m68kde~2_3.L
00000AFA  5E88      
00000AFC  4E92       756          jsr       (A2)
00000AFE  584F       757          addq.w    #4,A7
00000B00  600A       758          bra.s     SwitchTest_8
                     759   SwitchTest_7:
                     760   ; else
                     761   ; printf("1") ;
00000B02  4879 0000  762          pea       @m68kde~2_4.L
00000B06  5E8A      
00000B08  4E92       763          jsr       (A2)
00000B0A  584F       764          addq.w    #4,A7
                     765   SwitchTest_8:
00000B0C  E282       766          asr.l     #1,D2
00000B0E  60D8       767          bra       SwitchTest_4
                     768   SwitchTest_6:
00000B10  60A8       769          bra       SwitchTest_1
                     770   ; }
                     771   ; }
                     772   ; }
                     773   ; /*********************************************************************************************
                     774   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     775   ; *********************************************************************************************/
                     776   ; void Init_RS232(void)
                     777   ; {
                     778   _Init_RS232:
                     779   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B12  13FC 0015  780          move.b    #21,4194368
00000B16  0040 0040 
                     781   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B1A  13FC 0001  782          move.b    #1,4194372
00000B1E  0040 0044 
00000B22  4E75       783          rts
                     784   ; }
                     785   ; int kbhit(void)
                     786   ; {
                     787   _kbhit:
                     788   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B24  1039 0040  789          move.b    4194368,D0
00000B28  0040      
00000B2A  C03C 0001  790          and.b     #1,D0
00000B2E  0C00 0001  791          cmp.b     #1,D0
00000B32  6604       792          bne.s     kbhit_1
                     793   ; return 1 ;
00000B34  7001       794          moveq     #1,D0
00000B36  6002       795          bra.s     kbhit_3
                     796   kbhit_1:
                     797   ; else
                     798   ; return 0 ;
00000B38  4280       799          clr.l     D0
                     800   kbhit_3:
00000B3A  4E75       801          rts
                     802   ; }
                     803   ; /*********************************************************************************************************
                     804   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     805   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     806   ; **  to allow the board to communicate with HyperTerminal Program
                     807   ; **
                     808   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     809   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     810   ; **  call _putch() also
                     811   ; *********************************************************************************************************/
                     812   ; int _putch( int c)
                     813   ; {
                     814   __putch:
00000B3C  4E56 0000  815          link      A6,#0
                     816   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     817   _putch_1:
00000B40  1039 0040  818          move.b    4194368,D0
00000B44  0040      
00000B46  C03C 0002  819          and.b     #2,D0
00000B4A  0C00 0002  820          cmp.b     #2,D0
00000B4E  6702       821          beq.s     _putch_3
00000B50  60EE       822          bra       _putch_1
                     823   _putch_3:
                     824   ; ;
                     825   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B52  202E 0008  826          move.l    8(A6),D0
00000B56  C03C 007F  827          and.b     #127,D0
00000B5A  13C0 0040  828          move.b    D0,4194370
00000B5E  0042      
                     829   ; return c ;                                              // putchar() expects the character to be returned
00000B60  202E 0008  830          move.l    8(A6),D0
00000B64  4E5E       831          unlk      A6
00000B66  4E75       832          rts
                     833   ; }
                     834   ; /*********************************************************************************************************
                     835   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     836   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     837   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     838   ; **
                     839   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     840   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     841   ; **  call _getch() also
                     842   ; *********************************************************************************************************/
                     843   ; int _getch( void )
                     844   ; {
                     845   __getch:
00000B68  2F02       846          move.l    D2,-(A7)
                     847   ; int c ;
                     848   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     849   _getch_1:
00000B6A  1039 0040  850          move.b    4194368,D0
00000B6E  0040      
00000B70  C03C 0001  851          and.b     #1,D0
00000B74  0C00 0001  852          cmp.b     #1,D0
00000B78  6702       853          beq.s     _getch_3
00000B7A  60EE       854          bra       _getch_1
                     855   _getch_3:
                     856   ; ;
                     857   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B7C  1039 0040  858          move.b    4194370,D0
00000B80  0042      
00000B82  C0BC 0000  859          and.l     #255,D0
00000B86  00FF      
00000B88  C0BC 0000  860          and.l     #127,D0
00000B8C  007F      
00000B8E  2400       861          move.l    D0,D2
                     862   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     863   ; if(Echo)
00000B90  4AB9 0B00  864          tst.l     _Echo.L
00000B94  00E0      
00000B96  6708       865          beq.s     _getch_4
                     866   ; _putch(c);
00000B98  2F02       867          move.l    D2,-(A7)
00000B9A  4EB8 0B3C  868          jsr       __putch
00000B9E  584F       869          addq.w    #4,A7
                     870   _getch_4:
                     871   ; return c ;
00000BA0  2002       872          move.l    D2,D0
00000BA2  241F       873          move.l    (A7)+,D2
00000BA4  4E75       874          rts
                     875   ; }
                     876   ; // flush the input stream for any unread characters
                     877   ; void FlushKeyboard(void)
                     878   ; {
                     879   _FlushKeyboard:
00000BA6  4E56 FFFC  880          link      A6,#-4
                     881   ; char c ;
                     882   ; while(1)    {
                     883   FlushKeyboard_1:
                     884   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BAA  1039 0040  885          move.b    4194368,D0
00000BAE  0040      
00000BB0  C03C 0001  886          and.b     #1,D0
00000BB4  0C00 0001  887          cmp.b     #1,D0
00000BB8  6610       888          bne.s     FlushKeyboard_4
                     889   ; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
00000BBA  1039 0040  890          move.b    4194370,D0
00000BBE  0042      
00000BC0  C03C 007F  891          and.b     #127,D0
00000BC4  1D40 FFFF  892          move.b    D0,-1(A6)
00000BC8  6002       893          bra.s     FlushKeyboard_5
                     894   FlushKeyboard_4:
                     895   ; else
                     896   ; return ;
00000BCA  6002       897          bra.s     FlushKeyboard_6
                     898   FlushKeyboard_5:
00000BCC  60DC       899          bra       FlushKeyboard_1
                     900   FlushKeyboard_6:
00000BCE  4E5E       901          unlk      A6
00000BD0  4E75       902          rts
                     903   ; }
                     904   ; }
                     905   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     906   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     907   ; char xtod(int c)
                     908   ; {
                     909   _xtod:
00000BD2  4E56 0000  910          link      A6,#0
00000BD6  2F02       911          move.l    D2,-(A7)
00000BD8  242E 0008  912          move.l    8(A6),D2
                     913   ; if ((char)(c) <= (char)('9'))
00000BDC  0C02 0039  914          cmp.b     #57,D2
00000BE0  6E08       915          bgt.s     xtod_1
                     916   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE2  1002       917          move.b    D2,D0
00000BE4  0400 0030  918          sub.b     #48,D0
00000BE8  6014       919          bra.s     xtod_3
                     920   xtod_1:
                     921   ; else if((char)(c) > (char)('F'))    // assume lower case
00000BEA  0C02 0046  922          cmp.b     #70,D2
00000BEE  6F08       923          ble.s     xtod_4
                     924   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF0  1002       925          move.b    D2,D0
00000BF2  0400 0057  926          sub.b     #87,D0
00000BF6  6006       927          bra.s     xtod_3
                     928   xtod_4:
                     929   ; else
                     930   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BF8  1002       931          move.b    D2,D0
00000BFA  0400 0037  932          sub.b     #55,D0
                     933   xtod_3:
00000BFE  241F       934          move.l    (A7)+,D2
00000C00  4E5E       935          unlk      A6
00000C02  4E75       936          rts
                     937   ; }
                     938   ; int Get2HexDigits(char *CheckSumPtr)
                     939   ; {
                     940   _Get2HexDigits:
00000C04  4E56 0000  941          link      A6,#0
00000C08  2F02       942          move.l    D2,-(A7)
                     943   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C0A  2F00       944          move.l    D0,-(A7)
00000C0C  4EB8 0B68  945          jsr       __getch
00000C10  2200       946          move.l    D0,D1
00000C12  201F       947          move.l    (A7)+,D0
00000C14  2F01       948          move.l    D1,-(A7)
00000C16  4EB8 0BD2  949          jsr       _xtod
00000C1A  584F       950          addq.w    #4,A7
00000C1C  C0BC 0000  951          and.l     #255,D0
00000C20  00FF      
00000C22  E980       952          asl.l     #4,D0
00000C24  2F00       953          move.l    D0,-(A7)
00000C26  2F01       954          move.l    D1,-(A7)
00000C28  4EB8 0B68  955          jsr       __getch
00000C2C  221F       956          move.l    (A7)+,D1
00000C2E  2F00       957          move.l    D0,-(A7)
00000C30  4EB8 0BD2  958          jsr       _xtod
00000C34  584F       959          addq.w    #4,A7
00000C36  2200       960          move.l    D0,D1
00000C38  201F       961          move.l    (A7)+,D0
00000C3A  C2BC 0000  962          and.l     #255,D1
00000C3E  00FF      
00000C40  8081       963          or.l      D1,D0
00000C42  2400       964          move.l    D0,D2
                     965   ; if(CheckSumPtr)
00000C44  4AAE 0008  966          tst.l     8(A6)
00000C48  6706       967          beq.s     Get2HexDigits_1
                     968   ; *CheckSumPtr += i ;
00000C4A  206E 0008  969          move.l    8(A6),A0
00000C4E  D510       970          add.b     D2,(A0)
                     971   Get2HexDigits_1:
                     972   ; return i ;
00000C50  2002       973          move.l    D2,D0
00000C52  241F       974          move.l    (A7)+,D2
00000C54  4E5E       975          unlk      A6
00000C56  4E75       976          rts
                     977   ; }
                     978   ; int Get4HexDigits(char *CheckSumPtr)
                     979   ; {
                     980   _Get4HexDigits:
00000C58  4E56 0000  981          link      A6,#0
                     982   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C5C  2F2E 0008  983          move.l    8(A6),-(A7)
00000C60  4EB8 0C04  984          jsr       _Get2HexDigits
00000C64  584F       985          addq.w    #4,A7
00000C66  E180       986          asl.l     #8,D0
00000C68  2F00       987          move.l    D0,-(A7)
00000C6A  2F2E 0008  988          move.l    8(A6),-(A7)
00000C6E  4EB8 0C04  989          jsr       _Get2HexDigits
00000C72  584F       990          addq.w    #4,A7
00000C74  2200       991          move.l    D0,D1
00000C76  201F       992          move.l    (A7)+,D0
00000C78  8081       993          or.l      D1,D0
00000C7A  4E5E       994          unlk      A6
00000C7C  4E75       995          rts
                     996   ; }
                     997   ; int Get6HexDigits(char *CheckSumPtr)
                     998   ; {
                     999   _Get6HexDigits:
00000C7E  4E56 0000 1000          link      A6,#0
                    1001   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C82  2F2E 0008 1002          move.l    8(A6),-(A7)
00000C86  4EB8 0C58 1003          jsr       _Get4HexDigits
00000C8A  584F      1004          addq.w    #4,A7
00000C8C  E180      1005          asl.l     #8,D0
00000C8E  2F00      1006          move.l    D0,-(A7)
00000C90  2F2E 0008 1007          move.l    8(A6),-(A7)
00000C94  4EB8 0C04 1008          jsr       _Get2HexDigits
00000C98  584F      1009          addq.w    #4,A7
00000C9A  2200      1010          move.l    D0,D1
00000C9C  201F      1011          move.l    (A7)+,D0
00000C9E  8081      1012          or.l      D1,D0
00000CA0  4E5E      1013          unlk      A6
00000CA2  4E75      1014          rts
                    1015   ; }
                    1016   ; int Get8HexDigits(char *CheckSumPtr)
                    1017   ; {
                    1018   _Get8HexDigits:
00000CA4  4E56 0000 1019          link      A6,#0
                    1020   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CA8  2F2E 0008 1021          move.l    8(A6),-(A7)
00000CAC  4EB8 0C58 1022          jsr       _Get4HexDigits
00000CB0  584F      1023          addq.w    #4,A7
00000CB2  E180      1024          asl.l     #8,D0
00000CB4  E180      1025          asl.l     #8,D0
00000CB6  2F00      1026          move.l    D0,-(A7)
00000CB8  2F2E 0008 1027          move.l    8(A6),-(A7)
00000CBC  4EB8 0C58 1028          jsr       _Get4HexDigits
00000CC0  584F      1029          addq.w    #4,A7
00000CC2  2200      1030          move.l    D0,D1
00000CC4  201F      1031          move.l    (A7)+,D0
00000CC6  8081      1032          or.l      D1,D0
00000CC8  4E5E      1033          unlk      A6
00000CCA  4E75      1034          rts
                    1035   ; }
                    1036   ; char *strcatInstruction(char *s) {    return strcat(Instruction,s) ; }
                    1037   _strcatInstruction:
00000CCC  4E56 0000 1038          link      A6,#0
00000CD0  2F2E 0008 1039          move.l    8(A6),-(A7)
00000CD4  4879 0B00 1040          pea       _Instruction.L
00000CD8  04E2      
00000CDA  4EB9 0000 1041          jsr       _strcat
00000CDE  54DC      
00000CE0  504F      1042          addq.w    #8,A7
00000CE2  4E5E      1043          unlk      A6
00000CE4  4E75      1044          rts
                    1045   ; char *strcpyInstruction(char *s) {    return strcpy(Instruction,s) ; }
                    1046   _strcpyInstruction:
00000CE6  4E56 0000 1047          link      A6,#0
00000CEA  2F2E 0008 1048          move.l    8(A6),-(A7)
00000CEE  4879 0B00 1049          pea       _Instruction.L
00000CF2  04E2      
00000CF4  4EB9 0000 1050          jsr       _strcpy
00000CF8  5322      
00000CFA  504F      1051          addq.w    #8,A7
00000CFC  4E5E      1052          unlk      A6
00000CFE  4E75      1053          rts
                    1054   ; void DisassembleProgram(void )
                    1055   ; {
                    1056   _DisassembleProgram:
00000D00  4E56 FFF8 1057          link      A6,#-8
00000D04  48E7 3038 1058          movem.l   D2/D3/A2/A3/A4,-(A7)
00000D08  45F9 0B00 1059          lea       _InstructionSize.L,A2
00000D0C  017E      
00000D0E  47F9 0000 1060          lea       _printf.L,A3
00000D12  551E      
00000D14  49F9 0B00 1061          lea       _Instruction.L,A4
00000D18  04E2      
                    1062   ; char c ;
                    1063   ; int i, j ;
                    1064   ; unsigned short int *ProgramPtr ; // pointer to where the program is stored
                    1065   ; printf("\r\nEnter Start Address: ") ;
00000D1A  4879 0000 1066          pea       @m68kde~2_5.L
00000D1E  5E8C      
00000D20  4E93      1067          jsr       (A3)
00000D22  584F      1068          addq.w    #4,A7
                    1069   ; ProgramPtr = Get8HexDigits(0) ;
00000D24  42A7      1070          clr.l     -(A7)
00000D26  4EB8 0CA4 1071          jsr       _Get8HexDigits
00000D2A  584F      1072          addq.w    #4,A7
00000D2C  2400      1073          move.l    D0,D2
                    1074   ; printf("\r\n<ESC> = Abort, SPACE to Continue") ;
00000D2E  4879 0000 1075          pea       @m68kde~2_6.L
00000D32  5EA4      
00000D34  4E93      1076          jsr       (A3)
00000D36  584F      1077          addq.w    #4,A7
                    1078   ; while(1)    {
                    1079   DisassembleProgram_1:
                    1080   ; for(i = 0; i < 20; i ++)
00000D38  4283      1081          clr.l     D3
                    1082   DisassembleProgram_4:
00000D3A  0C83 0000 1083          cmp.l     #20,D3
00000D3E  0014      
00000D40  6C00 017E 1084          bge       DisassembleProgram_6
                    1085   ; {
                    1086   ; InstructionSize = 1 ;                   // assume all instruction are at least 1 word
00000D44  24BC 0000 1087          move.l    #1,(A2)
00000D48  0001      
                    1088   ; DisassembleInstruction(ProgramPtr) ;    // build up string for disassembled instruction at address in programptr
00000D4A  2F02      1089          move.l    D2,-(A7)
00000D4C  4EB9 0000 1090          jsr       _DisassembleInstruction
00000D50  3480      
00000D52  584F      1091          addq.w    #4,A7
                    1092   ; if(InstructionSize == 1)
00000D54  2012      1093          move.l    (A2),D0
00000D56  0C80 0000 1094          cmp.l     #1,D0
00000D5A  0001      
00000D5C  6620      1095          bne.s     DisassembleProgram_7
                    1096   ; printf("\r\n%08X  %04X                        %s", ProgramPtr, ProgramPtr[0], Instruction) ;
00000D5E  2F0C      1097          move.l    A4,-(A7)
00000D60  2042      1098          move.l    D2,A0
00000D62  3210      1099          move.w    (A0),D1
00000D64  C2BC 0000 1100          and.l     #65535,D1
00000D68  FFFF      
00000D6A  2F01      1101          move.l    D1,-(A7)
00000D6C  2F02      1102          move.l    D2,-(A7)
00000D6E  4879 0000 1103          pea       @m68kde~2_7.L
00000D72  5EC8      
00000D74  4E93      1104          jsr       (A3)
00000D76  DEFC 0010 1105          add.w     #16,A7
00000D7A  6000 0138 1106          bra       DisassembleProgram_15
                    1107   DisassembleProgram_7:
                    1108   ; else if(InstructionSize == 2)
00000D7E  2012      1109          move.l    (A2),D0
00000D80  0C80 0000 1110          cmp.l     #2,D0
00000D84  0002      
00000D86  662E      1111          bne.s     DisassembleProgram_9
                    1112   ; printf("\r\n%08X  %04X %04X                   %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], Instruction) ;
00000D88  2F0C      1113          move.l    A4,-(A7)
00000D8A  2042      1114          move.l    D2,A0
00000D8C  3228 0002 1115          move.w    2(A0),D1
00000D90  C2BC 0000 1116          and.l     #65535,D1
00000D94  FFFF      
00000D96  2F01      1117          move.l    D1,-(A7)
00000D98  2042      1118          move.l    D2,A0
00000D9A  3210      1119          move.w    (A0),D1
00000D9C  C2BC 0000 1120          and.l     #65535,D1
00000DA0  FFFF      
00000DA2  2F01      1121          move.l    D1,-(A7)
00000DA4  2F02      1122          move.l    D2,-(A7)
00000DA6  4879 0000 1123          pea       @m68kde~2_8.L
00000DAA  5EF0      
00000DAC  4E93      1124          jsr       (A3)
00000DAE  DEFC 0014 1125          add.w     #20,A7
00000DB2  6000 0100 1126          bra       DisassembleProgram_15
                    1127   DisassembleProgram_9:
                    1128   ; else if(InstructionSize == 3)
00000DB6  2012      1129          move.l    (A2),D0
00000DB8  0C80 0000 1130          cmp.l     #3,D0
00000DBC  0003      
00000DBE  6600 003E 1131          bne       DisassembleProgram_11
                    1132   ; printf("\r\n%08X  %04X %04X %04X              %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], ProgramPtr[2], Instruction) ;
00000DC2  2F0C      1133          move.l    A4,-(A7)
00000DC4  2042      1134          move.l    D2,A0
00000DC6  3228 0004 1135          move.w    4(A0),D1
00000DCA  C2BC 0000 1136          and.l     #65535,D1
00000DCE  FFFF      
00000DD0  2F01      1137          move.l    D1,-(A7)
00000DD2  2042      1138          move.l    D2,A0
00000DD4  3228 0002 1139          move.w    2(A0),D1
00000DD8  C2BC 0000 1140          and.l     #65535,D1
00000DDC  FFFF      
00000DDE  2F01      1141          move.l    D1,-(A7)
00000DE0  2042      1142          move.l    D2,A0
00000DE2  3210      1143          move.w    (A0),D1
00000DE4  C2BC 0000 1144          and.l     #65535,D1
00000DE8  FFFF      
00000DEA  2F01      1145          move.l    D1,-(A7)
00000DEC  2F02      1146          move.l    D2,-(A7)
00000DEE  4879 0000 1147          pea       @m68kde~2_9.L
00000DF2  5F18      
00000DF4  4E93      1148          jsr       (A3)
00000DF6  DEFC 0018 1149          add.w     #24,A7
00000DFA  6000 00B8 1150          bra       DisassembleProgram_15
                    1151   DisassembleProgram_11:
                    1152   ; else if(InstructionSize == 4)
00000DFE  2012      1153          move.l    (A2),D0
00000E00  0C80 0000 1154          cmp.l     #4,D0
00000E04  0004      
00000E06  6600 004C 1155          bne       DisassembleProgram_13
                    1156   ; printf("\r\n%08X  %04X %04X %04X %04X         %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], ProgramPtr[2], ProgramPtr[3], Instruction) ;
00000E0A  2F0C      1157          move.l    A4,-(A7)
00000E0C  2042      1158          move.l    D2,A0
00000E0E  3228 0006 1159          move.w    6(A0),D1
00000E12  C2BC 0000 1160          and.l     #65535,D1
00000E16  FFFF      
00000E18  2F01      1161          move.l    D1,-(A7)
00000E1A  2042      1162          move.l    D2,A0
00000E1C  3228 0004 1163          move.w    4(A0),D1
00000E20  C2BC 0000 1164          and.l     #65535,D1
00000E24  FFFF      
00000E26  2F01      1165          move.l    D1,-(A7)
00000E28  2042      1166          move.l    D2,A0
00000E2A  3228 0002 1167          move.w    2(A0),D1
00000E2E  C2BC 0000 1168          and.l     #65535,D1
00000E32  FFFF      
00000E34  2F01      1169          move.l    D1,-(A7)
00000E36  2042      1170          move.l    D2,A0
00000E38  3210      1171          move.w    (A0),D1
00000E3A  C2BC 0000 1172          and.l     #65535,D1
00000E3E  FFFF      
00000E40  2F01      1173          move.l    D1,-(A7)
00000E42  2F02      1174          move.l    D2,-(A7)
00000E44  4879 0000 1175          pea       @m68kde~2_10.L
00000E48  5F40      
00000E4A  4E93      1176          jsr       (A3)
00000E4C  DEFC 001C 1177          add.w     #28,A7
00000E50  6000 0062 1178          bra       DisassembleProgram_15
                    1179   DisassembleProgram_13:
                    1180   ; else if(InstructionSize == 5)
00000E54  2012      1181          move.l    (A2),D0
00000E56  0C80 0000 1182          cmp.l     #5,D0
00000E5A  0005      
00000E5C  6600 0056 1183          bne       DisassembleProgram_15
                    1184   ; printf("\r\n%08X  %04X %04X %04X %04X %04X    %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], ProgramPtr[2], ProgramPtr[3], ProgramPtr[4], Instruction) ;
00000E60  2F0C      1185          move.l    A4,-(A7)
00000E62  2042      1186          move.l    D2,A0
00000E64  3228 0008 1187          move.w    8(A0),D1
00000E68  C2BC 0000 1188          and.l     #65535,D1
00000E6C  FFFF      
00000E6E  2F01      1189          move.l    D1,-(A7)
00000E70  2042      1190          move.l    D2,A0
00000E72  3228 0006 1191          move.w    6(A0),D1
00000E76  C2BC 0000 1192          and.l     #65535,D1
00000E7A  FFFF      
00000E7C  2F01      1193          move.l    D1,-(A7)
00000E7E  2042      1194          move.l    D2,A0
00000E80  3228 0004 1195          move.w    4(A0),D1
00000E84  C2BC 0000 1196          and.l     #65535,D1
00000E88  FFFF      
00000E8A  2F01      1197          move.l    D1,-(A7)
00000E8C  2042      1198          move.l    D2,A0
00000E8E  3228 0002 1199          move.w    2(A0),D1
00000E92  C2BC 0000 1200          and.l     #65535,D1
00000E96  FFFF      
00000E98  2F01      1201          move.l    D1,-(A7)
00000E9A  2042      1202          move.l    D2,A0
00000E9C  3210      1203          move.w    (A0),D1
00000E9E  C2BC 0000 1204          and.l     #65535,D1
00000EA2  FFFF      
00000EA4  2F01      1205          move.l    D1,-(A7)
00000EA6  2F02      1206          move.l    D2,-(A7)
00000EA8  4879 0000 1207          pea       @m68kde~2_11.L
00000EAC  5F68      
00000EAE  4E93      1208          jsr       (A3)
00000EB0  DEFC 0020 1209          add.w     #32,A7
                    1210   DisassembleProgram_15:
                    1211   ; ProgramPtr += InstructionSize ;
00000EB4  2012      1212          move.l    (A2),D0
00000EB6  E388      1213          lsl.l     #1,D0
00000EB8  D480      1214          add.l     D0,D2
00000EBA  5283      1215          addq.l    #1,D3
00000EBC  6000 FE7C 1216          bra       DisassembleProgram_4
                    1217   DisassembleProgram_6:
                    1218   ; }
                    1219   ; c = _getch() ;
00000EC0  4EB8 0B68 1220          jsr       __getch
00000EC4  1D40 FFFB 1221          move.b    D0,-5(A6)
                    1222   ; if(c == 0x1b)          // break on ESC
00000EC8  102E FFFB 1223          move.b    -5(A6),D0
00000ECC  0C00 001B 1224          cmp.b     #27,D0
00000ED0  6602      1225          bne.s     DisassembleProgram_17
                    1226   ; return ;
00000ED2  6004      1227          bra.s     DisassembleProgram_19
                    1228   DisassembleProgram_17:
00000ED4  6000 FE62 1229          bra       DisassembleProgram_1
                    1230   DisassembleProgram_19:
00000ED8  4CDF 1C0C 1231          movem.l   (A7)+,D2/D3/A2/A3/A4
00000EDC  4E5E      1232          unlk      A6
00000EDE  4E75      1233          rts
                    1234   ; }
                    1235   ; }
                    1236   ; void DumpMemory(void)   // simple dump memory fn
                    1237   ; {
                    1238   _DumpMemory:
00000EE0  48E7 3C30 1239          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000EE4  45F9 0000 1240          lea       _printf.L,A2
00000EE8  551E      
00000EEA  47F9 0000 1241          lea       _putch.L,A3
00000EEE  5410      
                    1242   ; int i, j ;
                    1243   ; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
                    1244   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
00000EF0  4879 0000 1245          pea       @m68kde~2_12.L
00000EF4  5F90      
00000EF6  4E92      1246          jsr       (A2)
00000EF8  584F      1247          addq.w    #4,A7
                    1248   ; printf("\r\nEnter Start Address: ") ;
00000EFA  4879 0000 1249          pea       @m68kde~2_5.L
00000EFE  5E8C      
00000F00  4E92      1250          jsr       (A2)
00000F02  584F      1251          addq.w    #4,A7
                    1252   ; RamPtr = Get8HexDigits(0) ;
00000F04  42A7      1253          clr.l     -(A7)
00000F06  4EB8 0CA4 1254          jsr       _Get8HexDigits
00000F0A  584F      1255          addq.w    #4,A7
00000F0C  2600      1256          move.l    D0,D3
                    1257   ; while(1)    {
                    1258   DumpMemory_1:
                    1259   ; for(i = 0; i < 16; i ++)    {
00000F0E  4285      1260          clr.l     D5
                    1261   DumpMemory_4:
00000F10  0C85 0000 1262          cmp.l     #16,D5
00000F14  0010      
00000F16  6C00 0096 1263          bge       DumpMemory_6
                    1264   ; printf("\r\n%08x ", RamPtr) ;
00000F1A  2F03      1265          move.l    D3,-(A7)
00000F1C  4879 0000 1266          pea       @m68kde~2_13.L
00000F20  5FCA      
00000F22  4E92      1267          jsr       (A2)
00000F24  504F      1268          addq.w    #8,A7
                    1269   ; for(j=0; j < 16; j ++)  {
00000F26  4282      1270          clr.l     D2
                    1271   DumpMemory_7:
00000F28  0C82 0000 1272          cmp.l     #16,D2
00000F2C  0010      
00000F2E  6C24      1273          bge.s     DumpMemory_9
                    1274   ; printf("%02X",RamPtr[j]) ;
00000F30  2043      1275          move.l    D3,A0
00000F32  1230 2800 1276          move.b    0(A0,D2.L),D1
00000F36  C2BC 0000 1277          and.l     #255,D1
00000F3A  00FF      
00000F3C  2F01      1278          move.l    D1,-(A7)
00000F3E  4879 0000 1279          pea       @m68kde~2_14.L
00000F42  5FD2      
00000F44  4E92      1280          jsr       (A2)
00000F46  504F      1281          addq.w    #8,A7
                    1282   ; putchar(' ') ;
00000F48  4878 0020 1283          pea       32
00000F4C  4E93      1284          jsr       (A3)
00000F4E  584F      1285          addq.w    #4,A7
00000F50  5282      1286          addq.l    #1,D2
00000F52  60D4      1287          bra       DumpMemory_7
                    1288   DumpMemory_9:
                    1289   ; }
                    1290   ; // now display the data as ASCII at the end
                    1291   ; printf("  ") ;
00000F54  4879 0000 1292          pea       @m68kde~2_15.L
00000F58  5FD8      
00000F5A  4E92      1293          jsr       (A2)
00000F5C  584F      1294          addq.w    #4,A7
                    1295   ; for(j = 0; j < 16; j++) {
00000F5E  4282      1296          clr.l     D2
                    1297   DumpMemory_10:
00000F60  0C82 0000 1298          cmp.l     #16,D2
00000F64  0010      
00000F66  6C00 003A 1299          bge       DumpMemory_12
                    1300   ; c = ((char)(RamPtr[j]) & 0x7f) ;
00000F6A  2043      1301          move.l    D3,A0
00000F6C  1030 2800 1302          move.b    0(A0,D2.L),D0
00000F70  C03C 007F 1303          and.b     #127,D0
00000F74  1800      1304          move.b    D0,D4
                    1305   ; if((c > (char)(0x7f)) || (c < ' '))
00000F76  0C04 007F 1306          cmp.b     #127,D4
00000F7A  6206      1307          bhi.s     DumpMemory_15
00000F7C  0C04 0020 1308          cmp.b     #32,D4
00000F80  640A      1309          bhs.s     DumpMemory_13
                    1310   DumpMemory_15:
                    1311   ; putchar('.') ;
00000F82  4878 002E 1312          pea       46
00000F86  4E93      1313          jsr       (A3)
00000F88  584F      1314          addq.w    #4,A7
00000F8A  6012      1315          bra.s     DumpMemory_14
                    1316   DumpMemory_13:
                    1317   ; else
                    1318   ; putchar(RamPtr[j]) ;
00000F8C  2043      1319          move.l    D3,A0
00000F8E  1230 2800 1320          move.b    0(A0,D2.L),D1
00000F92  C2BC 0000 1321          and.l     #255,D1
00000F96  00FF      
00000F98  2F01      1322          move.l    D1,-(A7)
00000F9A  4E93      1323          jsr       (A3)
00000F9C  584F      1324          addq.w    #4,A7
                    1325   DumpMemory_14:
00000F9E  5282      1326          addq.l    #1,D2
00000FA0  60BE      1327          bra       DumpMemory_10
                    1328   DumpMemory_12:
                    1329   ; }
                    1330   ; RamPtr = RamPtr + 16 ;
00000FA2  0683 0000 1331          add.l     #16,D3
00000FA6  0010      
00000FA8  5285      1332          addq.l    #1,D5
00000FAA  6000 FF64 1333          bra       DumpMemory_4
                    1334   DumpMemory_6:
                    1335   ; }
                    1336   ; printf("\r\n") ;
00000FAE  4879 0000 1337          pea       @m68kde~2_1.L
00000FB2  5E6E      
00000FB4  4E92      1338          jsr       (A2)
00000FB6  584F      1339          addq.w    #4,A7
                    1340   ; c = _getch() ;
00000FB8  4EB8 0B68 1341          jsr       __getch
00000FBC  1800      1342          move.b    D0,D4
                    1343   ; if(c == 0x1b)          // break on ESC
00000FBE  0C04 001B 1344          cmp.b     #27,D4
00000FC2  6602      1345          bne.s     DumpMemory_16
                    1346   ; break ;
00000FC4  6004      1347          bra.s     DumpMemory_3
                    1348   DumpMemory_16:
00000FC6  6000 FF46 1349          bra       DumpMemory_1
                    1350   DumpMemory_3:
00000FCA  4CDF 0C3C 1351          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000FCE  4E75      1352          rts
                    1353   ; }
                    1354   ; }
                    1355   ; void FillMemory()
                    1356   ; {
                    1357   _FillMemory:
00000FD0  48E7 3820 1358          movem.l   D2/D3/D4/A2,-(A7)
00000FD4  45F9 0000 1359          lea       _printf.L,A2
00000FD8  551E      
                    1360   ; char *StartRamPtr, *EndRamPtr ;
                    1361   ; unsigned char FillData ;
                    1362   ; printf("\r\nFill Memory Block") ;
00000FDA  4879 0000 1363          pea       @m68kde~2_16.L
00000FDE  5FDC      
00000FE0  4E92      1364          jsr       (A2)
00000FE2  584F      1365          addq.w    #4,A7
                    1366   ; printf("\r\nEnter Start Address: ") ;
00000FE4  4879 0000 1367          pea       @m68kde~2_5.L
00000FE8  5E8C      
00000FEA  4E92      1368          jsr       (A2)
00000FEC  584F      1369          addq.w    #4,A7
                    1370   ; StartRamPtr = Get8HexDigits(0) ;
00000FEE  42A7      1371          clr.l     -(A7)
00000FF0  4EB8 0CA4 1372          jsr       _Get8HexDigits
00000FF4  584F      1373          addq.w    #4,A7
00000FF6  2400      1374          move.l    D0,D2
                    1375   ; printf("\r\nEnter End Address: ") ;
00000FF8  4879 0000 1376          pea       @m68kde~2_17.L
00000FFC  5FF0      
00000FFE  4E92      1377          jsr       (A2)
00001000  584F      1378          addq.w    #4,A7
                    1379   ; EndRamPtr = Get8HexDigits(0) ;
00001002  42A7      1380          clr.l     -(A7)
00001004  4EB8 0CA4 1381          jsr       _Get8HexDigits
00001008  584F      1382          addq.w    #4,A7
0000100A  2800      1383          move.l    D0,D4
                    1384   ; printf("\r\nEnter Fill Data: ") ;
0000100C  4879 0000 1385          pea       @m68kde~2_18.L
00001010  6006      
00001012  4E92      1386          jsr       (A2)
00001014  584F      1387          addq.w    #4,A7
                    1388   ; FillData = Get2HexDigits(0) ;
00001016  42A7      1389          clr.l     -(A7)
00001018  4EB8 0C04 1390          jsr       _Get2HexDigits
0000101C  584F      1391          addq.w    #4,A7
0000101E  1600      1392          move.b    D0,D3
                    1393   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
00001020  C6BC 0000 1394          and.l     #255,D3
00001024  00FF      
00001026  2F03      1395          move.l    D3,-(A7)
00001028  2F04      1396          move.l    D4,-(A7)
0000102A  2F02      1397          move.l    D2,-(A7)
0000102C  4879 0000 1398          pea       @m68kde~2_19.L
00001030  601A      
00001032  4E92      1399          jsr       (A2)
00001034  DEFC 0010 1400          add.w     #16,A7
                    1401   ; while(StartRamPtr < EndRamPtr)
                    1402   FillMemory_1:
00001038  B484      1403          cmp.l     D4,D2
0000103A  6408      1404          bhs.s     FillMemory_3
                    1405   ; *StartRamPtr++ = FillData ;
0000103C  2042      1406          move.l    D2,A0
0000103E  5282      1407          addq.l    #1,D2
00001040  1083      1408          move.b    D3,(A0)
00001042  60F4      1409          bra       FillMemory_1
                    1410   FillMemory_3:
00001044  4CDF 041C 1411          movem.l   (A7)+,D2/D3/D4/A2
00001048  4E75      1412          rts
                    1413   ; }
                    1414   ; void Load_SRecordFile()
                    1415   ; {
                    1416   _Load_SRecordFile:
0000104A  4E56 FFDC 1417          link      A6,#-36
0000104E  48E7 3F3C 1418          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001052  45EE FFFA 1419          lea       -6(A6),A2
00001056  47F8 0C04 1420          lea       _Get2HexDigits.L,A3
0000105A  49F9 0000 1421          lea       _printf.L,A4
0000105E  551E      
                    1422   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
00001060  42AE FFEE 1423          clr.l     -18(A6)
00001064  3A7C 0000 1424          move.w    #0,A5
                    1425   ; int result, ByteCount ;
                    1426   ; char c, CheckSum, ReadCheckSum, HeaderType ;
                    1427   ; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
                    1428   ; LoadFailed = 0 ;                        //assume LOAD operation will pass
00001068  7E00      1429          moveq     #0,D7
                    1430   ; AddressFail = 0 ;
0000106A  42AE FFEA 1431          clr.l     -22(A6)
                    1432   ; Echo = 0 ;                              // don't echo S records during download
0000106E  42B9 0B00 1433          clr.l     _Echo.L
00001072  00E0      
                    1434   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
00001074  4879 0000 1435          pea       @m68kde~2_20.L
00001078  604A      
0000107A  4E94      1436          jsr       (A4)
0000107C  584F      1437          addq.w    #4,A7
                    1438   ; while(1)    {
                    1439   Load_SRecordFile_1:
                    1440   ; CheckSum = 0 ;
0000107E  4212      1441          clr.b     (A2)
                    1442   ; do {
                    1443   Load_SRecordFile_4:
                    1444   ; c = toupper(_getch()) ;
00001080  2F00      1445          move.l    D0,-(A7)
00001082  4EB8 0B68 1446          jsr       __getch
00001086  2200      1447          move.l    D0,D1
00001088  201F      1448          move.l    (A7)+,D0
0000108A  2F01      1449          move.l    D1,-(A7)
0000108C  4EB9 0000 1450          jsr       _toupper
00001090  54F2      
00001092  584F      1451          addq.w    #4,A7
00001094  1C00      1452          move.b    D0,D6
                    1453   ; if(c == 0x1b )      // if break
00001096  0C06 001B 1454          cmp.b     #27,D6
0000109A  6604      1455          bne.s     Load_SRecordFile_6
                    1456   ; return;
0000109C  6000 0132 1457          bra       Load_SRecordFile_8
                    1458   Load_SRecordFile_6:
000010A0  0C06 0053 1459          cmp.b     #83,D6
000010A4  66DA      1460          bne       Load_SRecordFile_4
                    1461   ; }while(c != (char)('S'));   // wait for S start of header
                    1462   ; HeaderType = _getch() ;
000010A6  4EB8 0B68 1463          jsr       __getch
000010AA  1600      1464          move.b    D0,D3
                    1465   ; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
000010AC  0C03 0030 1466          cmp.b     #48,D3
000010B0  6706      1467          beq.s     Load_SRecordFile_11
000010B2  0C03 0035 1468          cmp.b     #53,D3
000010B6  6604      1469          bne.s     Load_SRecordFile_9
                    1470   Load_SRecordFile_11:
                    1471   ; continue ;
000010B8  6000 00D2 1472          bra       Load_SRecordFile_23
                    1473   Load_SRecordFile_9:
                    1474   ; if(HeaderType >= (char)('7'))
000010BC  0C03 0037 1475          cmp.b     #55,D3
000010C0  6D04      1476          blt.s     Load_SRecordFile_12
                    1477   ; break ;                 // end load on s7,s8,s9 records
000010C2  6000 00CC 1478          bra       Load_SRecordFile_3
                    1479   Load_SRecordFile_12:
                    1480   ; // get the bytecount
                    1481   ; ByteCount = Get2HexDigits(&CheckSum) ;
000010C6  2F0A      1482          move.l    A2,-(A7)
000010C8  4E93      1483          jsr       (A3)
000010CA  584F      1484          addq.w    #4,A7
000010CC  2D40 FFF6 1485          move.l    D0,-10(A6)
                    1486   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1487   ; if(HeaderType == (char)('1')) {
000010D0  0C03 0031 1488          cmp.b     #49,D3
000010D4  660E      1489          bne.s     Load_SRecordFile_14
                    1490   ; AddressSize = 2 ;       // 2 byte address
000010D6  7A02      1491          moveq     #2,D5
                    1492   ; Address = Get4HexDigits(&CheckSum);
000010D8  2F0A      1493          move.l    A2,-(A7)
000010DA  4EB8 0C58 1494          jsr       _Get4HexDigits
000010DE  584F      1495          addq.w    #4,A7
000010E0  2800      1496          move.l    D0,D4
000010E2  6020      1497          bra.s     Load_SRecordFile_17
                    1498   Load_SRecordFile_14:
                    1499   ; }
                    1500   ; else if (HeaderType == (char)('2')) {
000010E4  0C03 0032 1501          cmp.b     #50,D3
000010E8  660E      1502          bne.s     Load_SRecordFile_16
                    1503   ; AddressSize = 3 ;       // 3 byte address
000010EA  7A03      1504          moveq     #3,D5
                    1505   ; Address = Get6HexDigits(&CheckSum) ;
000010EC  2F0A      1506          move.l    A2,-(A7)
000010EE  4EB8 0C7E 1507          jsr       _Get6HexDigits
000010F2  584F      1508          addq.w    #4,A7
000010F4  2800      1509          move.l    D0,D4
000010F6  600C      1510          bra.s     Load_SRecordFile_17
                    1511   Load_SRecordFile_16:
                    1512   ; }
                    1513   ; else    {
                    1514   ; AddressSize = 4 ;       // 4 byte address
000010F8  7A04      1515          moveq     #4,D5
                    1516   ; Address = Get8HexDigits(&CheckSum) ;
000010FA  2F0A      1517          move.l    A2,-(A7)
000010FC  4EB8 0CA4 1518          jsr       _Get8HexDigits
00001100  584F      1519          addq.w    #4,A7
00001102  2800      1520          move.l    D0,D4
                    1521   Load_SRecordFile_17:
                    1522   ; }
                    1523   ; RamPtr = (char *)(Address) ;                            // point to download area
00001104  2D44 FFFC 1524          move.l    D4,-4(A6)
                    1525   ; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
00001108  202E FFF6 1526          move.l    -10(A6),D0
0000110C  9085      1527          sub.l     D5,D0
0000110E  5380      1528          subq.l    #1,D0
00001110  2D40 FFE2 1529          move.l    D0,-30(A6)
                    1530   ; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
00001114  4282      1531          clr.l     D2
                    1532   Load_SRecordFile_18:
00001116  B4AE FFE2 1533          cmp.l     -30(A6),D2
0000111A  6C1E      1534          bge.s     Load_SRecordFile_20
                    1535   ; DataByte = Get2HexDigits(&CheckSum) ;
0000111C  2F0A      1536          move.l    A2,-(A7)
0000111E  4E93      1537          jsr       (A3)
00001120  584F      1538          addq.w    #4,A7
00001122  2D40 FFDE 1539          move.l    D0,-34(A6)
                    1540   ; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
00001126  202E FFDE 1541          move.l    -34(A6),D0
0000112A  206E FFFC 1542          move.l    -4(A6),A0
0000112E  52AE FFFC 1543          addq.l    #1,-4(A6)
00001132  1080      1544          move.b    D0,(A0)
                    1545   ; ByteTotal++;
00001134  524D      1546          addq.w    #1,A5
00001136  5282      1547          addq.l    #1,D2
00001138  60DC      1548          bra       Load_SRecordFile_18
                    1549   Load_SRecordFile_20:
                    1550   ; }
                    1551   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1552   ; ReadCheckSum = Get2HexDigits(0) ;
0000113A  42A7      1553          clr.l     -(A7)
0000113C  4E93      1554          jsr       (A3)
0000113E  584F      1555          addq.w    #4,A7
00001140  1D40 FFFB 1556          move.b    D0,-5(A6)
                    1557   ; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
00001144  1012      1558          move.b    (A2),D0
00001146  4600      1559          not.b     D0
00001148  4880      1560          ext.w     D0
0000114A  C07C 00FF 1561          and.w     #255,D0
0000114E  122E FFFB 1562          move.b    -5(A6),D1
00001152  4881      1563          ext.w     D1
00001154  C27C 00FF 1564          and.w     #255,D1
00001158  B041      1565          cmp.w     D1,D0
0000115A  6708      1566          beq.s     Load_SRecordFile_21
                    1567   ; LoadFailed = 1 ;
0000115C  7E01      1568          moveq     #1,D7
                    1569   ; FailedAddress = Address ;
0000115E  2D44 FFE6 1570          move.l    D4,-26(A6)
                    1571   ; break;
00001162  602C      1572          bra.s     Load_SRecordFile_3
                    1573   Load_SRecordFile_21:
                    1574   ; }
                    1575   ; SRecordCount++ ;
00001164  52AE FFEE 1576          addq.l    #1,-18(A6)
                    1577   ; // display feedback on progress
                    1578   ; if(SRecordCount % 25 == 0)
00001168  2F2E FFEE 1579          move.l    -18(A6),-(A7)
0000116C  4878 0019 1580          pea       25
00001170  4EB9 0000 1581          jsr       LDIV
00001174  5344      
00001176  202F 0004 1582          move.l    4(A7),D0
0000117A  504F      1583          addq.w    #8,A7
0000117C  4A80      1584          tst.l     D0
0000117E  660C      1585          bne.s     Load_SRecordFile_23
                    1586   ; putchar('.') ;
00001180  4878 002E 1587          pea       46
00001184  4EB9 0000 1588          jsr       _putch
00001188  5410      
0000118A  584F      1589          addq.w    #4,A7
                    1590   Load_SRecordFile_23:
0000118C  6000 FEF0 1591          bra       Load_SRecordFile_1
                    1592   Load_SRecordFile_3:
                    1593   ; }
                    1594   ; if(LoadFailed == 1) {
00001190  0C87 0000 1595          cmp.l     #1,D7
00001194  0001      
00001196  6610      1596          bne.s     Load_SRecordFile_25
                    1597   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
00001198  2F2E FFE6 1598          move.l    -26(A6),-(A7)
0000119C  4879 0000 1599          pea       @m68kde~2_21.L
000011A0  607A      
000011A2  4E94      1600          jsr       (A4)
000011A4  504F      1601          addq.w    #8,A7
000011A6  600C      1602          bra.s     Load_SRecordFile_26
                    1603   Load_SRecordFile_25:
                    1604   ; }
                    1605   ; else
                    1606   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
000011A8  2F0D      1607          move.l    A5,-(A7)
000011AA  4879 0000 1608          pea       @m68kde~2_22.L
000011AE  60A0      
000011B0  4E94      1609          jsr       (A4)
000011B2  504F      1610          addq.w    #8,A7
                    1611   Load_SRecordFile_26:
                    1612   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1613   ; for(i = 0; i < 400000; i ++)
000011B4  4282      1614          clr.l     D2
                    1615   Load_SRecordFile_27:
000011B6  0C82 0006 1616          cmp.l     #400000,D2
000011BA  1A80      
000011BC  6C04      1617          bge.s     Load_SRecordFile_29
000011BE  5282      1618          addq.l    #1,D2
000011C0  60F4      1619          bra       Load_SRecordFile_27
                    1620   Load_SRecordFile_29:
                    1621   ; ;
                    1622   ; FlushKeyboard() ;
000011C2  4EB8 0BA6 1623          jsr       _FlushKeyboard
                    1624   ; Echo = 1;
000011C6  23FC 0000 1625          move.l    #1,_Echo.L
000011CA  0001 0B00 
000011CE  00E0      
                    1626   Load_SRecordFile_8:
000011D0  4CDF 3CFC 1627          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000011D4  4E5E      1628          unlk      A6
000011D6  4E75      1629          rts
                    1630   ; }
                    1631   ; void MemoryChange(void)
                    1632   ; {
                    1633   _MemoryChange:
000011D8  48E7 3820 1634          movem.l   D2/D3/D4/A2,-(A7)
000011DC  45F9 0000 1635          lea       _printf.L,A2
000011E0  551E      
                    1636   ; unsigned char *RamPtr,c ; // pointer to memory
                    1637   ; int Data ;
                    1638   ; printf("\r\nExamine and Change Memory") ;
000011E2  4879 0000 1639          pea       @m68kde~2_23.L
000011E6  60C2      
000011E8  4E92      1640          jsr       (A2)
000011EA  584F      1641          addq.w    #4,A7
                    1642   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
000011EC  4879 0000 1643          pea       @m68kde~2_24.L
000011F0  60DE      
000011F2  4E92      1644          jsr       (A2)
000011F4  584F      1645          addq.w    #4,A7
                    1646   ; printf("\r\nEnter Address: ") ;
000011F6  4879 0000 1647          pea       @m68kde~2_25.L
000011FA  6124      
000011FC  4E92      1648          jsr       (A2)
000011FE  584F      1649          addq.w    #4,A7
                    1650   ; RamPtr = Get8HexDigits(0) ;
00001200  42A7      1651          clr.l     -(A7)
00001202  4EB8 0CA4 1652          jsr       _Get8HexDigits
00001206  584F      1653          addq.w    #4,A7
00001208  2600      1654          move.l    D0,D3
                    1655   ; while(1)    {
                    1656   MemoryChange_1:
                    1657   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
0000120A  2043      1658          move.l    D3,A0
0000120C  1210      1659          move.b    (A0),D1
0000120E  C2BC 0000 1660          and.l     #255,D1
00001212  00FF      
00001214  2F01      1661          move.l    D1,-(A7)
00001216  2F03      1662          move.l    D3,-(A7)
00001218  4879 0000 1663          pea       @m68kde~2_26.L
0000121C  6136      
0000121E  4E92      1664          jsr       (A2)
00001220  DEFC 000C 1665          add.w     #12,A7
                    1666   ; c = tolower(_getch()) ;
00001224  2F00      1667          move.l    D0,-(A7)
00001226  4EB8 0B68 1668          jsr       __getch
0000122A  2200      1669          move.l    D0,D1
0000122C  201F      1670          move.l    (A7)+,D0
0000122E  2F01      1671          move.l    D1,-(A7)
00001230  4EB9 0000 1672          jsr       _tolower
00001234  547C      
00001236  584F      1673          addq.w    #4,A7
00001238  1400      1674          move.b    D0,D2
                    1675   ; if(c == (char)(0x1b))
0000123A  0C02 001B 1676          cmp.b     #27,D2
0000123E  6604      1677          bne.s     MemoryChange_4
                    1678   ; return ;                                // abort on escape
00001240  6000 0090 1679          bra       MemoryChange_6
                    1680   MemoryChange_4:
                    1681   ; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001244  0C02 0030 1682          cmp.b     #48,D2
00001248  6506      1683          blo.s     MemoryChange_10
0000124A  0C02 0039 1684          cmp.b     #57,D2
0000124E  6310      1685          bls.s     MemoryChange_9
                    1686   MemoryChange_10:
00001250  0C02 0061 1687          cmp.b     #97,D2
00001254  6500 006E 1688          blo       MemoryChange_7
00001258  0C02 0066 1689          cmp.b     #102,D2
0000125C  6200 0066 1690          bhi       MemoryChange_7
                    1691   MemoryChange_9:
                    1692   ; Data = (xtod(c) << 4) | (xtod(_getch()));
00001260  C4BC 0000 1693          and.l     #255,D2
00001264  00FF      
00001266  2F02      1694          move.l    D2,-(A7)
00001268  4EB8 0BD2 1695          jsr       _xtod
0000126C  584F      1696          addq.w    #4,A7
0000126E  C0BC 0000 1697          and.l     #255,D0
00001272  00FF      
00001274  E980      1698          asl.l     #4,D0
00001276  2F00      1699          move.l    D0,-(A7)
00001278  2F01      1700          move.l    D1,-(A7)
0000127A  4EB8 0B68 1701          jsr       __getch
0000127E  221F      1702          move.l    (A7)+,D1
00001280  2F00      1703          move.l    D0,-(A7)
00001282  4EB8 0BD2 1704          jsr       _xtod
00001286  584F      1705          addq.w    #4,A7
00001288  2200      1706          move.l    D0,D1
0000128A  201F      1707          move.l    (A7)+,D0
0000128C  C2BC 0000 1708          and.l     #255,D1
00001290  00FF      
00001292  8081      1709          or.l      D1,D0
00001294  2800      1710          move.l    D0,D4
                    1711   ; *RamPtr = (char)(Data) ;
00001296  2043      1712          move.l    D3,A0
00001298  1084      1713          move.b    D4,(A0)
                    1714   ; if(*RamPtr != Data) {
0000129A  2043      1715          move.l    D3,A0
0000129C  1010      1716          move.b    (A0),D0
0000129E  C0BC 0000 1717          and.l     #255,D0
000012A2  00FF      
000012A4  B084      1718          cmp.l     D4,D0
000012A6  671A      1719          beq.s     MemoryChange_11
                    1720   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
000012A8  2043      1721          move.l    D3,A0
000012AA  1210      1722          move.b    (A0),D1
000012AC  C2BC 0000 1723          and.l     #255,D1
000012B0  00FF      
000012B2  2F01      1724          move.l    D1,-(A7)
000012B4  2F04      1725          move.l    D4,-(A7)
000012B6  4879 0000 1726          pea       @m68kde~2_27.L
000012BA  6148      
000012BC  4E92      1727          jsr       (A2)
000012BE  DEFC 000C 1728          add.w     #12,A7
                    1729   MemoryChange_11:
000012C2  6008      1730          bra.s     MemoryChange_13
                    1731   MemoryChange_7:
                    1732   ; }
                    1733   ; }
                    1734   ; else if(c == (char)('-'))
000012C4  0C02 002D 1735          cmp.b     #45,D2
000012C8  6602      1736          bne.s     MemoryChange_13
                    1737   ; RamPtr -= 2 ; ;
000012CA  5583      1738          subq.l    #2,D3
                    1739   MemoryChange_13:
                    1740   ; RamPtr ++ ;
000012CC  5283      1741          addq.l    #1,D3
000012CE  6000 FF3A 1742          bra       MemoryChange_1
                    1743   MemoryChange_6:
000012D2  4CDF 041C 1744          movem.l   (A7)+,D2/D3/D4/A2
000012D6  4E75      1745          rts
                    1746   ; }
                    1747   ; }
                    1748   ; // /******************************************************************************************
                    1749   ; // ** The following code is for the SPI controller
                    1750   ; // *******************************************************************************************/
                    1751   ; // // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1752   ; // // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1753   ; // int TestForSPITransmitDataComplete(void) {
                    1754   ; //     return SPI_Status & 0x80;
                    1755   ; // }
                    1756   ; // /************************************************************************************
                    1757   ; // ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1758   ; // ************************************************************************************/
                    1759   ; // void SPI_Init(void)
                    1760   ; // {
                    1761   ; //     // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1762   ; //     // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1763   ; //     // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1764   ; //     // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1765   ; //     SPI_Control = 0x53;
                    1766   ; //     SPI_Ext = 0x00;
                    1767   ; //     SPI_CS = 0xff;
                    1768   ; //     SPI_Status |= 0xc0;
                    1769   ; // }
                    1770   ; // /************************************************************************************
                    1771   ; // ** return ONLY when the SPI controller has finished transmitting a byte
                    1772   ; // ************************************************************************************/
                    1773   ; // void WaitForSPITransmitComplete(void)
                    1774   ; // {
                    1775   ; //     while (!TestForSPITransmitDataComplete());
                    1776   ; //     SPI_Status |= 0xc0;
                    1777   ; // }
                    1778   ; // /************************************************************************************
                    1779   ; // ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1780   ; // ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1781   ; // ************************************************************************************/
                    1782   ; // int WriteSPIChar(int c)
                    1783   ; // {
                    1784   ; //     SPI_Data = c;
                    1785   ; //     WaitForSPITransmitComplete();
                    1786   ; //     return SPI_Data;
                    1787   ; // }
                    1788   ; // void SetSPIFlashWriteEnableLatch(void) {
                    1789   ; //     Enable_SPI_CS();
                    1790   ; //     WriteSPIChar(0x06);
                    1791   ; //     Disable_SPI_CS();
                    1792   ; // }
                    1793   ; // void ClearSPIFlashWriteEnableLatch(void) {
                    1794   ; //     Enable_SPI_CS();
                    1795   ; //     WriteSPIChar(0x04);
                    1796   ; //     Disable_SPI_CS();
                    1797   ; // }
                    1798   ; // int ReadSPIFlashStatusReg(void) {
                    1799   ; //     int status;
                    1800   ; //     Enable_SPI_CS();
                    1801   ; //     WriteSPIChar(0x05);
                    1802   ; //     status = WriteSPIChar(0x00);
                    1803   ; //     Disable_SPI_CS();
                    1804   ; //     return status;
                    1805   ; // }
                    1806   ; // void WaitForSPIFlashWriteCompletion(void) {
                    1807   ; //     Enable_SPI_CS();
                    1808   ; //     WriteSPIChar(0x05);
                    1809   ; //     while(WriteSPIChar(0x00) & 0x01);
                    1810   ; //     Disable_SPI_CS();
                    1811   ; // }
                    1812   ; // void ReadSPIFlashData(int FlashAddress, unsigned char *MemoryAddress, int size) {
                    1813   ; //     int i;
                    1814   ; //     Enable_SPI_CS();
                    1815   ; //     WriteSPIChar(0x03);
                    1816   ; //     WriteSPIChar(FlashAddress >> 16);
                    1817   ; //     WriteSPIChar(FlashAddress >> 8);
                    1818   ; //     WriteSPIChar(FlashAddress);
                    1819   ; //     for (i = 0; i < size; i++) {
                    1820   ; //         MemoryAddress[i] = (unsigned char) WriteSPIChar(0x00);
                    1821   ; //     }
                    1822   ; //     Disable_SPI_CS();
                    1823   ; // }
                    1824   ; // int WriteSPIFlashData(int FlashAddress, unsigned char *MemoryAddress, int size) {
                    1825   ; //     int chunk_size, addr, i, base = 0;
                    1826   ; //     WaitForSPIFlashWriteCompletion();
                    1827   ; //     while (size > 0) {
                    1828   ; //         addr = FlashAddress + base;
                    1829   ; //         SetSPIFlashWriteEnableLatch();
                    1830   ; //         Enable_SPI_CS();
                    1831   ; //         WriteSPIChar(0x02);
                    1832   ; //         WriteSPIChar(addr >> 16);
                    1833   ; //         WriteSPIChar(addr >> 8);
                    1834   ; //         WriteSPIChar(addr);
                    1835   ; //         chunk_size = (size < 256)? size : 256;
                    1836   ; //         for (i = 0; i < chunk_size; i++) {
                    1837   ; //             WriteSPIChar(MemoryAddress[i + base]);
                    1838   ; //         }
                    1839   ; //         size -= chunk_size;
                    1840   ; //         base += chunk_size;
                    1841   ; //         Disable_SPI_CS();
                    1842   ; //         WaitForSPIFlashWriteCompletion();
                    1843   ; //     }
                    1844   ; //     return 1;
                    1845   ; // }
                    1846   ; // int EraseSPIFlashChip(void) {
                    1847   ; //     SetSPIFlashWriteEnableLatch();
                    1848   ; //     Enable_SPI_CS();
                    1849   ; //     WriteSPIChar(0x60);
                    1850   ; //     Disable_SPI_CS();
                    1851   ; //     WaitForSPIFlashWriteCompletion();
                    1852   ; //     return 1;
                    1853   ; // }
                    1854   ; // int CheckSPIConnection (void)
                    1855   ; // {
                    1856   ; //     int status;
                    1857   ; //     SetSPIFlashWriteEnableLatch();
                    1858   ; //     status = ReadSPIFlashStatusReg();
                    1859   ; //     if (status == 0x02) {
                    1860   ; //         return 1;
                    1861   ; //     }
                    1862   ; //     ClearSPIFlashWriteEnableLatch();
                    1863   ; //     return 0;
                    1864   ; // }
                    1865   ; // /*******************************************************************
                    1866   ; // ** Write a program to SPI Flash Chip from memory and verify by reading back
                    1867   ; // ********************************************************************/
                    1868   ; void ProgramFlashChip(void)
                    1869   ; {
                    1870   _ProgramFlashChip:
000012D8  4E75      1871          rts
                    1872   ; //     unsigned int i, j;
                    1873   ; //     unsigned char *ram_ptr = ProgramStart;
                    1874   ; //     unsigned char Copy[Max_Size];
                    1875   ; //     while(!CheckSPIConnection()) {
                    1876   ; //         printf("\r\nError: Cannot connect to SPI Flash Chip");
                    1877   ; //         printf("\r\nCheck connections and press any key to try again");
                    1878   ; //         _getch();
                    1879   ; //     }
                    1880   ; //     printf("\r\nErasing Flash Chip ...");
                    1881   ; //     if (EraseSPIFlashChip() == 0) {
                    1882   ; //         return;
                    1883   ; //     }
                    1884   ; //     printf("\r\nProgramming Flash Chip ...");
                    1885   ; //     for (j = 0; j < T256K/Max_Size; j++) {
                    1886   ; //         if (WriteSPIFlashData(Max_Size*j, ram_ptr, Max_Size) == 0) {
                    1887   ; //             return;
                    1888   ; //         }
                    1889   ; //         ram_ptr += Max_Size;
                    1890   ; //         printf(".");
                    1891   ; //     }
                    1892   ; //     printf("\r\nProgramming Complete") ;
                    1893   ; //     printf("\r\nVerifying Flash Chip ...");
                    1894   ; //     ram_ptr = ProgramStart;
                    1895   ; //     for (j = 0; j < T256K/Max_Size; j++) {
                    1896   ; //         ReadSPIFlashData(Max_Size*j, Copy, Max_Size);
                    1897   ; //         for (i = 0; i < Max_Size; i++) {
                    1898   ; //             if (Copy[i] != ram_ptr[i]) {
                    1899   ; //                 printf("\r\nVerify Error at Address: %08X, Expected: %02X, Read: %02X", ram_ptr + i, ram_ptr[i], Copy[i]);
                    1900   ; //                 return;
                    1901   ; //             }
                    1902   ; //         }
                    1903   ; //         printf(".");
                    1904   ; //         ram_ptr += Max_Size;
                    1905   ; //     }
                    1906   ; //     printf("\r\nVerify Complete") ;
                    1907   ; }
                    1908   ; // /*************************************************************************
                    1909   ; // ** Load a program from SPI Flash Chip and copy to Dram
                    1910   ; // **************************************************************************/
                    1911   ; void LoadFromFlashChip(void)
                    1912   ; {
                    1913   _LoadFromFlashChip:
000012DA  4E75      1914          rts
                    1915   ; //     unsigned int i, j;
                    1916   ; //     unsigned char *ram_ptr = ProgramStart;
                    1917   ; //     unsigned char Data[Max_Size];
                    1918   ; //     while(!CheckSPIConnection()) {
                    1919   ; //         printf("\r\nError: Cannot connect to SPI Flash Chip");
                    1920   ; //         printf("\r\nCheck connections and press any key to try again");
                    1921   ; //         _getch();
                    1922   ; //     }
                    1923   ; //     printf("\r\nLoading Program from Flash Chip ...");
                    1924   ; //     for (j = 0; j < T256K/Max_Size; j++) {
                    1925   ; //         ReadSPIFlashData(Max_Size*j, Data, Max_Size);
                    1926   ; //         for (i = 0; i < Max_Size; i++) {
                    1927   ; //             ram_ptr[i] = Data[i];
                    1928   ; //         }
                    1929   ; //         ram_ptr += Max_Size;
                    1930   ; //         printf(".");
                    1931   ; //     }
                    1932   ; //     printf("\r\nLoading Complete") ;
                    1933   ; }
                    1934   ; // get rid of excess spaces
                    1935   ; void FormatInstructionForTrace(void)
                    1936   ; {
                    1937   _FormatInstructionForTrace:
000012DC  4E56 FF9C 1938          link      A6,#-100
000012E0  48E7 3C20 1939          movem.l   D2/D3/D4/D5/A2,-(A7)
000012E4  45EE FF9C 1940          lea       -100(A6),A2
                    1941   ; unsigned short int i ;
                    1942   ; char c, temp[100], *iptr, *tempptr ;
                    1943   ; for(i=0; i < 100; i++)
000012E8  4244      1944          clr.w     D4
                    1945   FormatInstructionForTrace_1:
000012EA  0C44 0064 1946          cmp.w     #100,D4
000012EE  640E      1947          bhs.s     FormatInstructionForTrace_3
                    1948   ; temp[i] = 0 ;
000012F0  C8BC 0000 1949          and.l     #65535,D4
000012F4  FFFF      
000012F6  4232 4800 1950          clr.b     0(A2,D4.L)
000012FA  5244      1951          addq.w    #1,D4
000012FC  60EC      1952          bra       FormatInstructionForTrace_1
                    1953   FormatInstructionForTrace_3:
                    1954   ; iptr = Instruction ;
000012FE  41F9 0B00 1955          lea       _Instruction.L,A0
00001302  04E2      
00001304  2408      1956          move.l    A0,D2
                    1957   ; tempptr = temp ;
00001306  2A0A      1958          move.l    A2,D5
                    1959   ; do{
                    1960   FormatInstructionForTrace_4:
                    1961   ; c = *iptr++ ;
00001308  2042      1962          move.l    D2,A0
0000130A  5282      1963          addq.l    #1,D2
0000130C  1610      1964          move.b    (A0),D3
                    1965   ; *tempptr++ = c ;  // copy chars over
0000130E  2045      1966          move.l    D5,A0
00001310  5285      1967          addq.l    #1,D5
00001312  1083      1968          move.b    D3,(A0)
                    1969   ; if(c == ' ')  {   // if copied space
00001314  0C03 0020 1970          cmp.b     #32,D3
00001318  6622      1971          bne.s     FormatInstructionForTrace_6
                    1972   ; while(*iptr == ' ') {
                    1973   FormatInstructionForTrace_8:
0000131A  2042      1974          move.l    D2,A0
0000131C  1010      1975          move.b    (A0),D0
0000131E  0C00 0020 1976          cmp.b     #32,D0
00001322  660C      1977          bne.s     FormatInstructionForTrace_10
                    1978   ; if(*iptr == 0)  // if end of string then done
00001324  2042      1979          move.l    D2,A0
00001326  1010      1980          move.b    (A0),D0
00001328  6602      1981          bne.s     FormatInstructionForTrace_11
                    1982   ; break ;
0000132A  6004      1983          bra.s     FormatInstructionForTrace_10
                    1984   FormatInstructionForTrace_11:
                    1985   ; iptr++ ; // skip over remaining spaces
0000132C  5282      1986          addq.l    #1,D2
0000132E  60EA      1987          bra       FormatInstructionForTrace_8
                    1988   FormatInstructionForTrace_10:
                    1989   ; }
                    1990   ; strcat(tempptr,iptr) ;
00001330  2F02      1991          move.l    D2,-(A7)
00001332  2F05      1992          move.l    D5,-(A7)
00001334  4EB9 0000 1993          jsr       _strcat
00001338  54DC      
0000133A  504F      1994          addq.w    #8,A7
                    1995   FormatInstructionForTrace_6:
0000133C  4A03      1996          tst.b     D3
0000133E  66C8      1997          bne       FormatInstructionForTrace_4
                    1998   ; }
                    1999   ; }while(c != 0) ;
                    2000   ; strcpyInstruction(temp) ;
00001340  2F0A      2001          move.l    A2,-(A7)
00001342  4EB8 0CE6 2002          jsr       _strcpyInstruction
00001346  584F      2003          addq.w    #4,A7
00001348  4CDF 043C 2004          movem.l   (A7)+,D2/D3/D4/D5/A2
0000134C  4E5E      2005          unlk      A6
0000134E  4E75      2006          rts
                    2007   ; }
                    2008   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    2009   ; // IMPORTANT
                    2010   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    2011   ; // has to be done with an interrupt (IRQ Level 6)
                    2012   ; //
                    2013   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    2014   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    2015   ; //
                    2016   ; // on return from the IRQ service handler, the first access to the user memory program space
                    2017   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    2018   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    2019   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    2020   ; // program area
                    2021   ; //
                    2022   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    2023   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    2024   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    2025   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    2026   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    2027   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    2028   ; void DumpRegisters()
                    2029   ; {
                    2030   _DumpRegisters:
00001350  48E7 3F3C 2031          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001354  45F9 0000 2032          lea       _putch.L,A2
00001358  5410      
0000135A  47F9 0000 2033          lea       _printf.L,A3
0000135E  551E      
00001360  49F9 0B00 2034          lea       _SR.L,A4
00001364  012C      
00001366  4BF9 0B00 2035          lea       _WatchPointString.L,A5
0000136A  01C2      
                    2036   ; short i, x, j, k ;
                    2037   ; unsigned char c, *BytePointer;
                    2038   ; // buld up strings for displaying watchpoints
                    2039   ; for(x = 0; x < (short)(8); x++)
0000136C  4242      2040          clr.w     D2
                    2041   DumpRegisters_1:
0000136E  0C42 0008 2042          cmp.w     #8,D2
00001372  6C00 01C6 2043          bge       DumpRegisters_3
                    2044   ; {
                    2045   ; if(WatchPointSetOrCleared[x] == 1)
00001376  48C2      2046          ext.l     D2
00001378  2002      2047          move.l    D2,D0
0000137A  E588      2048          lsl.l     #2,D0
0000137C  41F9 0B00 2049          lea       _WatchPointSetOrCleared.L,A0
00001380  01A2      
00001382  2030 0800 2050          move.l    0(A0,D0.L),D0
00001386  0C80 0000 2051          cmp.l     #1,D0
0000138A  0001      
0000138C  6600 0186 2052          bne       DumpRegisters_4
                    2053   ; {
                    2054   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
00001390  48C2      2055          ext.l     D2
00001392  2202      2056          move.l    D2,D1
00001394  E589      2057          lsl.l     #2,D1
00001396  41F9 0B00 2058          lea       _WatchPointAddress.L,A0
0000139A  0182      
0000139C  2F30 1800 2059          move.l    0(A0,D1.L),-(A7)
000013A0  4879 0000 2060          pea       @m68kde~2_28.L
000013A4  617C      
000013A6  220D      2061          move.l    A5,D1
000013A8  48C2      2062          ext.l     D2
000013AA  2F00      2063          move.l    D0,-(A7)
000013AC  2002      2064          move.l    D2,D0
000013AE  C1FC 0064 2065          muls      #100,D0
000013B2  D280      2066          add.l     D0,D1
000013B4  201F      2067          move.l    (A7)+,D0
000013B6  2F01      2068          move.l    D1,-(A7)
000013B8  4EB9 0000 2069          jsr       _sprintf
000013BC  54A8      
000013BE  DEFC 000C 2070          add.w     #12,A7
                    2071   ; BytePointer = (char *)(WatchPointAddress[x]) ;
000013C2  48C2      2072          ext.l     D2
000013C4  2002      2073          move.l    D2,D0
000013C6  E588      2074          lsl.l     #2,D0
000013C8  41F9 0B00 2075          lea       _WatchPointAddress.L,A0
000013CC  0182      
000013CE  2A30 0800 2076          move.l    0(A0,D0.L),D5
                    2077   ; for(j = 0; j < (short)(16); j+=2)
000013D2  4243      2078          clr.w     D3
                    2079   DumpRegisters_6:
000013D4  0C43 0010 2080          cmp.w     #16,D3
000013D8  6C00 0082 2081          bge       DumpRegisters_8
                    2082   ; {
                    2083   ; for(k = 0; k < (short)(2); k++)
000013DC  4246      2084          clr.w     D6
                    2085   DumpRegisters_9:
000013DE  0C46 0002 2086          cmp.w     #2,D6
000013E2  6C00 0052 2087          bge       DumpRegisters_11
                    2088   ; {
                    2089   ; sprintf(TempString, "%02X", BytePointer[j+k]) ;
000013E6  2045      2090          move.l    D5,A0
000013E8  48C3      2091          ext.l     D3
000013EA  2203      2092          move.l    D3,D1
000013EC  48C6      2093          ext.l     D6
000013EE  D286      2094          add.l     D6,D1
000013F0  1230 1800 2095          move.b    0(A0,D1.L),D1
000013F4  C2BC 0000 2096          and.l     #255,D1
000013F8  00FF      
000013FA  2F01      2097          move.l    D1,-(A7)
000013FC  4879 0000 2098          pea       @m68kde~2_14.L
00001400  5FD2      
00001402  4879 0B00 2099          pea       _TempString.L
00001406  0546      
00001408  4EB9 0000 2100          jsr       _sprintf
0000140C  54A8      
0000140E  DEFC 000C 2101          add.w     #12,A7
                    2102   ; strcat(WatchPointString[x], TempString) ;
00001412  4879 0B00 2103          pea       _TempString.L
00001416  0546      
00001418  220D      2104          move.l    A5,D1
0000141A  48C2      2105          ext.l     D2
0000141C  2F00      2106          move.l    D0,-(A7)
0000141E  2002      2107          move.l    D2,D0
00001420  C1FC 0064 2108          muls      #100,D0
00001424  D280      2109          add.l     D0,D1
00001426  201F      2110          move.l    (A7)+,D0
00001428  2F01      2111          move.l    D1,-(A7)
0000142A  4EB9 0000 2112          jsr       _strcat
0000142E  54DC      
00001430  504F      2113          addq.w    #8,A7
00001432  5246      2114          addq.w    #1,D6
00001434  60A8      2115          bra       DumpRegisters_9
                    2116   DumpRegisters_11:
                    2117   ; }
                    2118   ; strcat(WatchPointString[x]," ") ;
00001436  4879 0000 2119          pea       @m68kde~2_29.L
0000143A  6184      
0000143C  220D      2120          move.l    A5,D1
0000143E  48C2      2121          ext.l     D2
00001440  2F00      2122          move.l    D0,-(A7)
00001442  2002      2123          move.l    D2,D0
00001444  C1FC 0064 2124          muls      #100,D0
00001448  D280      2125          add.l     D0,D1
0000144A  201F      2126          move.l    (A7)+,D0
0000144C  2F01      2127          move.l    D1,-(A7)
0000144E  4EB9 0000 2128          jsr       _strcat
00001452  54DC      
00001454  504F      2129          addq.w    #8,A7
00001456  5443      2130          addq.w    #2,D3
00001458  6000 FF7A 2131          bra       DumpRegisters_6
                    2132   DumpRegisters_8:
                    2133   ; }
                    2134   ; strcat(WatchPointString[x], "  ") ;
0000145C  4879 0000 2135          pea       @m68kde~2_15.L
00001460  5FD8      
00001462  220D      2136          move.l    A5,D1
00001464  48C2      2137          ext.l     D2
00001466  2F00      2138          move.l    D0,-(A7)
00001468  2002      2139          move.l    D2,D0
0000146A  C1FC 0064 2140          muls      #100,D0
0000146E  D280      2141          add.l     D0,D1
00001470  201F      2142          move.l    (A7)+,D0
00001472  2F01      2143          move.l    D1,-(A7)
00001474  4EB9 0000 2144          jsr       _strcat
00001478  54DC      
0000147A  504F      2145          addq.w    #8,A7
                    2146   ; BytePointer = (char *)(WatchPointAddress[x]) ;
0000147C  48C2      2147          ext.l     D2
0000147E  2002      2148          move.l    D2,D0
00001480  E588      2149          lsl.l     #2,D0
00001482  41F9 0B00 2150          lea       _WatchPointAddress.L,A0
00001486  0182      
00001488  2A30 0800 2151          move.l    0(A0,D0.L),D5
                    2152   ; for(j = 0; j < (short)(16); j++)
0000148C  4243      2153          clr.w     D3
                    2154   DumpRegisters_12:
0000148E  0C43 0010 2155          cmp.w     #16,D3
00001492  6C00 007E 2156          bge       DumpRegisters_14
                    2157   ; {
                    2158   ; c = ((char)(BytePointer[j]) & 0x7f) ;
00001496  2045      2159          move.l    D5,A0
00001498  48C3      2160          ext.l     D3
0000149A  1030 3800 2161          move.b    0(A0,D3.L),D0
0000149E  C03C 007F 2162          and.b     #127,D0
000014A2  1E00      2163          move.b    D0,D7
                    2164   ; if((c > (char)(0x7f)) || (c < (char)(' ')))
000014A4  0C07 007F 2165          cmp.b     #127,D7
000014A8  6206      2166          bhi.s     DumpRegisters_17
000014AA  0C07 0020 2167          cmp.b     #32,D7
000014AE  6416      2168          bhs.s     DumpRegisters_15
                    2169   DumpRegisters_17:
                    2170   ; sprintf(TempString, ".") ;
000014B0  4879 0000 2171          pea       @m68kde~2_30.L
000014B4  6186      
000014B6  4879 0B00 2172          pea       _TempString.L
000014BA  0546      
000014BC  4EB9 0000 2173          jsr       _sprintf
000014C0  54A8      
000014C2  504F      2174          addq.w    #8,A7
000014C4  6026      2175          bra.s     DumpRegisters_16
                    2176   DumpRegisters_15:
                    2177   ; else
                    2178   ; sprintf(TempString, "%c", BytePointer[j]) ;
000014C6  2045      2179          move.l    D5,A0
000014C8  48C3      2180          ext.l     D3
000014CA  1230 3800 2181          move.b    0(A0,D3.L),D1
000014CE  C2BC 0000 2182          and.l     #255,D1
000014D2  00FF      
000014D4  2F01      2183          move.l    D1,-(A7)
000014D6  4879 0000 2184          pea       @m68kde~2_31.L
000014DA  6188      
000014DC  4879 0B00 2185          pea       _TempString.L
000014E0  0546      
000014E2  4EB9 0000 2186          jsr       _sprintf
000014E6  54A8      
000014E8  DEFC 000C 2187          add.w     #12,A7
                    2188   DumpRegisters_16:
                    2189   ; strcat(WatchPointString[x], TempString) ;
000014EC  4879 0B00 2190          pea       _TempString.L
000014F0  0546      
000014F2  220D      2191          move.l    A5,D1
000014F4  48C2      2192          ext.l     D2
000014F6  2F00      2193          move.l    D0,-(A7)
000014F8  2002      2194          move.l    D2,D0
000014FA  C1FC 0064 2195          muls      #100,D0
000014FE  D280      2196          add.l     D0,D1
00001500  201F      2197          move.l    (A7)+,D0
00001502  2F01      2198          move.l    D1,-(A7)
00001504  4EB9 0000 2199          jsr       _strcat
00001508  54DC      
0000150A  504F      2200          addq.w    #8,A7
0000150C  5243      2201          addq.w    #1,D3
0000150E  6000 FF7E 2202          bra       DumpRegisters_12
                    2203   DumpRegisters_14:
00001512  6020      2204          bra.s     DumpRegisters_5
                    2205   DumpRegisters_4:
                    2206   ; }
                    2207   ; }
                    2208   ; else
                    2209   ; strcpy(WatchPointString[x], "") ;
00001514  4879 0000 2210          pea       @m68kde~2_32.L
00001518  618C      
0000151A  220D      2211          move.l    A5,D1
0000151C  48C2      2212          ext.l     D2
0000151E  2F00      2213          move.l    D0,-(A7)
00001520  2002      2214          move.l    D2,D0
00001522  C1FC 0064 2215          muls      #100,D0
00001526  D280      2216          add.l     D0,D1
00001528  201F      2217          move.l    (A7)+,D0
0000152A  2F01      2218          move.l    D1,-(A7)
0000152C  4EB9 0000 2219          jsr       _strcpy
00001530  5322      
00001532  504F      2220          addq.w    #8,A7
                    2221   DumpRegisters_5:
00001534  5242      2222          addq.w    #1,D2
00001536  6000 FE36 2223          bra       DumpRegisters_1
                    2224   DumpRegisters_3:
                    2225   ; }
                    2226   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
0000153A  2F39 0B00 2227          move.l    _a0.L,-(A7)
0000153E  0104      
00001540  2F39 0B00 2228          move.l    _d0.L,-(A7)
00001544  00E4      
00001546  4879 0000 2229          pea       @m68kde~2_33.L
0000154A  618E      
0000154C  4E93      2230          jsr       (A3)
0000154E  DEFC 000C 2231          add.w     #12,A7
                    2232   ; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
00001552  2F39 0B00 2233          move.l    _a1.L,-(A7)
00001556  0108      
00001558  2F39 0B00 2234          move.l    _d1.L,-(A7)
0000155C  00E8      
0000155E  4879 0000 2235          pea       @m68kde~2_34.L
00001562  61AA      
00001564  4E93      2236          jsr       (A3)
00001566  DEFC 000C 2237          add.w     #12,A7
                    2238   ; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
0000156A  2F39 0B00 2239          move.l    _a2.L,-(A7)
0000156E  010C      
00001570  2F39 0B00 2240          move.l    _d2.L,-(A7)
00001574  00EC      
00001576  4879 0000 2241          pea       @m68kde~2_35.L
0000157A  61C4      
0000157C  4E93      2242          jsr       (A3)
0000157E  DEFC 000C 2243          add.w     #12,A7
                    2244   ; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
00001582  2F39 0B00 2245          move.l    _a3.L,-(A7)
00001586  0110      
00001588  2F39 0B00 2246          move.l    _d3.L,-(A7)
0000158C  00F0      
0000158E  4879 0000 2247          pea       @m68kde~2_36.L
00001592  61DE      
00001594  4E93      2248          jsr       (A3)
00001596  DEFC 000C 2249          add.w     #12,A7
                    2250   ; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
0000159A  2F39 0B00 2251          move.l    _a4.L,-(A7)
0000159E  0114      
000015A0  2F39 0B00 2252          move.l    _d4.L,-(A7)
000015A4  00F4      
000015A6  4879 0000 2253          pea       @m68kde~2_37.L
000015AA  61F8      
000015AC  4E93      2254          jsr       (A3)
000015AE  DEFC 000C 2255          add.w     #12,A7
                    2256   ; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
000015B2  2F39 0B00 2257          move.l    _a5.L,-(A7)
000015B6  0118      
000015B8  2F39 0B00 2258          move.l    _d5.L,-(A7)
000015BC  00F8      
000015BE  4879 0000 2259          pea       @m68kde~2_38.L
000015C2  6212      
000015C4  4E93      2260          jsr       (A3)
000015C6  DEFC 000C 2261          add.w     #12,A7
                    2262   ; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
000015CA  2F39 0B00 2263          move.l    _a6.L,-(A7)
000015CE  011C      
000015D0  2F39 0B00 2264          move.l    _d6.L,-(A7)
000015D4  00FC      
000015D6  4879 0000 2265          pea       @m68kde~2_39.L
000015DA  622C      
000015DC  4E93      2266          jsr       (A3)
000015DE  DEFC 000C 2267          add.w     #12,A7
                    2268   ; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
000015E2  3214      2269          move.w    (A4),D1
000015E4  C27C 2000 2270          and.w     #8192,D1
000015E8  0C41 2000 2271          cmp.w     #8192,D1
000015EC  6608      2272          bne.s     DumpRegisters_18
000015EE  2239 0B00 2273          move.l    _SSP.L,D1
000015F2  0124      
000015F4  6006      2274          bra.s     DumpRegisters_19
                    2275   DumpRegisters_18:
000015F6  2239 0B00 2276          move.l    _USP.L,D1
000015FA  0128      
                    2277   DumpRegisters_19:
000015FC  2F01      2278          move.l    D1,-(A7)
000015FE  2F39 0B00 2279          move.l    _d7.L,-(A7)
00001602  0100      
00001604  4879 0000 2280          pea       @m68kde~2_40.L
00001608  6246      
0000160A  4E93      2281          jsr       (A3)
0000160C  DEFC 000C 2282          add.w     #12,A7
                    2283   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
00001610  2F39 0B00 2284          move.l    _USP.L,-(A7)
00001614  0128      
00001616  4879 0000 2285          pea       @m68kde~2_41.L
0000161A  6260      
0000161C  4E93      2286          jsr       (A3)
0000161E  504F      2287          addq.w    #8,A7
                    2288   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
00001620  2F39 0B00 2289          move.l    _SSP.L,-(A7)
00001624  0124      
00001626  4879 0000 2290          pea       @m68kde~2_42.L
0000162A  627E      
0000162C  4E93      2291          jsr       (A3)
0000162E  504F      2292          addq.w    #8,A7
                    2293   ; printf("\r\n SR = $%04X   ",SR) ;
00001630  3214      2294          move.w    (A4),D1
00001632  C2BC 0000 2295          and.l     #65535,D1
00001636  FFFF      
00001638  2F01      2296          move.l    D1,-(A7)
0000163A  4879 0000 2297          pea       @m68kde~2_43.L
0000163E  62A0      
00001640  4E93      2298          jsr       (A3)
00001642  504F      2299          addq.w    #8,A7
                    2300   ; // display the status word in characters etc.
                    2301   ; printf("   [") ;
00001644  4879 0000 2302          pea       @m68kde~2_44.L
00001648  62B2      
0000164A  4E93      2303          jsr       (A3)
0000164C  584F      2304          addq.w    #4,A7
                    2305   ; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
0000164E  3014      2306          move.w    (A4),D0
00001650  C07C 8000 2307          and.w     #32768,D0
00001654  0C40 8000 2308          cmp.w     #32768,D0
00001658  660A      2309          bne.s     DumpRegisters_20
0000165A  4878 0054 2310          pea       84
0000165E  4E92      2311          jsr       (A2)
00001660  584F      2312          addq.w    #4,A7
00001662  6008      2313          bra.s     DumpRegisters_21
                    2314   DumpRegisters_20:
00001664  4878 002D 2315          pea       45
00001668  4E92      2316          jsr       (A2)
0000166A  584F      2317          addq.w    #4,A7
                    2318   DumpRegisters_21:
                    2319   ; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
0000166C  3014      2320          move.w    (A4),D0
0000166E  C07C 2000 2321          and.w     #8192,D0
00001672  0C40 2000 2322          cmp.w     #8192,D0
00001676  660A      2323          bne.s     DumpRegisters_22
00001678  4878 0053 2324          pea       83
0000167C  4E92      2325          jsr       (A2)
0000167E  584F      2326          addq.w    #4,A7
00001680  6008      2327          bra.s     DumpRegisters_23
                    2328   DumpRegisters_22:
00001682  4878 0055 2329          pea       85
00001686  4E92      2330          jsr       (A2)
00001688  584F      2331          addq.w    #4,A7
                    2332   DumpRegisters_23:
                    2333   ; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
0000168A  3014      2334          move.w    (A4),D0
0000168C  C07C 0400 2335          and.w     #1024,D0
00001690  0C40 0400 2336          cmp.w     #1024,D0
00001694  660A      2337          bne.s     DumpRegisters_24
00001696  4878 0031 2338          pea       49
0000169A  4E92      2339          jsr       (A2)
0000169C  584F      2340          addq.w    #4,A7
0000169E  6008      2341          bra.s     DumpRegisters_25
                    2342   DumpRegisters_24:
000016A0  4878 0030 2343          pea       48
000016A4  4E92      2344          jsr       (A2)
000016A6  584F      2345          addq.w    #4,A7
                    2346   DumpRegisters_25:
                    2347   ; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
000016A8  3014      2348          move.w    (A4),D0
000016AA  C07C 0200 2349          and.w     #512,D0
000016AE  0C40 0200 2350          cmp.w     #512,D0
000016B2  660A      2351          bne.s     DumpRegisters_26
000016B4  4878 0031 2352          pea       49
000016B8  4E92      2353          jsr       (A2)
000016BA  584F      2354          addq.w    #4,A7
000016BC  6008      2355          bra.s     DumpRegisters_27
                    2356   DumpRegisters_26:
000016BE  4878 0030 2357          pea       48
000016C2  4E92      2358          jsr       (A2)
000016C4  584F      2359          addq.w    #4,A7
                    2360   DumpRegisters_27:
                    2361   ; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
000016C6  3014      2362          move.w    (A4),D0
000016C8  C07C 0100 2363          and.w     #256,D0
000016CC  0C40 0100 2364          cmp.w     #256,D0
000016D0  660A      2365          bne.s     DumpRegisters_28
000016D2  4878 0031 2366          pea       49
000016D6  4E92      2367          jsr       (A2)
000016D8  584F      2368          addq.w    #4,A7
000016DA  6008      2369          bra.s     DumpRegisters_29
                    2370   DumpRegisters_28:
000016DC  4878 0030 2371          pea       48
000016E0  4E92      2372          jsr       (A2)
000016E2  584F      2373          addq.w    #4,A7
                    2374   DumpRegisters_29:
                    2375   ; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
000016E4  3014      2376          move.w    (A4),D0
000016E6  C07C 0010 2377          and.w     #16,D0
000016EA  0C40 0010 2378          cmp.w     #16,D0
000016EE  660A      2379          bne.s     DumpRegisters_30
000016F0  4878 0058 2380          pea       88
000016F4  4E92      2381          jsr       (A2)
000016F6  584F      2382          addq.w    #4,A7
000016F8  6008      2383          bra.s     DumpRegisters_31
                    2384   DumpRegisters_30:
000016FA  4878 002D 2385          pea       45
000016FE  4E92      2386          jsr       (A2)
00001700  584F      2387          addq.w    #4,A7
                    2388   DumpRegisters_31:
                    2389   ; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
00001702  3014      2390          move.w    (A4),D0
00001704  C07C 0008 2391          and.w     #8,D0
00001708  0C40 0008 2392          cmp.w     #8,D0
0000170C  660A      2393          bne.s     DumpRegisters_32
0000170E  4878 004E 2394          pea       78
00001712  4E92      2395          jsr       (A2)
00001714  584F      2396          addq.w    #4,A7
00001716  6008      2397          bra.s     DumpRegisters_33
                    2398   DumpRegisters_32:
00001718  4878 002D 2399          pea       45
0000171C  4E92      2400          jsr       (A2)
0000171E  584F      2401          addq.w    #4,A7
                    2402   DumpRegisters_33:
                    2403   ; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
00001720  3014      2404          move.w    (A4),D0
00001722  C07C 0004 2405          and.w     #4,D0
00001726  0C40 0004 2406          cmp.w     #4,D0
0000172A  660A      2407          bne.s     DumpRegisters_34
0000172C  4878 005A 2408          pea       90
00001730  4E92      2409          jsr       (A2)
00001732  584F      2410          addq.w    #4,A7
00001734  6008      2411          bra.s     DumpRegisters_35
                    2412   DumpRegisters_34:
00001736  4878 002D 2413          pea       45
0000173A  4E92      2414          jsr       (A2)
0000173C  584F      2415          addq.w    #4,A7
                    2416   DumpRegisters_35:
                    2417   ; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
0000173E  3014      2418          move.w    (A4),D0
00001740  C07C 0002 2419          and.w     #2,D0
00001744  0C40 0002 2420          cmp.w     #2,D0
00001748  660A      2421          bne.s     DumpRegisters_36
0000174A  4878 0056 2422          pea       86
0000174E  4E92      2423          jsr       (A2)
00001750  584F      2424          addq.w    #4,A7
00001752  6008      2425          bra.s     DumpRegisters_37
                    2426   DumpRegisters_36:
00001754  4878 002D 2427          pea       45
00001758  4E92      2428          jsr       (A2)
0000175A  584F      2429          addq.w    #4,A7
                    2430   DumpRegisters_37:
                    2431   ; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
0000175C  3014      2432          move.w    (A4),D0
0000175E  C07C 0001 2433          and.w     #1,D0
00001762  0C40 0001 2434          cmp.w     #1,D0
00001766  660A      2435          bne.s     DumpRegisters_38
00001768  4878 0043 2436          pea       67
0000176C  4E92      2437          jsr       (A2)
0000176E  584F      2438          addq.w    #4,A7
00001770  6008      2439          bra.s     DumpRegisters_39
                    2440   DumpRegisters_38:
00001772  4878 002D 2441          pea       45
00001776  4E92      2442          jsr       (A2)
00001778  584F      2443          addq.w    #4,A7
                    2444   DumpRegisters_39:
                    2445   ; putchar(']') ;
0000177A  4878 005D 2446          pea       93
0000177E  4E92      2447          jsr       (A2)
00001780  584F      2448          addq.w    #4,A7
                    2449   ; printf("\r\n PC = $%08X  ", PC) ;
00001782  2F39 0B00 2450          move.l    _PC.L,-(A7)
00001786  0120      
00001788  4879 0000 2451          pea       @m68kde~2_45.L
0000178C  62B8      
0000178E  4E93      2452          jsr       (A3)
00001790  504F      2453          addq.w    #8,A7
                    2454   ; if(*(unsigned short int *)(PC) != 0x4e4e)   {
00001792  2039 0B00 2455          move.l    _PC.L,D0
00001796  0120      
00001798  2040      2456          move.l    D0,A0
0000179A  3010      2457          move.w    (A0),D0
0000179C  0C40 4E4E 2458          cmp.w     #20046,D0
000017A0  6724      2459          beq.s     DumpRegisters_40
                    2460   ; DisassembleInstruction(PC) ;
000017A2  2F39 0B00 2461          move.l    _PC.L,-(A7)
000017A6  0120      
000017A8  4EB9 0000 2462          jsr       _DisassembleInstruction
000017AC  3480      
000017AE  584F      2463          addq.w    #4,A7
                    2464   ; FormatInstructionForTrace() ;
000017B0  4EB8 12DC 2465          jsr       _FormatInstructionForTrace
                    2466   ; printf("%s", Instruction) ;
000017B4  4879 0B00 2467          pea       _Instruction.L
000017B8  04E2      
000017BA  4879 0000 2468          pea       @m68kde~2_46.L
000017BE  62C8      
000017C0  4E93      2469          jsr       (A3)
000017C2  504F      2470          addq.w    #8,A7
000017C4  600A      2471          bra.s     DumpRegisters_41
                    2472   DumpRegisters_40:
                    2473   ; }
                    2474   ; else
                    2475   ; printf("[BREAKPOINT]") ;
000017C6  4879 0000 2476          pea       @m68kde~2_47.L
000017CA  62CC      
000017CC  4E93      2477          jsr       (A3)
000017CE  584F      2478          addq.w    #4,A7
                    2479   DumpRegisters_41:
                    2480   ; printf("\r\n") ;
000017D0  4879 0000 2481          pea       @m68kde~2_1.L
000017D4  5E6E      
000017D6  4E93      2482          jsr       (A3)
000017D8  584F      2483          addq.w    #4,A7
                    2484   ; for(i=0; i < 8; i++)    {
000017DA  4244      2485          clr.w     D4
                    2486   DumpRegisters_42:
000017DC  0C44 0008 2487          cmp.w     #8,D4
000017E0  6C00 0040 2488          bge       DumpRegisters_44
                    2489   ; if(WatchPointSetOrCleared[i] == 1)
000017E4  48C4      2490          ext.l     D4
000017E6  2004      2491          move.l    D4,D0
000017E8  E588      2492          lsl.l     #2,D0
000017EA  41F9 0B00 2493          lea       _WatchPointSetOrCleared.L,A0
000017EE  01A2      
000017F0  2030 0800 2494          move.l    0(A0,D0.L),D0
000017F4  0C80 0000 2495          cmp.l     #1,D0
000017F8  0001      
000017FA  6622      2496          bne.s     DumpRegisters_45
                    2497   ; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
000017FC  220D      2498          move.l    A5,D1
000017FE  48C4      2499          ext.l     D4
00001800  2F00      2500          move.l    D0,-(A7)
00001802  2004      2501          move.l    D4,D0
00001804  C1FC 0064 2502          muls      #100,D0
00001808  D280      2503          add.l     D0,D1
0000180A  201F      2504          move.l    (A7)+,D0
0000180C  2F01      2505          move.l    D1,-(A7)
0000180E  48C4      2506          ext.l     D4
00001810  2F04      2507          move.l    D4,-(A7)
00001812  4879 0000 2508          pea       @m68kde~2_48.L
00001816  62DA      
00001818  4E93      2509          jsr       (A3)
0000181A  DEFC 000C 2510          add.w     #12,A7
                    2511   DumpRegisters_45:
0000181E  5244      2512          addq.w    #1,D4
00001820  60BA      2513          bra       DumpRegisters_42
                    2514   DumpRegisters_44:
00001822  4CDF 3CFC 2515          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001826  4E75      2516          rts
                    2517   ; }
                    2518   ; }
                    2519   ; // Trace Exception Handler
                    2520   ; void DumpRegistersandPause(void)
                    2521   ; {
                    2522   _DumpRegistersandPause:
00001828  2F0A      2523          move.l    A2,-(A7)
0000182A  45F9 0000 2524          lea       _printf.L,A2
0000182E  551E      
                    2525   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
00001830  4879 0000 2526          pea       @m68kde~2_49.L
00001834  62E6      
00001836  4E92      2527          jsr       (A2)
00001838  584F      2528          addq.w    #4,A7
                    2529   ; printf("\r\nBreak Points :[Disabled]") ;
0000183A  4879 0000 2530          pea       @m68kde~2_50.L
0000183E  6306      
00001840  4E92      2531          jsr       (A2)
00001842  584F      2532          addq.w    #4,A7
                    2533   ; DumpRegisters() ;
00001844  4EB8 1350 2534          jsr       _DumpRegisters
                    2535   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00001848  4879 0000 2536          pea       @m68kde~2_51.L
0000184C  6322      
0000184E  4E92      2537          jsr       (A2)
00001850  584F      2538          addq.w    #4,A7
                    2539   ; printf("\r\nPress <ESC> to Resume Program") ;
00001852  4879 0000 2540          pea       @m68kde~2_52.L
00001856  634E      
00001858  4E92      2541          jsr       (A2)
0000185A  584F      2542          addq.w    #4,A7
                    2543   ; menu() ;
0000185C  4EB9 0000 2544          jsr       _menu
00001860  2492      
00001862  245F      2545          move.l    (A7)+,A2
00001864  4E75      2546          rts
                    2547   ; }
                    2548   ; void ChangeRegisters(void)
                    2549   ; {
                    2550   _ChangeRegisters:
00001866  4E56 FFFC 2551          link      A6,#-4
0000186A  48E7 303C 2552          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
0000186E  45F9 0000 2553          lea       _printf.L,A2
00001872  551E      
00001874  47EE FFFC 2554          lea       -4(A6),A3
00001878  49F8 0CA4 2555          lea       _Get8HexDigits.L,A4
0000187C  4BF8 0B68 2556          lea       __getch.L,A5
                    2557   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2558   ; int reg_val ;
                    2559   ; char c, reg[3] ;
                    2560   ; reg[0] = tolower(_getch()) ;
00001880  2F00      2561          move.l    D0,-(A7)
00001882  4E95      2562          jsr       (A5)
00001884  2200      2563          move.l    D0,D1
00001886  201F      2564          move.l    (A7)+,D0
00001888  2F01      2565          move.l    D1,-(A7)
0000188A  4EB9 0000 2566          jsr       _tolower
0000188E  547C      
00001890  584F      2567          addq.w    #4,A7
00001892  1680      2568          move.b    D0,(A3)
                    2569   ; reg[1] = c = tolower(_getch()) ;
00001894  2F00      2570          move.l    D0,-(A7)
00001896  4E95      2571          jsr       (A5)
00001898  2200      2572          move.l    D0,D1
0000189A  201F      2573          move.l    (A7)+,D0
0000189C  2F01      2574          move.l    D1,-(A7)
0000189E  4EB9 0000 2575          jsr       _tolower
000018A2  547C      
000018A4  584F      2576          addq.w    #4,A7
000018A6  1400      2577          move.b    D0,D2
000018A8  1740 0001 2578          move.b    D0,1(A3)
                    2579   ; if(reg[0] == (char)('d'))  {    // change data register
000018AC  1013      2580          move.b    (A3),D0
000018AE  0C00 0064 2581          cmp.b     #100,D0
000018B2  6600 00AE 2582          bne       ChangeRegisters_1
                    2583   ; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
000018B6  102B 0001 2584          move.b    1(A3),D0
000018BA  0C00 0037 2585          cmp.b     #55,D0
000018BE  6E0A      2586          bgt.s     ChangeRegisters_5
000018C0  102B 0001 2587          move.b    1(A3),D0
000018C4  0C00 0030 2588          cmp.b     #48,D0
000018C8  6C0E      2589          bge.s     ChangeRegisters_3
                    2590   ChangeRegisters_5:
                    2591   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
000018CA  4879 0000 2592          pea       @m68kde~2_53.L
000018CE  636E      
000018D0  4E92      2593          jsr       (A2)
000018D2  584F      2594          addq.w    #4,A7
                    2595   ; return ;
000018D4  6000 0244 2596          bra       ChangeRegisters_6
                    2597   ChangeRegisters_3:
                    2598   ; }
                    2599   ; else {
                    2600   ; printf("\r\nD%c = ", c) ;
000018D8  4882      2601          ext.w     D2
000018DA  48C2      2602          ext.l     D2
000018DC  2F02      2603          move.l    D2,-(A7)
000018DE  4879 0000 2604          pea       @m68kde~2_54.L
000018E2  639A      
000018E4  4E92      2605          jsr       (A2)
000018E6  504F      2606          addq.w    #8,A7
                    2607   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
000018E8  42A7      2608          clr.l     -(A7)
000018EA  4E94      2609          jsr       (A4)
000018EC  584F      2610          addq.w    #4,A7
000018EE  2600      2611          move.l    D0,D3
                    2612   ; }
                    2613   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2614   ; if(c == (char)('0'))
000018F0  0C02 0030 2615          cmp.b     #48,D2
000018F4  660A      2616          bne.s     ChangeRegisters_7
                    2617   ; d0 = reg_val ;
000018F6  23C3 0B00 2618          move.l    D3,_d0.L
000018FA  00E4      
000018FC  6000 0060 2619          bra       ChangeRegisters_20
                    2620   ChangeRegisters_7:
                    2621   ; else if(c == (char)('1'))
00001900  0C02 0031 2622          cmp.b     #49,D2
00001904  660A      2623          bne.s     ChangeRegisters_9
                    2624   ; d1 = reg_val ;
00001906  23C3 0B00 2625          move.l    D3,_d1.L
0000190A  00E8      
0000190C  6000 0050 2626          bra       ChangeRegisters_20
                    2627   ChangeRegisters_9:
                    2628   ; else if(c == (char)('2'))
00001910  0C02 0032 2629          cmp.b     #50,D2
00001914  660A      2630          bne.s     ChangeRegisters_11
                    2631   ; d2 = reg_val ;
00001916  23C3 0B00 2632          move.l    D3,_d2.L
0000191A  00EC      
0000191C  6000 0040 2633          bra       ChangeRegisters_20
                    2634   ChangeRegisters_11:
                    2635   ; else if(c == (char)('3'))
00001920  0C02 0033 2636          cmp.b     #51,D2
00001924  6608      2637          bne.s     ChangeRegisters_13
                    2638   ; d3 = reg_val ;
00001926  23C3 0B00 2639          move.l    D3,_d3.L
0000192A  00F0      
0000192C  6030      2640          bra.s     ChangeRegisters_20
                    2641   ChangeRegisters_13:
                    2642   ; else if(c == (char)('4'))
0000192E  0C02 0034 2643          cmp.b     #52,D2
00001932  6608      2644          bne.s     ChangeRegisters_15
                    2645   ; d4 = reg_val ;
00001934  23C3 0B00 2646          move.l    D3,_d4.L
00001938  00F4      
0000193A  6022      2647          bra.s     ChangeRegisters_20
                    2648   ChangeRegisters_15:
                    2649   ; else if(c == (char)('5'))
0000193C  0C02 0035 2650          cmp.b     #53,D2
00001940  6608      2651          bne.s     ChangeRegisters_17
                    2652   ; d5 = reg_val ;
00001942  23C3 0B00 2653          move.l    D3,_d5.L
00001946  00F8      
00001948  6014      2654          bra.s     ChangeRegisters_20
                    2655   ChangeRegisters_17:
                    2656   ; else if(c == (char)('6'))
0000194A  0C02 0036 2657          cmp.b     #54,D2
0000194E  6608      2658          bne.s     ChangeRegisters_19
                    2659   ; d6 = reg_val ;
00001950  23C3 0B00 2660          move.l    D3,_d6.L
00001954  00FC      
00001956  6006      2661          bra.s     ChangeRegisters_20
                    2662   ChangeRegisters_19:
                    2663   ; else
                    2664   ; d7 = reg_val ;
00001958  23C3 0B00 2665          move.l    D3,_d7.L
0000195C  0100      
                    2666   ChangeRegisters_20:
0000195E  6000 01B6 2667          bra       ChangeRegisters_51
                    2668   ChangeRegisters_1:
                    2669   ; }
                    2670   ; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001962  1013      2671          move.b    (A3),D0
00001964  0C00 0061 2672          cmp.b     #97,D0
00001968  6600 00A6 2673          bne       ChangeRegisters_21
                    2674   ; if((c > (char)('7')) || (c < (char)('0'))) {
0000196C  0C02 0037 2675          cmp.b     #55,D2
00001970  6E06      2676          bgt.s     ChangeRegisters_25
00001972  0C02 0030 2677          cmp.b     #48,D2
00001976  6C0E      2678          bge.s     ChangeRegisters_23
                    2679   ChangeRegisters_25:
                    2680   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
00001978  4879 0000 2681          pea       @m68kde~2_55.L
0000197C  63A4      
0000197E  4E92      2682          jsr       (A2)
00001980  584F      2683          addq.w    #4,A7
                    2684   ; return ;
00001982  6000 0196 2685          bra       ChangeRegisters_6
                    2686   ChangeRegisters_23:
                    2687   ; }
                    2688   ; else {
                    2689   ; printf("\r\nA%c = ", c) ;
00001986  4882      2690          ext.w     D2
00001988  48C2      2691          ext.l     D2
0000198A  2F02      2692          move.l    D2,-(A7)
0000198C  4879 0000 2693          pea       @m68kde~2_56.L
00001990  63D2      
00001992  4E92      2694          jsr       (A2)
00001994  504F      2695          addq.w    #8,A7
                    2696   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001996  42A7      2697          clr.l     -(A7)
00001998  4E94      2698          jsr       (A4)
0000199A  584F      2699          addq.w    #4,A7
0000199C  2600      2700          move.l    D0,D3
                    2701   ; }
                    2702   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2703   ; if(c == (char)('0'))
0000199E  0C02 0030 2704          cmp.b     #48,D2
000019A2  660A      2705          bne.s     ChangeRegisters_26
                    2706   ; a0 = reg_val ;
000019A4  23C3 0B00 2707          move.l    D3,_a0.L
000019A8  0104      
000019AA  6000 0060 2708          bra       ChangeRegisters_39
                    2709   ChangeRegisters_26:
                    2710   ; else if(c == (char)('1'))
000019AE  0C02 0031 2711          cmp.b     #49,D2
000019B2  660A      2712          bne.s     ChangeRegisters_28
                    2713   ; a1 = reg_val ;
000019B4  23C3 0B00 2714          move.l    D3,_a1.L
000019B8  0108      
000019BA  6000 0050 2715          bra       ChangeRegisters_39
                    2716   ChangeRegisters_28:
                    2717   ; else if(c == (char)('2'))
000019BE  0C02 0032 2718          cmp.b     #50,D2
000019C2  660A      2719          bne.s     ChangeRegisters_30
                    2720   ; a2 = reg_val ;
000019C4  23C3 0B00 2721          move.l    D3,_a2.L
000019C8  010C      
000019CA  6000 0040 2722          bra       ChangeRegisters_39
                    2723   ChangeRegisters_30:
                    2724   ; else if(c == (char)('3'))
000019CE  0C02 0033 2725          cmp.b     #51,D2
000019D2  6608      2726          bne.s     ChangeRegisters_32
                    2727   ; a3 = reg_val ;
000019D4  23C3 0B00 2728          move.l    D3,_a3.L
000019D8  0110      
000019DA  6030      2729          bra.s     ChangeRegisters_39
                    2730   ChangeRegisters_32:
                    2731   ; else if(c == (char)('4'))
000019DC  0C02 0034 2732          cmp.b     #52,D2
000019E0  6608      2733          bne.s     ChangeRegisters_34
                    2734   ; a4 = reg_val ;
000019E2  23C3 0B00 2735          move.l    D3,_a4.L
000019E6  0114      
000019E8  6022      2736          bra.s     ChangeRegisters_39
                    2737   ChangeRegisters_34:
                    2738   ; else if(c == (char)('5'))
000019EA  0C02 0035 2739          cmp.b     #53,D2
000019EE  6608      2740          bne.s     ChangeRegisters_36
                    2741   ; a5 = reg_val ;
000019F0  23C3 0B00 2742          move.l    D3,_a5.L
000019F4  0118      
000019F6  6014      2743          bra.s     ChangeRegisters_39
                    2744   ChangeRegisters_36:
                    2745   ; else if(c == (char)('6'))
000019F8  0C02 0036 2746          cmp.b     #54,D2
000019FC  6608      2747          bne.s     ChangeRegisters_38
                    2748   ; a6 = reg_val ;
000019FE  23C3 0B00 2749          move.l    D3,_a6.L
00001A02  011C      
00001A04  6006      2750          bra.s     ChangeRegisters_39
                    2751   ChangeRegisters_38:
                    2752   ; else
                    2753   ; USP = reg_val ;
00001A06  23C3 0B00 2754          move.l    D3,_USP.L
00001A0A  0128      
                    2755   ChangeRegisters_39:
00001A0C  6000 0108 2756          bra       ChangeRegisters_51
                    2757   ChangeRegisters_21:
                    2758   ; }
                    2759   ; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
00001A10  1013      2760          move.b    (A3),D0
00001A12  0C00 0075 2761          cmp.b     #117,D0
00001A16  6600 004E 2762          bne       ChangeRegisters_40
00001A1A  0C02 0073 2763          cmp.b     #115,D2
00001A1E  6600 0046 2764          bne       ChangeRegisters_40
                    2765   ; if(tolower(_getch()) == 'p')  {    // change user stack pointer
00001A22  2F00      2766          move.l    D0,-(A7)
00001A24  4E95      2767          jsr       (A5)
00001A26  2200      2768          move.l    D0,D1
00001A28  201F      2769          move.l    (A7)+,D0
00001A2A  2F01      2770          move.l    D1,-(A7)
00001A2C  4EB9 0000 2771          jsr       _tolower
00001A30  547C      
00001A32  584F      2772          addq.w    #4,A7
00001A34  0C80 0000 2773          cmp.l     #112,D0
00001A38  0070      
00001A3A  6618      2774          bne.s     ChangeRegisters_42
                    2775   ; printf("\r\nUser SP = ") ;
00001A3C  4879 0000 2776          pea       @m68kde~2_57.L
00001A40  63DC      
00001A42  4E92      2777          jsr       (A2)
00001A44  584F      2778          addq.w    #4,A7
                    2779   ; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001A46  42A7      2780          clr.l     -(A7)
00001A48  4E94      2781          jsr       (A4)
00001A4A  584F      2782          addq.w    #4,A7
00001A4C  23C0 0B00 2783          move.l    D0,_USP.L
00001A50  0128      
00001A52  600E      2784          bra.s     ChangeRegisters_43
                    2785   ChangeRegisters_42:
                    2786   ; }
                    2787   ; else {
                    2788   ; printf("\r\nIllegal Register....") ;
00001A54  4879 0000 2789          pea       @m68kde~2_58.L
00001A58  63EA      
00001A5A  4E92      2790          jsr       (A2)
00001A5C  584F      2791          addq.w    #4,A7
                    2792   ; return ;
00001A5E  6000 00BA 2793          bra       ChangeRegisters_6
                    2794   ChangeRegisters_43:
00001A62  6000 00B2 2795          bra       ChangeRegisters_51
                    2796   ChangeRegisters_40:
                    2797   ; }
                    2798   ; }
                    2799   ; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
00001A66  1013      2800          move.b    (A3),D0
00001A68  0C00 0073 2801          cmp.b     #115,D0
00001A6C  6600 004E 2802          bne       ChangeRegisters_44
00001A70  0C02 0073 2803          cmp.b     #115,D2
00001A74  6600 0046 2804          bne       ChangeRegisters_44
                    2805   ; if(tolower(_getch()) == 'p')  {    // change system stack pointer
00001A78  2F00      2806          move.l    D0,-(A7)
00001A7A  4E95      2807          jsr       (A5)
00001A7C  2200      2808          move.l    D0,D1
00001A7E  201F      2809          move.l    (A7)+,D0
00001A80  2F01      2810          move.l    D1,-(A7)
00001A82  4EB9 0000 2811          jsr       _tolower
00001A86  547C      
00001A88  584F      2812          addq.w    #4,A7
00001A8A  0C80 0000 2813          cmp.l     #112,D0
00001A8E  0070      
00001A90  6618      2814          bne.s     ChangeRegisters_46
                    2815   ; printf("\r\nSystem SP = ") ;
00001A92  4879 0000 2816          pea       @m68kde~2_59.L
00001A96  6402      
00001A98  4E92      2817          jsr       (A2)
00001A9A  584F      2818          addq.w    #4,A7
                    2819   ; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001A9C  42A7      2820          clr.l     -(A7)
00001A9E  4E94      2821          jsr       (A4)
00001AA0  584F      2822          addq.w    #4,A7
00001AA2  23C0 0B00 2823          move.l    D0,_SSP.L
00001AA6  0124      
00001AA8  600E      2824          bra.s     ChangeRegisters_47
                    2825   ChangeRegisters_46:
                    2826   ; }
                    2827   ; else {
                    2828   ; printf("\r\nIllegal Register....") ;
00001AAA  4879 0000 2829          pea       @m68kde~2_58.L
00001AAE  63EA      
00001AB0  4E92      2830          jsr       (A2)
00001AB2  584F      2831          addq.w    #4,A7
                    2832   ; return ;
00001AB4  6000 0064 2833          bra       ChangeRegisters_6
                    2834   ChangeRegisters_47:
00001AB8  6000 005C 2835          bra       ChangeRegisters_51
                    2836   ChangeRegisters_44:
                    2837   ; }
                    2838   ; }
                    2839   ; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
00001ABC  1013      2840          move.b    (A3),D0
00001ABE  0C00 0070 2841          cmp.b     #112,D0
00001AC2  6620      2842          bne.s     ChangeRegisters_48
00001AC4  0C02 0063 2843          cmp.b     #99,D2
00001AC8  661A      2844          bne.s     ChangeRegisters_48
                    2845   ; printf("\r\nPC = ") ;
00001ACA  4879 0000 2846          pea       @m68kde~2_60.L
00001ACE  6412      
00001AD0  4E92      2847          jsr       (A2)
00001AD2  584F      2848          addq.w    #4,A7
                    2849   ; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001AD4  42A7      2850          clr.l     -(A7)
00001AD6  4E94      2851          jsr       (A4)
00001AD8  584F      2852          addq.w    #4,A7
00001ADA  23C0 0B00 2853          move.l    D0,_PC.L
00001ADE  0120      
00001AE0  6000 0034 2854          bra       ChangeRegisters_51
                    2855   ChangeRegisters_48:
                    2856   ; }
                    2857   ; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
00001AE4  1013      2858          move.b    (A3),D0
00001AE6  0C00 0073 2859          cmp.b     #115,D0
00001AEA  6620      2860          bne.s     ChangeRegisters_50
00001AEC  0C02 0072 2861          cmp.b     #114,D2
00001AF0  661A      2862          bne.s     ChangeRegisters_50
                    2863   ; printf("\r\nSR = ") ;
00001AF2  4879 0000 2864          pea       @m68kde~2_61.L
00001AF6  641A      
00001AF8  4E92      2865          jsr       (A2)
00001AFA  584F      2866          addq.w    #4,A7
                    2867   ; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
00001AFC  42A7      2868          clr.l     -(A7)
00001AFE  4EB8 0C58 2869          jsr       _Get4HexDigits
00001B02  584F      2870          addq.w    #4,A7
00001B04  33C0 0B00 2871          move.w    D0,_SR.L
00001B08  012C      
00001B0A  600A      2872          bra.s     ChangeRegisters_51
                    2873   ChangeRegisters_50:
                    2874   ; }
                    2875   ; else
                    2876   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
00001B0C  4879 0000 2877          pea       @m68kde~2_62.L
00001B10  6422      
00001B12  4E92      2878          jsr       (A2)
00001B14  584F      2879          addq.w    #4,A7
                    2880   ChangeRegisters_51:
                    2881   ; DumpRegisters() ;
00001B16  4EB8 1350 2882          jsr       _DumpRegisters
                    2883   ChangeRegisters_6:
00001B1A  4CDF 3C0C 2884          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001B1E  4E5E      2885          unlk      A6
00001B20  4E75      2886          rts
                    2887   ; }
                    2888   ; void BreakPointDisplay(void)
                    2889   ; {
                    2890   _BreakPointDisplay:
00001B22  48E7 3030 2891          movem.l   D2/D3/A2/A3,-(A7)
00001B26  45F9 0000 2892          lea       _printf.L,A2
00001B2A  551E      
00001B2C  47F9 0B00 2893          lea       _BreakPointAddress.L,A3
00001B30  012E      
                    2894   ; int i, BreakPointsSet = 0 ;
00001B32  4283      2895          clr.l     D3
                    2896   ; // any break points  set
                    2897   ; for(i = 0; i < 8; i++)  {
00001B34  4282      2898          clr.l     D2
                    2899   BreakPointDisplay_1:
00001B36  0C82 0000 2900          cmp.l     #8,D2
00001B3A  0008      
00001B3C  6C1C      2901          bge.s     BreakPointDisplay_3
                    2902   ; if(BreakPointSetOrCleared[i] == 1)
00001B3E  2002      2903          move.l    D2,D0
00001B40  E588      2904          lsl.l     #2,D0
00001B42  41F9 0B00 2905          lea       _BreakPointSetOrCleared.L,A0
00001B46  015E      
00001B48  2030 0800 2906          move.l    0(A0,D0.L),D0
00001B4C  0C80 0000 2907          cmp.l     #1,D0
00001B50  0001      
00001B52  6602      2908          bne.s     BreakPointDisplay_4
                    2909   ; BreakPointsSet = 1;
00001B54  7601      2910          moveq     #1,D3
                    2911   BreakPointDisplay_4:
00001B56  5282      2912          addq.l    #1,D2
00001B58  60DC      2913          bra       BreakPointDisplay_1
                    2914   BreakPointDisplay_3:
                    2915   ; }
                    2916   ; if(BreakPointsSet == 1) {
00001B5A  0C83 0000 2917          cmp.l     #1,D3
00001B5E  0001      
00001B60  6616      2918          bne.s     BreakPointDisplay_6
                    2919   ; printf("\r\n\r\nNum     Address      Instruction") ;
00001B62  4879 0000 2920          pea       @m68kde~2_63.L
00001B66  645E      
00001B68  4E92      2921          jsr       (A2)
00001B6A  584F      2922          addq.w    #4,A7
                    2923   ; printf("\r\n---     ---------    -----------") ;
00001B6C  4879 0000 2924          pea       @m68kde~2_64.L
00001B70  6484      
00001B72  4E92      2925          jsr       (A2)
00001B74  584F      2926          addq.w    #4,A7
00001B76  600A      2927          bra.s     BreakPointDisplay_7
                    2928   BreakPointDisplay_6:
                    2929   ; }
                    2930   ; else
                    2931   ; printf("\r\nNo BreakPoints Set") ;
00001B78  4879 0000 2932          pea       @m68kde~2_65.L
00001B7C  64A8      
00001B7E  4E92      2933          jsr       (A2)
00001B80  584F      2934          addq.w    #4,A7
                    2935   BreakPointDisplay_7:
                    2936   ; for(i = 0; i < 8; i++)  {
00001B82  4282      2937          clr.l     D2
                    2938   BreakPointDisplay_8:
00001B84  0C82 0000 2939          cmp.l     #8,D2
00001B88  0008      
00001B8A  6C00 0080 2940          bge       BreakPointDisplay_10
                    2941   ; // put opcode back to disassemble it, then put break point back
                    2942   ; if(BreakPointSetOrCleared[i] == 1)  {
00001B8E  2002      2943          move.l    D2,D0
00001B90  E588      2944          lsl.l     #2,D0
00001B92  41F9 0B00 2945          lea       _BreakPointSetOrCleared.L,A0
00001B96  015E      
00001B98  2030 0800 2946          move.l    0(A0,D0.L),D0
00001B9C  0C80 0000 2947          cmp.l     #1,D0
00001BA0  0001      
00001BA2  6600 0062 2948          bne       BreakPointDisplay_11
                    2949   ; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
00001BA6  2002      2950          move.l    D2,D0
00001BA8  E388      2951          lsl.l     #1,D0
00001BAA  41F9 0B00 2952          lea       _BreakPointInstruction.L,A0
00001BAE  014E      
00001BB0  2202      2953          move.l    D2,D1
00001BB2  E589      2954          lsl.l     #2,D1
00001BB4  2233 1800 2955          move.l    0(A3,D1.L),D1
00001BB8  2241      2956          move.l    D1,A1
00001BBA  32B0 0800 2957          move.w    0(A0,D0.L),(A1)
                    2958   ; DisassembleInstruction(BreakPointAddress[i]) ;
00001BBE  2202      2959          move.l    D2,D1
00001BC0  E589      2960          lsl.l     #2,D1
00001BC2  2F33 1800 2961          move.l    0(A3,D1.L),-(A7)
00001BC6  4EB9 0000 2962          jsr       _DisassembleInstruction
00001BCA  3480      
00001BCC  584F      2963          addq.w    #4,A7
                    2964   ; FormatInstructionForTrace() ;
00001BCE  4EB8 12DC 2965          jsr       _FormatInstructionForTrace
                    2966   ; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
00001BD2  2002      2967          move.l    D2,D0
00001BD4  E588      2968          lsl.l     #2,D0
00001BD6  2033 0800 2969          move.l    0(A3,D0.L),D0
00001BDA  2040      2970          move.l    D0,A0
00001BDC  30BC 4E4E 2971          move.w    #20046,(A0)
                    2972   ; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
00001BE0  2202      2973          move.l    D2,D1
00001BE2  E589      2974          lsl.l     #2,D1
00001BE4  2F33 1800 2975          move.l    0(A3,D1.L),-(A7)
00001BE8  2F02      2976          move.l    D2,-(A7)
00001BEA  4879 0000 2977          pea       @m68kde~2_66.L
00001BEE  64BE      
00001BF0  4E92      2978          jsr       (A2)
00001BF2  DEFC 000C 2979          add.w     #12,A7
                    2980   ; printf("    %s", Instruction);
00001BF6  4879 0B00 2981          pea       _Instruction.L
00001BFA  04E2      
00001BFC  4879 0000 2982          pea       @m68kde~2_67.L
00001C00  64CE      
00001C02  4E92      2983          jsr       (A2)
00001C04  504F      2984          addq.w    #8,A7
                    2985   BreakPointDisplay_11:
00001C06  5282      2986          addq.l    #1,D2
00001C08  6000 FF7A 2987          bra       BreakPointDisplay_8
                    2988   BreakPointDisplay_10:
                    2989   ; }
                    2990   ; }
                    2991   ; printf("\r\n") ;
00001C0C  4879 0000 2992          pea       @m68kde~2_1.L
00001C10  5E6E      
00001C12  4E92      2993          jsr       (A2)
00001C14  584F      2994          addq.w    #4,A7
00001C16  4CDF 0C0C 2995          movem.l   (A7)+,D2/D3/A2/A3
00001C1A  4E75      2996          rts
                    2997   ; }
                    2998   ; void WatchPointDisplay(void)
                    2999   ; {
                    3000   _WatchPointDisplay:
00001C1C  48E7 3020 3001          movem.l   D2/D3/A2,-(A7)
00001C20  45F9 0000 3002          lea       _printf.L,A2
00001C24  551E      
                    3003   ; int i ;
                    3004   ; int WatchPointsSet = 0 ;
00001C26  4283      3005          clr.l     D3
                    3006   ; // any watchpoints set
                    3007   ; for(i = 0; i < 8; i++)  {
00001C28  4282      3008          clr.l     D2
                    3009   WatchPointDisplay_1:
00001C2A  0C82 0000 3010          cmp.l     #8,D2
00001C2E  0008      
00001C30  6C1C      3011          bge.s     WatchPointDisplay_3
                    3012   ; if(WatchPointSetOrCleared[i] == 1)
00001C32  2002      3013          move.l    D2,D0
00001C34  E588      3014          lsl.l     #2,D0
00001C36  41F9 0B00 3015          lea       _WatchPointSetOrCleared.L,A0
00001C3A  01A2      
00001C3C  2030 0800 3016          move.l    0(A0,D0.L),D0
00001C40  0C80 0000 3017          cmp.l     #1,D0
00001C44  0001      
00001C46  6602      3018          bne.s     WatchPointDisplay_4
                    3019   ; WatchPointsSet = 1;
00001C48  7601      3020          moveq     #1,D3
                    3021   WatchPointDisplay_4:
00001C4A  5282      3022          addq.l    #1,D2
00001C4C  60DC      3023          bra       WatchPointDisplay_1
                    3024   WatchPointDisplay_3:
                    3025   ; }
                    3026   ; if(WatchPointsSet == 1) {
00001C4E  0C83 0000 3027          cmp.l     #1,D3
00001C52  0001      
00001C54  6616      3028          bne.s     WatchPointDisplay_6
                    3029   ; printf("\r\nNum     Address") ;
00001C56  4879 0000 3030          pea       @m68kde~2_68.L
00001C5A  64D6      
00001C5C  4E92      3031          jsr       (A2)
00001C5E  584F      3032          addq.w    #4,A7
                    3033   ; printf("\r\n---     ---------") ;
00001C60  4879 0000 3034          pea       @m68kde~2_69.L
00001C64  64E8      
00001C66  4E92      3035          jsr       (A2)
00001C68  584F      3036          addq.w    #4,A7
00001C6A  600A      3037          bra.s     WatchPointDisplay_7
                    3038   WatchPointDisplay_6:
                    3039   ; }
                    3040   ; else
                    3041   ; printf("\r\nNo WatchPoints Set") ;
00001C6C  4879 0000 3042          pea       @m68kde~2_70.L
00001C70  64FC      
00001C72  4E92      3043          jsr       (A2)
00001C74  584F      3044          addq.w    #4,A7
                    3045   WatchPointDisplay_7:
                    3046   ; for(i = 0; i < 8; i++)  {
00001C76  4282      3047          clr.l     D2
                    3048   WatchPointDisplay_8:
00001C78  0C82 0000 3049          cmp.l     #8,D2
00001C7C  0008      
00001C7E  6C00 0038 3050          bge       WatchPointDisplay_10
                    3051   ; if(WatchPointSetOrCleared[i] == 1)
00001C82  2002      3052          move.l    D2,D0
00001C84  E588      3053          lsl.l     #2,D0
00001C86  41F9 0B00 3054          lea       _WatchPointSetOrCleared.L,A0
00001C8A  01A2      
00001C8C  2030 0800 3055          move.l    0(A0,D0.L),D0
00001C90  0C80 0000 3056          cmp.l     #1,D0
00001C94  0001      
00001C96  661C      3057          bne.s     WatchPointDisplay_11
                    3058   ; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
00001C98  2202      3059          move.l    D2,D1
00001C9A  E589      3060          lsl.l     #2,D1
00001C9C  41F9 0B00 3061          lea       _WatchPointAddress.L,A0
00001CA0  0182      
00001CA2  2F30 1800 3062          move.l    0(A0,D1.L),-(A7)
00001CA6  2F02      3063          move.l    D2,-(A7)
00001CA8  4879 0000 3064          pea       @m68kde~2_66.L
00001CAC  64BE      
00001CAE  4E92      3065          jsr       (A2)
00001CB0  DEFC 000C 3066          add.w     #12,A7
                    3067   WatchPointDisplay_11:
00001CB4  5282      3068          addq.l    #1,D2
00001CB6  60C0      3069          bra       WatchPointDisplay_8
                    3070   WatchPointDisplay_10:
                    3071   ; }
                    3072   ; printf("\r\n") ;
00001CB8  4879 0000 3073          pea       @m68kde~2_1.L
00001CBC  5E6E      
00001CBE  4E92      3074          jsr       (A2)
00001CC0  584F      3075          addq.w    #4,A7
00001CC2  4CDF 040C 3076          movem.l   (A7)+,D2/D3/A2
00001CC6  4E75      3077          rts
                    3078   ; }
                    3079   ; void BreakPointClear(void)
                    3080   ; {
                    3081   _BreakPointClear:
00001CC8  4E56 FFFC 3082          link      A6,#-4
00001CCC  48E7 2020 3083          movem.l   D2/A2,-(A7)
00001CD0  45F9 0000 3084          lea       _printf.L,A2
00001CD4  551E      
                    3085   ; unsigned int i ;
                    3086   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3087   ; BreakPointDisplay() ;
00001CD6  4EB8 1B22 3088          jsr       _BreakPointDisplay
                    3089   ; printf("\r\nEnter Break Point Number: ") ;
00001CDA  4879 0000 3090          pea       @m68kde~2_71.L
00001CDE  6512      
00001CE0  4E92      3091          jsr       (A2)
00001CE2  584F      3092          addq.w    #4,A7
                    3093   ; i = xtod(_getch()) ;           // get break pointer number
00001CE4  2F00      3094          move.l    D0,-(A7)
00001CE6  4EB8 0B68 3095          jsr       __getch
00001CEA  2200      3096          move.l    D0,D1
00001CEC  201F      3097          move.l    (A7)+,D0
00001CEE  2F01      3098          move.l    D1,-(A7)
00001CF0  4EB8 0BD2 3099          jsr       _xtod
00001CF4  584F      3100          addq.w    #4,A7
00001CF6  C0BC 0000 3101          and.l     #255,D0
00001CFA  00FF      
00001CFC  2400      3102          move.l    D0,D2
                    3103   ; if((i < 0) || (i > 7))   {
00001CFE  0C82 0000 3104          cmp.l     #0,D2
00001D02  0000      
00001D04  6508      3105          blo.s     BreakPointClear_3
00001D06  0C82 0000 3106          cmp.l     #7,D2
00001D0A  0007      
00001D0C  630E      3107          bls.s     BreakPointClear_1
                    3108   BreakPointClear_3:
                    3109   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001D0E  4879 0000 3110          pea       @m68kde~2_72.L
00001D12  6530      
00001D14  4E92      3111          jsr       (A2)
00001D16  584F      3112          addq.w    #4,A7
                    3113   ; return ;
00001D18  6000 0080 3114          bra       BreakPointClear_4
                    3115   BreakPointClear_1:
                    3116   ; }
                    3117   ; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
00001D1C  2002      3118          move.l    D2,D0
00001D1E  E588      3119          lsl.l     #2,D0
00001D20  41F9 0B00 3120          lea       _BreakPointSetOrCleared.L,A0
00001D24  015E      
00001D26  2030 0800 3121          move.l    0(A0,D0.L),D0
00001D2A  0C80 0000 3122          cmp.l     #1,D0
00001D2E  0001      
00001D30  6600 005A 3123          bne       BreakPointClear_5
                    3124   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
00001D34  2002      3125          move.l    D2,D0
00001D36  E588      3126          lsl.l     #2,D0
00001D38  41F9 0B00 3127          lea       _BreakPointAddress.L,A0
00001D3C  012E      
00001D3E  2D70 0800 3128          move.l    0(A0,D0.L),-4(A6)
00001D42  FFFC      
                    3129   ; BreakPointAddress[i] = 0 ;
00001D44  2002      3130          move.l    D2,D0
00001D46  E588      3131          lsl.l     #2,D0
00001D48  41F9 0B00 3132          lea       _BreakPointAddress.L,A0
00001D4C  012E      
00001D4E  42B0 0800 3133          clr.l     0(A0,D0.L)
                    3134   ; BreakPointSetOrCleared[i] = 0 ;
00001D52  2002      3135          move.l    D2,D0
00001D54  E588      3136          lsl.l     #2,D0
00001D56  41F9 0B00 3137          lea       _BreakPointSetOrCleared.L,A0
00001D5A  015E      
00001D5C  42B0 0800 3138          clr.l     0(A0,D0.L)
                    3139   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00001D60  2002      3140          move.l    D2,D0
00001D62  E388      3141          lsl.l     #1,D0
00001D64  41F9 0B00 3142          lea       _BreakPointInstruction.L,A0
00001D68  014E      
00001D6A  226E FFFC 3143          move.l    -4(A6),A1
00001D6E  32B0 0800 3144          move.w    0(A0,D0.L),(A1)
                    3145   ; BreakPointInstruction[i] = 0 ;
00001D72  2002      3146          move.l    D2,D0
00001D74  E388      3147          lsl.l     #1,D0
00001D76  41F9 0B00 3148          lea       _BreakPointInstruction.L,A0
00001D7A  014E      
00001D7C  4270 0800 3149          clr.w     0(A0,D0.L)
                    3150   ; printf("\r\nBreak Point Cleared.....\r\n") ;
00001D80  4879 0000 3151          pea       @m68kde~2_73.L
00001D84  654C      
00001D86  4E92      3152          jsr       (A2)
00001D88  584F      3153          addq.w    #4,A7
00001D8A  600A      3154          bra.s     BreakPointClear_6
                    3155   BreakPointClear_5:
                    3156   ; }
                    3157   ; else
                    3158   ; printf("\r\nBreak Point wasn't Set.....") ;
00001D8C  4879 0000 3159          pea       @m68kde~2_74.L
00001D90  656A      
00001D92  4E92      3160          jsr       (A2)
00001D94  584F      3161          addq.w    #4,A7
                    3162   BreakPointClear_6:
                    3163   ; BreakPointDisplay() ;
00001D96  4EB8 1B22 3164          jsr       _BreakPointDisplay
                    3165   ; return ;
                    3166   BreakPointClear_4:
00001D9A  4CDF 0404 3167          movem.l   (A7)+,D2/A2
00001D9E  4E5E      3168          unlk      A6
00001DA0  4E75      3169          rts
                    3170   ; }
                    3171   ; void WatchPointClear(void)
                    3172   ; {
                    3173   _WatchPointClear:
00001DA2  48E7 2020 3174          movem.l   D2/A2,-(A7)
00001DA6  45F9 0000 3175          lea       _printf.L,A2
00001DAA  551E      
                    3176   ; unsigned int i ;
                    3177   ; WatchPointDisplay() ;
00001DAC  4EB8 1C1C 3178          jsr       _WatchPointDisplay
                    3179   ; printf("\r\nEnter Watch Point Number: ") ;
00001DB0  4879 0000 3180          pea       @m68kde~2_75.L
00001DB4  6588      
00001DB6  4E92      3181          jsr       (A2)
00001DB8  584F      3182          addq.w    #4,A7
                    3183   ; i = xtod(_getch()) ;           // get watch pointer number
00001DBA  2F00      3184          move.l    D0,-(A7)
00001DBC  4EB8 0B68 3185          jsr       __getch
00001DC0  2200      3186          move.l    D0,D1
00001DC2  201F      3187          move.l    (A7)+,D0
00001DC4  2F01      3188          move.l    D1,-(A7)
00001DC6  4EB8 0BD2 3189          jsr       _xtod
00001DCA  584F      3190          addq.w    #4,A7
00001DCC  C0BC 0000 3191          and.l     #255,D0
00001DD0  00FF      
00001DD2  2400      3192          move.l    D0,D2
                    3193   ; if((i < 0) || (i > 7))   {
00001DD4  0C82 0000 3194          cmp.l     #0,D2
00001DD8  0000      
00001DDA  6508      3195          blo.s     WatchPointClear_3
00001DDC  0C82 0000 3196          cmp.l     #7,D2
00001DE0  0007      
00001DE2  630E      3197          bls.s     WatchPointClear_1
                    3198   WatchPointClear_3:
                    3199   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001DE4  4879 0000 3200          pea       @m68kde~2_72.L
00001DE8  6530      
00001DEA  4E92      3201          jsr       (A2)
00001DEC  584F      3202          addq.w    #4,A7
                    3203   ; return ;
00001DEE  6000 004E 3204          bra       WatchPointClear_4
                    3205   WatchPointClear_1:
                    3206   ; }
                    3207   ; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
00001DF2  2002      3208          move.l    D2,D0
00001DF4  E588      3209          lsl.l     #2,D0
00001DF6  41F9 0B00 3210          lea       _WatchPointSetOrCleared.L,A0
00001DFA  01A2      
00001DFC  2030 0800 3211          move.l    0(A0,D0.L),D0
00001E00  0C80 0000 3212          cmp.l     #1,D0
00001E04  0001      
00001E06  6628      3213          bne.s     WatchPointClear_5
                    3214   ; WatchPointAddress[i] = 0 ;
00001E08  2002      3215          move.l    D2,D0
00001E0A  E588      3216          lsl.l     #2,D0
00001E0C  41F9 0B00 3217          lea       _WatchPointAddress.L,A0
00001E10  0182      
00001E12  42B0 0800 3218          clr.l     0(A0,D0.L)
                    3219   ; WatchPointSetOrCleared[i] = 0 ;
00001E16  2002      3220          move.l    D2,D0
00001E18  E588      3221          lsl.l     #2,D0
00001E1A  41F9 0B00 3222          lea       _WatchPointSetOrCleared.L,A0
00001E1E  01A2      
00001E20  42B0 0800 3223          clr.l     0(A0,D0.L)
                    3224   ; printf("\r\nWatch Point Cleared.....\r\n") ;
00001E24  4879 0000 3225          pea       @m68kde~2_76.L
00001E28  65A6      
00001E2A  4E92      3226          jsr       (A2)
00001E2C  584F      3227          addq.w    #4,A7
00001E2E  600A      3228          bra.s     WatchPointClear_6
                    3229   WatchPointClear_5:
                    3230   ; }
                    3231   ; else
                    3232   ; printf("\r\nWatch Point Was not Set.....") ;
00001E30  4879 0000 3233          pea       @m68kde~2_77.L
00001E34  65C4      
00001E36  4E92      3234          jsr       (A2)
00001E38  584F      3235          addq.w    #4,A7
                    3236   WatchPointClear_6:
                    3237   ; WatchPointDisplay() ;
00001E3A  4EB8 1C1C 3238          jsr       _WatchPointDisplay
                    3239   ; return ;
                    3240   WatchPointClear_4:
00001E3E  4CDF 0404 3241          movem.l   (A7)+,D2/A2
00001E42  4E75      3242          rts
                    3243   ; }
                    3244   ; void DisableBreakPoints(void)
                    3245   ; {
                    3246   _DisableBreakPoints:
00001E44  4E56 FFFC 3247          link      A6,#-4
00001E48  2F02      3248          move.l    D2,-(A7)
                    3249   ; int i ;
                    3250   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3251   ; for(i = 0; i < 8; i++)  {
00001E4A  4282      3252          clr.l     D2
                    3253   DisableBreakPoints_1:
00001E4C  0C82 0000 3254          cmp.l     #8,D2
00001E50  0008      
00001E52  6C00 003E 3255          bge       DisableBreakPoints_3
                    3256   ; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
00001E56  2002      3257          move.l    D2,D0
00001E58  E588      3258          lsl.l     #2,D0
00001E5A  41F9 0B00 3259          lea       _BreakPointSetOrCleared.L,A0
00001E5E  015E      
00001E60  2030 0800 3260          move.l    0(A0,D0.L),D0
00001E64  0C80 0000 3261          cmp.l     #1,D0
00001E68  0001      
00001E6A  6622      3262          bne.s     DisableBreakPoints_4
                    3263   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001E6C  2002      3264          move.l    D2,D0
00001E6E  E588      3265          lsl.l     #2,D0
00001E70  41F9 0B00 3266          lea       _BreakPointAddress.L,A0
00001E74  012E      
00001E76  2D70 0800 3267          move.l    0(A0,D0.L),-4(A6)
00001E7A  FFFC      
                    3268   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00001E7C  2002      3269          move.l    D2,D0
00001E7E  E388      3270          lsl.l     #1,D0
00001E80  41F9 0B00 3271          lea       _BreakPointInstruction.L,A0
00001E84  014E      
00001E86  226E FFFC 3272          move.l    -4(A6),A1
00001E8A  32B0 0800 3273          move.w    0(A0,D0.L),(A1)
                    3274   DisableBreakPoints_4:
00001E8E  5282      3275          addq.l    #1,D2
00001E90  60BA      3276          bra       DisableBreakPoints_1
                    3277   DisableBreakPoints_3:
00001E92  241F      3278          move.l    (A7)+,D2
00001E94  4E5E      3279          unlk      A6
00001E96  4E75      3280          rts
                    3281   ; }
                    3282   ; }
                    3283   ; }
                    3284   ; void EnableBreakPoints(void)
                    3285   ; {
                    3286   _EnableBreakPoints:
00001E98  4E56 FFFC 3287          link      A6,#-4
00001E9C  2F02      3288          move.l    D2,-(A7)
                    3289   ; int i ;
                    3290   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3291   ; for(i = 0; i < 8; i++)  {
00001E9E  4282      3292          clr.l     D2
                    3293   EnableBreakPoints_1:
00001EA0  0C82 0000 3294          cmp.l     #8,D2
00001EA4  0008      
00001EA6  6C32      3295          bge.s     EnableBreakPoints_3
                    3296   ; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
00001EA8  2002      3297          move.l    D2,D0
00001EAA  E588      3298          lsl.l     #2,D0
00001EAC  41F9 0B00 3299          lea       _BreakPointSetOrCleared.L,A0
00001EB0  015E      
00001EB2  2030 0800 3300          move.l    0(A0,D0.L),D0
00001EB6  0C80 0000 3301          cmp.l     #1,D0
00001EBA  0001      
00001EBC  6618      3302          bne.s     EnableBreakPoints_4
                    3303   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001EBE  2002      3304          move.l    D2,D0
00001EC0  E588      3305          lsl.l     #2,D0
00001EC2  41F9 0B00 3306          lea       _BreakPointAddress.L,A0
00001EC6  012E      
00001EC8  2D70 0800 3307          move.l    0(A0,D0.L),-4(A6)
00001ECC  FFFC      
                    3308   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00001ECE  206E FFFC 3309          move.l    -4(A6),A0
00001ED2  30BC 4E4E 3310          move.w    #20046,(A0)
                    3311   EnableBreakPoints_4:
00001ED6  5282      3312          addq.l    #1,D2
00001ED8  60C6      3313          bra       EnableBreakPoints_1
                    3314   EnableBreakPoints_3:
00001EDA  241F      3315          move.l    (A7)+,D2
00001EDC  4E5E      3316          unlk      A6
00001EDE  4E75      3317          rts
                    3318   ; }
                    3319   ; }
                    3320   ; }
                    3321   ; void KillAllBreakPoints(void)
                    3322   ; {
                    3323   _KillAllBreakPoints:
00001EE0  4E56 FFFC 3324          link      A6,#-4
00001EE4  2F02      3325          move.l    D2,-(A7)
                    3326   ; int i ;
                    3327   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3328   ; for(i = 0; i < 8; i++)  {
00001EE6  4282      3329          clr.l     D2
                    3330   KillAllBreakPoints_1:
00001EE8  0C82 0000 3331          cmp.l     #8,D2
00001EEC  0008      
00001EEE  6C00 0052 3332          bge       KillAllBreakPoints_3
                    3333   ; // clear BP
                    3334   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001EF2  2002      3335          move.l    D2,D0
00001EF4  E588      3336          lsl.l     #2,D0
00001EF6  41F9 0B00 3337          lea       _BreakPointAddress.L,A0
00001EFA  012E      
00001EFC  2D70 0800 3338          move.l    0(A0,D0.L),-4(A6)
00001F00  FFFC      
                    3339   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
00001F02  2002      3340          move.l    D2,D0
00001F04  E388      3341          lsl.l     #1,D0
00001F06  41F9 0B00 3342          lea       _BreakPointInstruction.L,A0
00001F0A  014E      
00001F0C  226E FFFC 3343          move.l    -4(A6),A1
00001F10  32B0 0800 3344          move.w    0(A0,D0.L),(A1)
                    3345   ; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
00001F14  2002      3346          move.l    D2,D0
00001F16  E588      3347          lsl.l     #2,D0
00001F18  41F9 0B00 3348          lea       _BreakPointAddress.L,A0
00001F1C  012E      
00001F1E  42B0 0800 3349          clr.l     0(A0,D0.L)
                    3350   ; BreakPointInstruction[i] = 0 ;
00001F22  2002      3351          move.l    D2,D0
00001F24  E388      3352          lsl.l     #1,D0
00001F26  41F9 0B00 3353          lea       _BreakPointInstruction.L,A0
00001F2A  014E      
00001F2C  4270 0800 3354          clr.w     0(A0,D0.L)
                    3355   ; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00001F30  2002      3356          move.l    D2,D0
00001F32  E588      3357          lsl.l     #2,D0
00001F34  41F9 0B00 3358          lea       _BreakPointSetOrCleared.L,A0
00001F38  015E      
00001F3A  42B0 0800 3359          clr.l     0(A0,D0.L)
00001F3E  5282      3360          addq.l    #1,D2
00001F40  60A6      3361          bra       KillAllBreakPoints_1
                    3362   KillAllBreakPoints_3:
00001F42  241F      3363          move.l    (A7)+,D2
00001F44  4E5E      3364          unlk      A6
00001F46  4E75      3365          rts
                    3366   ; }
                    3367   ; //BreakPointDisplay() ;       // display the break points
                    3368   ; }
                    3369   ; void KillAllWatchPoints(void)
                    3370   ; {
                    3371   _KillAllWatchPoints:
00001F48  2F02      3372          move.l    D2,-(A7)
                    3373   ; int i ;
                    3374   ; for(i = 0; i < 8; i++)  {
00001F4A  4282      3375          clr.l     D2
                    3376   KillAllWatchPoints_1:
00001F4C  0C82 0000 3377          cmp.l     #8,D2
00001F50  0008      
00001F52  6C20      3378          bge.s     KillAllWatchPoints_3
                    3379   ; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
00001F54  2002      3380          move.l    D2,D0
00001F56  E588      3381          lsl.l     #2,D0
00001F58  41F9 0B00 3382          lea       _WatchPointAddress.L,A0
00001F5C  0182      
00001F5E  42B0 0800 3383          clr.l     0(A0,D0.L)
                    3384   ; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00001F62  2002      3385          move.l    D2,D0
00001F64  E588      3386          lsl.l     #2,D0
00001F66  41F9 0B00 3387          lea       _WatchPointSetOrCleared.L,A0
00001F6A  01A2      
00001F6C  42B0 0800 3388          clr.l     0(A0,D0.L)
00001F70  5282      3389          addq.l    #1,D2
00001F72  60D8      3390          bra       KillAllWatchPoints_1
                    3391   KillAllWatchPoints_3:
00001F74  241F      3392          move.l    (A7)+,D2
00001F76  4E75      3393          rts
                    3394   ; }
                    3395   ; //WatchPointDisplay() ;       // display the break points
                    3396   ; }
                    3397   ; void SetBreakPoint(void)
                    3398   ; {
                    3399   _SetBreakPoint:
00001F78  4E56 FFFC 3400          link      A6,#-4
00001F7C  48E7 3830 3401          movem.l   D2/D3/D4/A2/A3,-(A7)
00001F80  45F9 0000 3402          lea       _printf.L,A2
00001F84  551E      
00001F86  47F9 0B00 3403          lea       _BreakPointSetOrCleared.L,A3
00001F8A  015E      
                    3404   ; int i ;
                    3405   ; int BPNumber;
                    3406   ; int BPAddress;
                    3407   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3408   ; // see if any free break points
                    3409   ; for(i = 0; i < 8; i ++) {
00001F8C  4282      3410          clr.l     D2
                    3411   SetBreakPoint_1:
00001F8E  0C82 0000 3412          cmp.l     #8,D2
00001F92  0008      
00001F94  6C10      3413          bge.s     SetBreakPoint_3
                    3414   ; if( BreakPointSetOrCleared[i] == 0)
00001F96  2002      3415          move.l    D2,D0
00001F98  E588      3416          lsl.l     #2,D0
00001F9A  2033 0800 3417          move.l    0(A3,D0.L),D0
00001F9E  6602      3418          bne.s     SetBreakPoint_4
                    3419   ; break ;         // if spare BP found allow user to set it
00001FA0  6004      3420          bra.s     SetBreakPoint_3
                    3421   SetBreakPoint_4:
00001FA2  5282      3422          addq.l    #1,D2
00001FA4  60E8      3423          bra       SetBreakPoint_1
                    3424   SetBreakPoint_3:
                    3425   ; }
                    3426   ; if(i == 8) {
00001FA6  0C82 0000 3427          cmp.l     #8,D2
00001FAA  0008      
00001FAC  660E      3428          bne.s     SetBreakPoint_6
                    3429   ; printf("\r\nNo FREE Break Points.....") ;
00001FAE  4879 0000 3430          pea       @m68kde~2_78.L
00001FB2  65E4      
00001FB4  4E92      3431          jsr       (A2)
00001FB6  584F      3432          addq.w    #4,A7
                    3433   ; return ;
00001FB8  6000 00EC 3434          bra       SetBreakPoint_15
                    3435   SetBreakPoint_6:
                    3436   ; }
                    3437   ; printf("\r\nBreak Point Address: ") ;
00001FBC  4879 0000 3438          pea       @m68kde~2_79.L
00001FC0  6600      
00001FC2  4E92      3439          jsr       (A2)
00001FC4  584F      3440          addq.w    #4,A7
                    3441   ; BPAddress = Get8HexDigits(0) ;
00001FC6  42A7      3442          clr.l     -(A7)
00001FC8  4EB8 0CA4 3443          jsr       _Get8HexDigits
00001FCC  584F      3444          addq.w    #4,A7
00001FCE  2600      3445          move.l    D0,D3
                    3446   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
00001FD0  2803      3447          move.l    D3,D4
                    3448   ; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
00001FD2  2003      3449          move.l    D3,D0
00001FD4  C0BC 0000 3450          and.l     #1,D0
00001FD8  0001      
00001FDA  0C80 0000 3451          cmp.l     #1,D0
00001FDE  0001      
00001FE0  660E      3452          bne.s     SetBreakPoint_9
                    3453   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
00001FE2  4879 0000 3454          pea       @m68kde~2_80.L
00001FE6  6618      
00001FE8  4E92      3455          jsr       (A2)
00001FEA  584F      3456          addq.w    #4,A7
                    3457   ; return ;
00001FEC  6000 00B8 3458          bra       SetBreakPoint_15
                    3459   SetBreakPoint_9:
                    3460   ; }
                    3461   ; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
00001FF0  0C83 0000 3462          cmp.l     #32768,D3
00001FF4  8000      
00001FF6  640E      3463          bhs.s     SetBreakPoint_11
                    3464   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
00001FF8  4879 0000 3465          pea       @m68kde~2_81.L
00001FFC  664E      
00001FFE  4E92      3466          jsr       (A2)
00002000  584F      3467          addq.w    #4,A7
                    3468   ; return ;
00002002  6000 00A2 3469          bra       SetBreakPoint_15
                    3470   SetBreakPoint_11:
                    3471   ; }
                    3472   ; // search for first free bp or existing same BP
                    3473   ; for(i = 0; i < 8; i++)  {
00002006  4282      3474          clr.l     D2
                    3475   SetBreakPoint_13:
00002008  0C82 0000 3476          cmp.l     #8,D2
0000200C  0008      
0000200E  6C00 0096 3477          bge       SetBreakPoint_15
                    3478   ; if(BreakPointAddress[i] == BPAddress)   {
00002012  2002      3479          move.l    D2,D0
00002014  E588      3480          lsl.l     #2,D0
00002016  41F9 0B00 3481          lea       _BreakPointAddress.L,A0
0000201A  012E      
0000201C  B6B0 0800 3482          cmp.l     0(A0,D0.L),D3
00002020  6610      3483          bne.s     SetBreakPoint_16
                    3484   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
00002022  2F03      3485          move.l    D3,-(A7)
00002024  4879 0000 3486          pea       @m68kde~2_82.L
00002028  6696      
0000202A  4E92      3487          jsr       (A2)
0000202C  504F      3488          addq.w    #8,A7
                    3489   ; return ;
0000202E  6000 0076 3490          bra       SetBreakPoint_15
                    3491   SetBreakPoint_16:
                    3492   ; }
                    3493   ; if(BreakPointSetOrCleared[i] == 0) {
00002032  2002      3494          move.l    D2,D0
00002034  E588      3495          lsl.l     #2,D0
00002036  2033 0800 3496          move.l    0(A3,D0.L),D0
0000203A  6600 0064 3497          bne       SetBreakPoint_18
                    3498   ; // set BP here
                    3499   ; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
0000203E  2002      3500          move.l    D2,D0
00002040  E588      3501          lsl.l     #2,D0
00002042  27BC 0000 3502          move.l    #1,0(A3,D0.L)
00002046  0001 0800 
                    3503   ; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
0000204A  2044      3504          move.l    D4,A0
0000204C  2002      3505          move.l    D2,D0
0000204E  E388      3506          lsl.l     #1,D0
00002050  43F9 0B00 3507          lea       _BreakPointInstruction.L,A1
00002054  014E      
00002056  3390 0800 3508          move.w    (A0),0(A1,D0.L)
                    3509   ; DisassembleInstruction(ProgramBreakPointAddress) ;
0000205A  2F04      3510          move.l    D4,-(A7)
0000205C  4EB9 0000 3511          jsr       _DisassembleInstruction
00002060  3480      
00002062  584F      3512          addq.w    #4,A7
                    3513   ; FormatInstructionForTrace() ;
00002064  4EB8 12DC 3514          jsr       _FormatInstructionForTrace
                    3515   ; printf("\r\nBreak Point Set at Address: [$%08x], Instruction = %s", ProgramBreakPointAddress, Instruction) ;
00002068  4879 0B00 3516          pea       _Instruction.L
0000206C  04E2      
0000206E  2F04      3517          move.l    D4,-(A7)
00002070  4879 0000 3518          pea       @m68kde~2_83.L
00002074  66CE      
00002076  4E92      3519          jsr       (A2)
00002078  DEFC 000C 3520          add.w     #12,A7
                    3521   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
0000207C  2044      3522          move.l    D4,A0
0000207E  30BC 4E4E 3523          move.w    #20046,(A0)
                    3524   ; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
00002082  2002      3525          move.l    D2,D0
00002084  E588      3526          lsl.l     #2,D0
00002086  41F9 0B00 3527          lea       _BreakPointAddress.L,A0
0000208A  012E      
0000208C  2183 0800 3528          move.l    D3,0(A0,D0.L)
                    3529   ; printf("\r\n") ;
00002090  4879 0000 3530          pea       @m68kde~2_1.L
00002094  5E6E      
00002096  4E92      3531          jsr       (A2)
00002098  584F      3532          addq.w    #4,A7
                    3533   ; BreakPointDisplay() ;       // display the break points
0000209A  4EB8 1B22 3534          jsr       _BreakPointDisplay
                    3535   ; return ;
0000209E  6006      3536          bra.s     SetBreakPoint_15
                    3537   SetBreakPoint_18:
000020A0  5282      3538          addq.l    #1,D2
000020A2  6000 FF64 3539          bra       SetBreakPoint_13
                    3540   SetBreakPoint_15:
000020A6  4CDF 0C1C 3541          movem.l   (A7)+,D2/D3/D4/A2/A3
000020AA  4E5E      3542          unlk      A6
000020AC  4E75      3543          rts
                    3544   ; }
                    3545   ; }
                    3546   ; }
                    3547   ; void SetWatchPoint(void)
                    3548   ; {
                    3549   _SetWatchPoint:
000020AE  4E56 FFF8 3550          link      A6,#-8
000020B2  48E7 3030 3551          movem.l   D2/D3/A2/A3,-(A7)
000020B6  45F9 0000 3552          lea       _printf.L,A2
000020BA  551E      
000020BC  47F9 0B00 3553          lea       _WatchPointSetOrCleared.L,A3
000020C0  01A2      
                    3554   ; int i ;
                    3555   ; int WPNumber;
                    3556   ; int WPAddress;
                    3557   ; volatile unsigned short int *ProgramWatchPointAddress ;
                    3558   ; // see if any free break points
                    3559   ; for(i = 0; i < 8; i ++) {
000020C2  4282      3560          clr.l     D2
                    3561   SetWatchPoint_1:
000020C4  0C82 0000 3562          cmp.l     #8,D2
000020C8  0008      
000020CA  6C10      3563          bge.s     SetWatchPoint_3
                    3564   ; if( WatchPointSetOrCleared[i] == 0)
000020CC  2002      3565          move.l    D2,D0
000020CE  E588      3566          lsl.l     #2,D0
000020D0  2033 0800 3567          move.l    0(A3,D0.L),D0
000020D4  6602      3568          bne.s     SetWatchPoint_4
                    3569   ; break ;         // if spare WP found allow user to set it
000020D6  6004      3570          bra.s     SetWatchPoint_3
                    3571   SetWatchPoint_4:
000020D8  5282      3572          addq.l    #1,D2
000020DA  60E8      3573          bra       SetWatchPoint_1
                    3574   SetWatchPoint_3:
                    3575   ; }
                    3576   ; if(i == 8) {
000020DC  0C82 0000 3577          cmp.l     #8,D2
000020E0  0008      
000020E2  660E      3578          bne.s     SetWatchPoint_6
                    3579   ; printf("\r\nNo FREE Watch Points.....") ;
000020E4  4879 0000 3580          pea       @m68kde~2_84.L
000020E8  6706      
000020EA  4E92      3581          jsr       (A2)
000020EC  584F      3582          addq.w    #4,A7
                    3583   ; return ;
000020EE  6000 008C 3584          bra       SetWatchPoint_11
                    3585   SetWatchPoint_6:
                    3586   ; }
                    3587   ; printf("\r\nWatch Point Address: ") ;
000020F2  4879 0000 3588          pea       @m68kde~2_85.L
000020F6  6722      
000020F8  4E92      3589          jsr       (A2)
000020FA  584F      3590          addq.w    #4,A7
                    3591   ; WPAddress = Get8HexDigits(0) ;
000020FC  42A7      3592          clr.l     -(A7)
000020FE  4EB8 0CA4 3593          jsr       _Get8HexDigits
00002102  584F      3594          addq.w    #4,A7
00002104  2600      3595          move.l    D0,D3
                    3596   ; // search for first free wp or existing same wp
                    3597   ; for(i = 0; i < 8; i++)  {
00002106  4282      3598          clr.l     D2
                    3599   SetWatchPoint_9:
00002108  0C82 0000 3600          cmp.l     #8,D2
0000210C  0008      
0000210E  6C00 006C 3601          bge       SetWatchPoint_11
                    3602   ; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
00002112  2002      3603          move.l    D2,D0
00002114  E588      3604          lsl.l     #2,D0
00002116  41F9 0B00 3605          lea       _WatchPointAddress.L,A0
0000211A  0182      
0000211C  B6B0 0800 3606          cmp.l     0(A0,D0.L),D3
00002120  6614      3607          bne.s     SetWatchPoint_12
00002122  4A83      3608          tst.l     D3
00002124  6710      3609          beq.s     SetWatchPoint_12
                    3610   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
00002126  2F03      3611          move.l    D3,-(A7)
00002128  4879 0000 3612          pea       @m68kde~2_86.L
0000212C  673A      
0000212E  4E92      3613          jsr       (A2)
00002130  504F      3614          addq.w    #8,A7
                    3615   ; return ;
00002132  6000 0048 3616          bra       SetWatchPoint_11
                    3617   SetWatchPoint_12:
                    3618   ; }
                    3619   ; if(WatchPointSetOrCleared[i] == 0) {
00002136  2002      3620          move.l    D2,D0
00002138  E588      3621          lsl.l     #2,D0
0000213A  2033 0800 3622          move.l    0(A3,D0.L),D0
0000213E  6600 0038 3623          bne       SetWatchPoint_14
                    3624   ; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
00002142  2002      3625          move.l    D2,D0
00002144  E588      3626          lsl.l     #2,D0
00002146  27BC 0000 3627          move.l    #1,0(A3,D0.L)
0000214A  0001 0800 
                    3628   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
0000214E  2F03      3629          move.l    D3,-(A7)
00002150  4879 0000 3630          pea       @m68kde~2_87.L
00002154  6770      
00002156  4E92      3631          jsr       (A2)
00002158  504F      3632          addq.w    #8,A7
                    3633   ; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
0000215A  2002      3634          move.l    D2,D0
0000215C  E588      3635          lsl.l     #2,D0
0000215E  41F9 0B00 3636          lea       _WatchPointAddress.L,A0
00002162  0182      
00002164  2183 0800 3637          move.l    D3,0(A0,D0.L)
                    3638   ; printf("\r\n") ;
00002168  4879 0000 3639          pea       @m68kde~2_1.L
0000216C  5E6E      
0000216E  4E92      3640          jsr       (A2)
00002170  584F      3641          addq.w    #4,A7
                    3642   ; WatchPointDisplay() ;       // display the break points
00002172  4EB8 1C1C 3643          jsr       _WatchPointDisplay
                    3644   ; return ;
00002176  6004      3645          bra.s     SetWatchPoint_11
                    3646   SetWatchPoint_14:
00002178  5282      3647          addq.l    #1,D2
0000217A  608C      3648          bra       SetWatchPoint_9
                    3649   SetWatchPoint_11:
0000217C  4CDF 0C0C 3650          movem.l   (A7)+,D2/D3/A2/A3
00002180  4E5E      3651          unlk      A6
00002182  4E75      3652          rts
                    3653   ; }
                    3654   ; }
                    3655   ; }
                    3656   ; void HandleBreakPoint(void)
                    3657   ; {
                    3658   _HandleBreakPoint:
00002184  4E56 FFFC 3659          link      A6,#-4
00002188  48E7 0038 3660          movem.l   A2/A3/A4,-(A7)
0000218C  45F9 0B00 3661          lea       _i.L,A2
00002190  00C4      
00002192  47F9 0000 3662          lea       _printf.L,A3
00002196  551E      
00002198  49F9 0B00 3663          lea       _PC.L,A4
0000219C  0120      
                    3664   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3665   ; // now we have to put the break point back to run the instruction
                    3666   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3667   ; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
0000219E  5594      3668          subq.l    #2,(A4)
                    3669   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
000021A0  4879 0000 3670          pea       @m68kde~2_88.L
000021A4  6796      
000021A6  4E93      3671          jsr       (A3)
000021A8  584F      3672          addq.w    #4,A7
                    3673   ; printf("\r\nSingle Step : [ON]") ;
000021AA  4879 0000 3674          pea       @m68kde~2_89.L
000021AE  67AA      
000021B0  4E93      3675          jsr       (A3)
000021B2  584F      3676          addq.w    #4,A7
                    3677   ; printf("\r\nBreakPoints : [Enabled]") ;
000021B4  4879 0000 3678          pea       @m68kde~2_90.L
000021B8  67C0      
000021BA  4E93      3679          jsr       (A3)
000021BC  584F      3680          addq.w    #4,A7
                    3681   ; // now clear the break point (put original instruction back)
                    3682   ; ProgramBreakPointAddress = PC ;
000021BE  2D54 FFFC 3683          move.l    (A4),-4(A6)
                    3684   ; for(i = 0; i < 8; i ++) {
000021C2  4292      3685          clr.l     (A2)
                    3686   HandleBreakPoint_1:
000021C4  2012      3687          move.l    (A2),D0
000021C6  0C80 0000 3688          cmp.l     #8,D0
000021CA  0008      
000021CC  6400 0056 3689          bhs       HandleBreakPoint_3
                    3690   ; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
000021D0  2012      3691          move.l    (A2),D0
000021D2  E588      3692          lsl.l     #2,D0
000021D4  41F9 0B00 3693          lea       _BreakPointAddress.L,A0
000021D8  012E      
000021DA  2230 0800 3694          move.l    0(A0,D0.L),D1
000021DE  B294      3695          cmp.l     (A4),D1
000021E0  6600 003E 3696          bne       HandleBreakPoint_4
                    3697   ; BreakPointAddress[i] = 0 ;
000021E4  2012      3698          move.l    (A2),D0
000021E6  E588      3699          lsl.l     #2,D0
000021E8  41F9 0B00 3700          lea       _BreakPointAddress.L,A0
000021EC  012E      
000021EE  42B0 0800 3701          clr.l     0(A0,D0.L)
                    3702   ; BreakPointSetOrCleared[i] = 0 ;
000021F2  2012      3703          move.l    (A2),D0
000021F4  E588      3704          lsl.l     #2,D0
000021F6  41F9 0B00 3705          lea       _BreakPointSetOrCleared.L,A0
000021FA  015E      
000021FC  42B0 0800 3706          clr.l     0(A0,D0.L)
                    3707   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00002200  2012      3708          move.l    (A2),D0
00002202  E388      3709          lsl.l     #1,D0
00002204  41F9 0B00 3710          lea       _BreakPointInstruction.L,A0
00002208  014E      
0000220A  226E FFFC 3711          move.l    -4(A6),A1
0000220E  32B0 0800 3712          move.w    0(A0,D0.L),(A1)
                    3713   ; BreakPointInstruction[i] = 0 ;
00002212  2012      3714          move.l    (A2),D0
00002214  E388      3715          lsl.l     #1,D0
00002216  41F9 0B00 3716          lea       _BreakPointInstruction.L,A0
0000221A  014E      
0000221C  4270 0800 3717          clr.w     0(A0,D0.L)
                    3718   HandleBreakPoint_4:
00002220  5292      3719          addq.l    #1,(A2)
00002222  60A0      3720          bra       HandleBreakPoint_1
                    3721   HandleBreakPoint_3:
                    3722   ; }
                    3723   ; }
                    3724   ; DumpRegisters() ;
00002224  4EB8 1350 3725          jsr       _DumpRegisters
                    3726   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00002228  4879 0000 3727          pea       @m68kde~2_51.L
0000222C  6322      
0000222E  4E93      3728          jsr       (A3)
00002230  584F      3729          addq.w    #4,A7
                    3730   ; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
00002232  4879 0000 3731          pea       @m68kde~2_91.L
00002236  67DA      
00002238  4E93      3732          jsr       (A3)
0000223A  584F      3733          addq.w    #4,A7
                    3734   ; menu() ;
0000223C  4EB9 0000 3735          jsr       _menu
00002240  2492      
00002242  4CDF 1C00 3736          movem.l   (A7)+,A2/A3/A4
00002246  4E5E      3737          unlk      A6
00002248  4E75      3738          rts
                    3739   ; }
                    3740   ; void UnknownCommand()
                    3741   ; {
                    3742   _UnknownCommand:
                    3743   ; printf("\r\nUnknown Command.....\r\n") ;
0000224A  4879 0000 3744          pea       @m68kde~2_92.L
0000224E  6802      
00002250  4EB9 0000 3745          jsr       _printf
00002254  551E      
00002256  584F      3746          addq.w    #4,A7
                    3747   ; Help() ;
00002258  4EB9 0000 3748          jsr       _Help
0000225C  23AE      
0000225E  4E75      3749          rts
                    3750   ; }
                    3751   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    3752   ; void CallDebugMonitor(void)
                    3753   ; {
                    3754   _CallDebugMonitor:
                    3755   ; printf("\r\nProgram Ended (TRAP #15)....") ;
00002260  4879 0000 3756          pea       @m68kde~2_93.L
00002264  681C      
00002266  4EB9 0000 3757          jsr       _printf
0000226A  551E      
0000226C  584F      3758          addq.w    #4,A7
                    3759   ; menu();
0000226E  4EB9 0000 3760          jsr       _menu
00002272  2492      
00002274  4E75      3761          rts
                    3762   ; }
                    3763   ; void Breakpoint(void)
                    3764   ; {
                    3765   _Breakpoint:
00002276  2F02      3766          move.l    D2,-(A7)
                    3767   ; char c;
                    3768   ; c = toupper(_getch());
00002278  2F00      3769          move.l    D0,-(A7)
0000227A  4EB8 0B68 3770          jsr       __getch
0000227E  2200      3771          move.l    D0,D1
00002280  201F      3772          move.l    (A7)+,D0
00002282  2F01      3773          move.l    D1,-(A7)
00002284  4EB9 0000 3774          jsr       _toupper
00002288  54F2      
0000228A  584F      3775          addq.w    #4,A7
0000228C  1400      3776          move.b    D0,D2
                    3777   ; if( c == (char)('D'))                                      // BreakPoint Display
0000228E  0C02 0044 3778          cmp.b     #68,D2
00002292  6608      3779          bne.s     Breakpoint_1
                    3780   ; BreakPointDisplay() ;
00002294  4EB8 1B22 3781          jsr       _BreakPointDisplay
00002298  6000 0054 3782          bra       Breakpoint_10
                    3783   Breakpoint_1:
                    3784   ; else if(c == (char)('K')) {                                 // breakpoint Kill
0000229C  0C02 004B 3785          cmp.b     #75,D2
000022A0  6630      3786          bne.s     Breakpoint_3
                    3787   ; printf("\r\nKill All Break Points...(y/n)?") ;
000022A2  4879 0000 3788          pea       @m68kde~2_94.L
000022A6  683C      
000022A8  4EB9 0000 3789          jsr       _printf
000022AC  551E      
000022AE  584F      3790          addq.w    #4,A7
                    3791   ; c = toupper(_getch());
000022B0  2F00      3792          move.l    D0,-(A7)
000022B2  4EB8 0B68 3793          jsr       __getch
000022B6  2200      3794          move.l    D0,D1
000022B8  201F      3795          move.l    (A7)+,D0
000022BA  2F01      3796          move.l    D1,-(A7)
000022BC  4EB9 0000 3797          jsr       _toupper
000022C0  54F2      
000022C2  584F      3798          addq.w    #4,A7
000022C4  1400      3799          move.b    D0,D2
                    3800   ; if(c == (char)('Y'))
000022C6  0C02 0059 3801          cmp.b     #89,D2
000022CA  6604      3802          bne.s     Breakpoint_5
                    3803   ; KillAllBreakPoints() ;
000022CC  4EB8 1EE0 3804          jsr       _KillAllBreakPoints
                    3805   Breakpoint_5:
000022D0  601C      3806          bra.s     Breakpoint_10
                    3807   Breakpoint_3:
                    3808   ; }
                    3809   ; else if(c == (char)('S')) {
000022D2  0C02 0053 3810          cmp.b     #83,D2
000022D6  6606      3811          bne.s     Breakpoint_7
                    3812   ; SetBreakPoint() ;
000022D8  4EB8 1F78 3813          jsr       _SetBreakPoint
000022DC  6010      3814          bra.s     Breakpoint_10
                    3815   Breakpoint_7:
                    3816   ; }
                    3817   ; else if(c == (char)('C')) {
000022DE  0C02 0043 3818          cmp.b     #67,D2
000022E2  6606      3819          bne.s     Breakpoint_9
                    3820   ; BreakPointClear() ;
000022E4  4EB8 1CC8 3821          jsr       _BreakPointClear
000022E8  6004      3822          bra.s     Breakpoint_10
                    3823   Breakpoint_9:
                    3824   ; }
                    3825   ; else
                    3826   ; UnknownCommand() ;
000022EA  4EB8 224A 3827          jsr       _UnknownCommand
                    3828   Breakpoint_10:
000022EE  241F      3829          move.l    (A7)+,D2
000022F0  4E75      3830          rts
                    3831   ; }
                    3832   ; void Watchpoint(void)
                    3833   ; {
                    3834   _Watchpoint:
000022F2  2F02      3835          move.l    D2,-(A7)
                    3836   ; char c;
                    3837   ; c = toupper(_getch());
000022F4  2F00      3838          move.l    D0,-(A7)
000022F6  4EB8 0B68 3839          jsr       __getch
000022FA  2200      3840          move.l    D0,D1
000022FC  201F      3841          move.l    (A7)+,D0
000022FE  2F01      3842          move.l    D1,-(A7)
00002300  4EB9 0000 3843          jsr       _toupper
00002304  54F2      
00002306  584F      3844          addq.w    #4,A7
00002308  1400      3845          move.b    D0,D2
                    3846   ; if( c == (char)('D'))                                      // WatchPoint Display
0000230A  0C02 0044 3847          cmp.b     #68,D2
0000230E  6608      3848          bne.s     Watchpoint_1
                    3849   ; WatchPointDisplay() ;
00002310  4EB8 1C1C 3850          jsr       _WatchPointDisplay
00002314  6000 0054 3851          bra       Watchpoint_10
                    3852   Watchpoint_1:
                    3853   ; else if(c == (char)('K')) {                                 // wtahcpoint Kill
00002318  0C02 004B 3854          cmp.b     #75,D2
0000231C  6630      3855          bne.s     Watchpoint_3
                    3856   ; printf("\r\nKill All Watch Points...(y/n)?") ;
0000231E  4879 0000 3857          pea       @m68kde~2_95.L
00002322  685E      
00002324  4EB9 0000 3858          jsr       _printf
00002328  551E      
0000232A  584F      3859          addq.w    #4,A7
                    3860   ; c = toupper(_getch());
0000232C  2F00      3861          move.l    D0,-(A7)
0000232E  4EB8 0B68 3862          jsr       __getch
00002332  2200      3863          move.l    D0,D1
00002334  201F      3864          move.l    (A7)+,D0
00002336  2F01      3865          move.l    D1,-(A7)
00002338  4EB9 0000 3866          jsr       _toupper
0000233C  54F2      
0000233E  584F      3867          addq.w    #4,A7
00002340  1400      3868          move.b    D0,D2
                    3869   ; if(c == (char)('Y'))
00002342  0C02 0059 3870          cmp.b     #89,D2
00002346  6604      3871          bne.s     Watchpoint_5
                    3872   ; KillAllWatchPoints() ;
00002348  4EB8 1F48 3873          jsr       _KillAllWatchPoints
                    3874   Watchpoint_5:
0000234C  601C      3875          bra.s     Watchpoint_10
                    3876   Watchpoint_3:
                    3877   ; }
                    3878   ; else if(c == (char)('S')) {
0000234E  0C02 0053 3879          cmp.b     #83,D2
00002352  6606      3880          bne.s     Watchpoint_7
                    3881   ; SetWatchPoint() ;
00002354  4EB8 20AE 3882          jsr       _SetWatchPoint
00002358  6010      3883          bra.s     Watchpoint_10
                    3884   Watchpoint_7:
                    3885   ; }
                    3886   ; else if(c == (char)('C')) {
0000235A  0C02 0043 3887          cmp.b     #67,D2
0000235E  6606      3888          bne.s     Watchpoint_9
                    3889   ; WatchPointClear() ;
00002360  4EB8 1DA2 3890          jsr       _WatchPointClear
00002364  6004      3891          bra.s     Watchpoint_10
                    3892   Watchpoint_9:
                    3893   ; }
                    3894   ; else
                    3895   ; UnknownCommand() ;
00002366  4EB8 224A 3896          jsr       _UnknownCommand
                    3897   Watchpoint_10:
0000236A  241F      3898          move.l    (A7)+,D2
0000236C  4E75      3899          rts
                    3900   ; }
                    3901   ; void DMenu(void)
                    3902   ; {
                    3903   _DMenu:
0000236E  2F02      3904          move.l    D2,-(A7)
                    3905   ; char c;
                    3906   ; c = toupper(_getch());
00002370  2F00      3907          move.l    D0,-(A7)
00002372  4EB8 0B68 3908          jsr       __getch
00002376  2200      3909          move.l    D0,D1
00002378  201F      3910          move.l    (A7)+,D0
0000237A  2F01      3911          move.l    D1,-(A7)
0000237C  4EB9 0000 3912          jsr       _toupper
00002380  54F2      
00002382  584F      3913          addq.w    #4,A7
00002384  1400      3914          move.b    D0,D2
                    3915   ; if( c == (char)('U'))                                     // Dump Memory
00002386  0C02 0055 3916          cmp.b     #85,D2
0000238A  6606      3917          bne.s     DMenu_1
                    3918   ; DumpMemory() ;
0000238C  4EB8 0EE0 3919          jsr       _DumpMemory
00002390  6018      3920          bra.s     DMenu_4
                    3921   DMenu_1:
                    3922   ; else if(c == (char)('I'))   {
00002392  0C02 0049 3923          cmp.b     #73,D2
00002396  660E      3924          bne.s     DMenu_3
                    3925   ; DisableBreakPoints() ;
00002398  4EB8 1E44 3926          jsr       _DisableBreakPoints
                    3927   ; DisassembleProgram() ;
0000239C  4EB8 0D00 3928          jsr       _DisassembleProgram
                    3929   ; EnableBreakPoints() ;
000023A0  4EB8 1E98 3930          jsr       _EnableBreakPoints
000023A4  6004      3931          bra.s     DMenu_4
                    3932   DMenu_3:
                    3933   ; }
                    3934   ; else
                    3935   ; UnknownCommand() ;
000023A6  4EB8 224A 3936          jsr       _UnknownCommand
                    3937   DMenu_4:
000023AA  241F      3938          move.l    (A7)+,D2
000023AC  4E75      3939          rts
                    3940   ; }
                    3941   ; void Help(void)
                    3942   ; {
                    3943   _Help:
000023AE  48E7 2020 3944          movem.l   D2/A2,-(A7)
000023B2  45F9 0000 3945          lea       _printf.L,A2
000023B6  551E      
                    3946   ; char *banner = "\r\n----------------------------------------------------------------" ;
000023B8  41F9 0000 3947          lea       @m68kde~2_96.L,A0
000023BC  6880      
000023BE  2408      3948          move.l    A0,D2
                    3949   ; printf(banner) ;
000023C0  2F02      3950          move.l    D2,-(A7)
000023C2  4E92      3951          jsr       (A2)
000023C4  584F      3952          addq.w    #4,A7
                    3953   ; printf("\r\n  Debugger Command Summary") ;
000023C6  4879 0000 3954          pea       @m68kde~2_97.L
000023CA  68C4      
000023CC  4E92      3955          jsr       (A2)
000023CE  584F      3956          addq.w    #4,A7
                    3957   ; printf(banner) ;
000023D0  2F02      3958          move.l    D2,-(A7)
000023D2  4E92      3959          jsr       (A2)
000023D4  584F      3960          addq.w    #4,A7
                    3961   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
000023D6  4879 0000 3962          pea       @m68kde~2_98.L
000023DA  68E2      
000023DC  4E92      3963          jsr       (A2)
000023DE  584F      3964          addq.w    #4,A7
                    3965   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill") ;
000023E0  4879 0000 3966          pea       @m68kde~2_99.L
000023E4  6926      
000023E6  4E92      3967          jsr       (A2)
000023E8  584F      3968          addq.w    #4,A7
                    3969   ; printf("\r\n  C            - Copy Program from Flash to Main Memory") ;
000023EA  4879 0000 3970          pea       @m68kde~2_100.L
000023EE  695E      
000023F0  4E92      3971          jsr       (A2)
000023F2  584F      3972          addq.w    #4,A7
                    3973   ; printf("\r\n  DI           - Disassemble Program");
000023F4  4879 0000 3974          pea       @m68kde~2_101.L
000023F8  6998      
000023FA  4E92      3975          jsr       (A2)
000023FC  584F      3976          addq.w    #4,A7
                    3977   ; printf("\r\n  DU           - Dump Memory Contents to Screen") ;
000023FE  4879 0000 3978          pea       @m68kde~2_102.L
00002402  69C0      
00002404  4E92      3979          jsr       (A2)
00002406  584F      3980          addq.w    #4,A7
                    3981   ; printf("\r\n  E            - Enter String into Memory") ;
00002408  4879 0000 3982          pea       @m68kde~2_103.L
0000240C  69F2      
0000240E  4E92      3983          jsr       (A2)
00002410  584F      3984          addq.w    #4,A7
                    3985   ; printf("\r\n  F            - Fill Memory with Data") ;
00002412  4879 0000 3986          pea       @m68kde~2_104.L
00002416  6A1E      
00002418  4E92      3987          jsr       (A2)
0000241A  584F      3988          addq.w    #4,A7
                    3989   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC) ;
0000241C  2F39 0B00 3990          move.l    _PC.L,-(A7)
00002420  0120      
00002422  4879 0000 3991          pea       @m68kde~2_105.L
00002426  6A48      
00002428  4E92      3992          jsr       (A2)
0000242A  504F      3993          addq.w    #8,A7
                    3994   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop") ;
0000242C  4879 0000 3995          pea       @m68kde~2_106.L
00002430  6A82      
00002432  4E92      3996          jsr       (A2)
00002434  584F      3997          addq.w    #4,A7
                    3998   ; printf("\r\n  M            - Memory Examine and Change");
00002436  4879 0000 3999          pea       @m68kde~2_107.L
0000243A  6ABA      
0000243C  4E92      4000          jsr       (A2)
0000243E  584F      4001          addq.w    #4,A7
                    4002   ; printf("\r\n  P            - Program Flash Memory with User Program") ;
00002440  4879 0000 4003          pea       @m68kde~2_108.L
00002444  6AE8      
00002446  4E92      4004          jsr       (A2)
00002448  584F      4005          addq.w    #4,A7
                    4006   ; printf("\r\n  R            - Display 68000 Registers") ;
0000244A  4879 0000 4007          pea       @m68kde~2_109.L
0000244E  6B22      
00002450  4E92      4008          jsr       (A2)
00002452  584F      4009          addq.w    #4,A7
                    4010   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode") ;
00002454  4879 0000 4011          pea       @m68kde~2_110.L
00002458  6B4E      
0000245A  4E92      4012          jsr       (A2)
0000245C  584F      4013          addq.w    #4,A7
                    4014   ; printf("\r\n  TM           - Test Memory") ;
0000245E  4879 0000 4015          pea       @m68kde~2_111.L
00002462  6B80      
00002464  4E92      4016          jsr       (A2)
00002466  584F      4017          addq.w    #4,A7
                    4018   ; printf("\r\n  TS           - Test Switches: SW7-0") ;
00002468  4879 0000 4019          pea       @m68kde~2_112.L
0000246C  6BA0      
0000246E  4E92      4020          jsr       (A2)
00002470  584F      4021          addq.w    #4,A7
                    4022   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment") ;
00002472  4879 0000 4023          pea       @m68kde~2_113.L
00002476  6BC8      
00002478  4E92      4024          jsr       (A2)
0000247A  584F      4025          addq.w    #4,A7
                    4026   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill") ;
0000247C  4879 0000 4027          pea       @m68kde~2_114.L
00002480  6BFE      
00002482  4E92      4028          jsr       (A2)
00002484  584F      4029          addq.w    #4,A7
                    4030   ; printf(banner) ;
00002486  2F02      4031          move.l    D2,-(A7)
00002488  4E92      4032          jsr       (A2)
0000248A  584F      4033          addq.w    #4,A7
0000248C  4CDF 0404 4034          movem.l   (A7)+,D2/A2
00002490  4E75      4035          rts
                    4036   ; }
                    4037   ; void menu(void)
                    4038   ; {
                    4039   _menu:
00002492  48E7 303C 4040          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00002496  45F9 0000 4041          lea       _printf.L,A2
0000249A  551E      
0000249C  47F9 0B00 4042          lea       _Trace.L,A3
000024A0  00D8      
000024A2  49F9 0B00 4043          lea       _x.L,A4
000024A6  00C8      
000024A8  4BF9 0B00 4044          lea       _SR.L,A5
000024AC  012C      
                    4045   ; char c,c1 ;
                    4046   ; while(1)    {
                    4047   menu_1:
                    4048   ; FlushKeyboard() ;               // dump unread characters from keyboard
000024AE  4EB8 0BA6 4049          jsr       _FlushKeyboard
                    4050   ; printf("\r\n#") ;
000024B2  4879 0000 4051          pea       @m68kde~2_115.L
000024B6  6C36      
000024B8  4E92      4052          jsr       (A2)
000024BA  584F      4053          addq.w    #4,A7
                    4054   ; c = toupper(_getch());
000024BC  2F00      4055          move.l    D0,-(A7)
000024BE  4EB8 0B68 4056          jsr       __getch
000024C2  2200      4057          move.l    D0,D1
000024C4  201F      4058          move.l    (A7)+,D0
000024C6  2F01      4059          move.l    D1,-(A7)
000024C8  4EB9 0000 4060          jsr       _toupper
000024CC  54F2      
000024CE  584F      4061          addq.w    #4,A7
000024D0  1400      4062          move.b    D0,D2
                    4063   ; if( c == (char)('L'))                  // load s record file
000024D2  0C02 004C 4064          cmp.b     #76,D2
000024D6  6608      4065          bne.s     menu_4
                    4066   ; Load_SRecordFile() ;
000024D8  4EB8 104A 4067          jsr       _Load_SRecordFile
000024DC  6000 021E 4068          bra       menu_46
                    4069   menu_4:
                    4070   ; else if( c == (char)('D'))             // dump memory
000024E0  0C02 0044 4071          cmp.b     #68,D2
000024E4  6608      4072          bne.s     menu_6
                    4073   ; DMenu() ;
000024E6  4EB8 236E 4074          jsr       _DMenu
000024EA  6000 0210 4075          bra       menu_46
                    4076   menu_6:
                    4077   ; else if( c == (char)('E'))             // Enter String into memory
000024EE  0C02 0045 4078          cmp.b     #69,D2
000024F2  660A      4079          bne.s     menu_8
                    4080   ; EnterString() ;
000024F4  4EB9 0000 4081          jsr       _EnterString
000024F8  2844      
000024FA  6000 0200 4082          bra       menu_46
                    4083   menu_8:
                    4084   ; else if( c == (char)('F'))             // fill memory
000024FE  0C02 0046 4085          cmp.b     #70,D2
00002502  6608      4086          bne.s     menu_10
                    4087   ; FillMemory() ;
00002504  4EB8 0FD0 4088          jsr       _FillMemory
00002508  6000 01F2 4089          bra       menu_46
                    4090   menu_10:
                    4091   ; else if( c == (char)('G'))  {           // go user program
0000250C  0C02 0047 4092          cmp.b     #71,D2
00002510  6626      4093          bne.s     menu_12
                    4094   ; printf("\r\nProgram Running.....") ;
00002512  4879 0000 4095          pea       @m68kde~2_116.L
00002516  6C3A      
00002518  4E92      4096          jsr       (A2)
0000251A  584F      4097          addq.w    #4,A7
                    4098   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
0000251C  4879 0000 4099          pea       @m68kde~2_117.L
00002520  6C52      
00002522  4E92      4100          jsr       (A2)
00002524  584F      4101          addq.w    #4,A7
                    4102   ; GoFlag = 1 ;
00002526  23FC 0000 4103          move.l    #1,_GoFlag.L
0000252A  0001 0B00 
0000252E  00DC      
                    4104   ; go() ;
00002530  4EB8 08B8 4105          jsr       _go
00002534  6000 01C6 4106          bra       menu_46
                    4107   menu_12:
                    4108   ; }
                    4109   ; else if( c == (char)('M'))           // memory examine and modify
00002538  0C02 004D 4110          cmp.b     #77,D2
0000253C  6608      4111          bne.s     menu_14
                    4112   ; MemoryChange() ;
0000253E  4EB8 11D8 4113          jsr       _MemoryChange
00002542  6000 01B8 4114          bra       menu_46
                    4115   menu_14:
                    4116   ; else if( c == (char)('P'))            // Program Flash Chip
00002546  0C02 0050 4117          cmp.b     #80,D2
0000254A  6608      4118          bne.s     menu_16
                    4119   ; ProgramFlashChip() ;
0000254C  4EB8 12D8 4120          jsr       _ProgramFlashChip
00002550  6000 01AA 4121          bra       menu_46
                    4122   menu_16:
                    4123   ; else if( c == (char)('C'))             // copy flash chip to ram and go
00002554  0C02 0043 4124          cmp.b     #67,D2
00002558  6608      4125          bne.s     menu_18
                    4126   ; LoadFromFlashChip();
0000255A  4EB8 12DA 4127          jsr       _LoadFromFlashChip
0000255E  6000 019C 4128          bra       menu_46
                    4129   menu_18:
                    4130   ; else if( c == (char)('R'))             // dump registers
00002562  0C02 0052 4131          cmp.b     #82,D2
00002566  6608      4132          bne.s     menu_20
                    4133   ; DumpRegisters() ;
00002568  4EB8 1350 4134          jsr       _DumpRegisters
0000256C  6000 018E 4135          bra       menu_46
                    4136   menu_20:
                    4137   ; else if( c == (char)('.'))           // change registers
00002570  0C02 002E 4138          cmp.b     #46,D2
00002574  6608      4139          bne.s     menu_22
                    4140   ; ChangeRegisters() ;
00002576  4EB8 1866 4141          jsr       _ChangeRegisters
0000257A  6000 0180 4142          bra       menu_46
                    4143   menu_22:
                    4144   ; else if( c == (char)('B'))              // breakpoint command
0000257E  0C02 0042 4145          cmp.b     #66,D2
00002582  6608      4146          bne.s     menu_24
                    4147   ; Breakpoint() ;
00002584  4EB8 2276 4148          jsr       _Breakpoint
00002588  6000 0172 4149          bra       menu_46
                    4150   menu_24:
                    4151   ; else if( c == (char)('T'))  {          // Test command
0000258C  0C02 0054 4152          cmp.b     #84,D2
00002590  6600 0046 4153          bne       menu_26
                    4154   ; c1 = toupper(_getch()) ;
00002594  2F00      4155          move.l    D0,-(A7)
00002596  4EB8 0B68 4156          jsr       __getch
0000259A  2200      4157          move.l    D0,D1
0000259C  201F      4158          move.l    (A7)+,D0
0000259E  2F01      4159          move.l    D1,-(A7)
000025A0  4EB9 0000 4160          jsr       _toupper
000025A4  54F2      
000025A6  584F      4161          addq.w    #4,A7
000025A8  1600      4162          move.b    D0,D3
                    4163   ; if(c1 == (char)('M'))                    // memory test
000025AA  0C03 004D 4164          cmp.b     #77,D3
000025AE  6608      4165          bne.s     menu_28
                    4166   ; MemoryTest() ;
000025B0  4EB9 0000 4167          jsr       _MemoryTest
000025B4  2894      
000025B6  601C      4168          bra.s     menu_33
                    4169   menu_28:
                    4170   ; else if( c1 == (char)('S'))              // Switch Test command
000025B8  0C03 0053 4171          cmp.b     #83,D3
000025BC  6606      4172          bne.s     menu_30
                    4173   ; SwitchTest() ;
000025BE  4EB8 0AA4 4174          jsr       _SwitchTest
000025C2  6010      4175          bra.s     menu_33
                    4176   menu_30:
                    4177   ; else if( c1 == (char)('D'))              // display Test command
000025C4  0C03 0044 4178          cmp.b     #68,D3
000025C8  6606      4179          bne.s     menu_32
                    4180   ; TestLEDS() ;
000025CA  4EB8 0A50 4181          jsr       _TestLEDS
000025CE  6004      4182          bra.s     menu_33
                    4183   menu_32:
                    4184   ; else
                    4185   ; UnknownCommand() ;
000025D0  4EB8 224A 4186          jsr       _UnknownCommand
                    4187   menu_33:
000025D4  6000 0126 4188          bra       menu_46
                    4189   menu_26:
                    4190   ; }
                    4191   ; else if( c == (char)(' ')) {             // Next instruction command
000025D8  0C02 0020 4192          cmp.b     #32,D2
000025DC  6636      4193          bne.s     menu_34
                    4194   ; DisableBreakPoints() ;
000025DE  4EB8 1E44 4195          jsr       _DisableBreakPoints
                    4196   ; if(Trace == 1 && GoFlag == 1)   {    // if the program is running and trace mode on then 'N' is valid
000025E2  2013      4197          move.l    (A3),D0
000025E4  0C80 0000 4198          cmp.l     #1,D0
000025E8  0001      
000025EA  661A      4199          bne.s     menu_36
000025EC  2039 0B00 4200          move.l    _GoFlag.L,D0
000025F0  00DC      
000025F2  0C80 0000 4201          cmp.l     #1,D0
000025F6  0001      
000025F8  660C      4202          bne.s     menu_36
                    4203   ; TraceException = 1 ;             // generate a trace exception for the next instruction if user wants to single step though next instruction
000025FA  13FC 0001 4204          move.b    #1,4194314
000025FE  0040 000A 
                    4205   ; return ;
00002602  6000 00FC 4206          bra       menu_38
                    4207   menu_36:
                    4208   ; }
                    4209   ; else
                    4210   ; printf("\r\nError: Press 'G' first to start program") ;
00002606  4879 0000 4211          pea       @m68kde~2_118.L
0000260A  6C80      
0000260C  4E92      4212          jsr       (A2)
0000260E  584F      4213          addq.w    #4,A7
00002610  6000 00EA 4214          bra       menu_46
                    4215   menu_34:
                    4216   ; }
                    4217   ; else if( c == (char)('S')) {             // single step
00002614  0C02 0053 4218          cmp.b     #83,D2
00002618  6600 008C 4219          bne       menu_39
                    4220   ; if(Trace == 0) {
0000261C  2013      4221          move.l    (A3),D0
0000261E  6600 0050 4222          bne       menu_41
                    4223   ; DisableBreakPoints() ;
00002622  4EB8 1E44 4224          jsr       _DisableBreakPoints
                    4225   ; printf("\r\nSingle Step  :[ON]") ;
00002626  4879 0000 4226          pea       @m68kde~2_119.L
0000262A  6CAA      
0000262C  4E92      4227          jsr       (A2)
0000262E  584F      4228          addq.w    #4,A7
                    4229   ; printf("\r\nBreak Points :[Disabled]") ;
00002630  4879 0000 4230          pea       @m68kde~2_50.L
00002634  6306      
00002636  4E92      4231          jsr       (A2)
00002638  584F      4232          addq.w    #4,A7
                    4233   ; SR = SR | (unsigned short int)(0x8000) ;    // set T bit in status register
0000263A  0055 8000 4234          or.w      #32768,(A5)
                    4235   ; printf("\r\nPress 'G' to Trace Program from address $%X.....",PC) ;
0000263E  2F39 0B00 4236          move.l    _PC.L,-(A7)
00002642  0120      
00002644  4879 0000 4237          pea       @m68kde~2_120.L
00002648  6CC0      
0000264A  4E92      4238          jsr       (A2)
0000264C  504F      4239          addq.w    #8,A7
                    4240   ; printf("\r\nPush <RESET Button> to Stop.....") ;
0000264E  4879 0000 4241          pea       @m68kde~2_121.L
00002652  6CF4      
00002654  4E92      4242          jsr       (A2)
00002656  584F      4243          addq.w    #4,A7
                    4244   ; DumpRegisters() ;
00002658  4EB8 1350 4245          jsr       _DumpRegisters
                    4246   ; Trace = 1;
0000265C  26BC 0000 4247          move.l    #1,(A3)
00002660  0001      
                    4248   ; TraceException = 1;
00002662  13FC 0001 4249          move.b    #1,4194314
00002666  0040 000A 
                    4250   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
0000266A  28B8 0074 4251          move.l    116,(A4)
0000266E  6032      4252          bra.s     menu_42
                    4253   menu_41:
                    4254   ; }
                    4255   ; else {
                    4256   ; Trace = 0 ;
00002670  4293      4257          clr.l     (A3)
                    4258   ; TraceException = 0 ;
00002672  4239 0040 4259          clr.b     4194314
00002676  000A      
                    4260   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002678  28B8 0074 4261          move.l    116,(A4)
                    4262   ; EnableBreakPoints() ;
0000267C  4EB8 1E98 4263          jsr       _EnableBreakPoints
                    4264   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
00002680  0255 7FFF 4265          and.w     #32767,(A5)
                    4266   ; printf("\r\nSingle Step : [OFF]") ;
00002684  4879 0000 4267          pea       @m68kde~2_122.L
00002688  6D18      
0000268A  4E92      4268          jsr       (A2)
0000268C  584F      4269          addq.w    #4,A7
                    4270   ; printf("\r\nBreak Points :[Enabled]") ;
0000268E  4879 0000 4271          pea       @m68kde~2_123.L
00002692  6D2E      
00002694  4E92      4272          jsr       (A2)
00002696  584F      4273          addq.w    #4,A7
                    4274   ; printf("\r\nPress <ESC> to Resume User Program.....") ;
00002698  4879 0000 4275          pea       @m68kde~2_124.L
0000269C  6D48      
0000269E  4E92      4276          jsr       (A2)
000026A0  584F      4277          addq.w    #4,A7
                    4278   menu_42:
000026A2  6000 0058 4279          bra       menu_46
                    4280   menu_39:
                    4281   ; }
                    4282   ; }
                    4283   ; else if(c == (char)(0x1b))  {   // if user choses to end trace and run program
000026A6  0C02 001B 4284          cmp.b     #27,D2
000026AA  6600 0040 4285          bne       menu_43
                    4286   ; Trace = 0;
000026AE  4293      4287          clr.l     (A3)
                    4288   ; TraceException = 0;
000026B0  4239 0040 4289          clr.b     4194314
000026B4  000A      
                    4290   ; x = *(unsigned int *)(0x00000074) ;   // read IRQ 5 vector to reset trace vector generator
000026B6  28B8 0074 4291          move.l    116,(A4)
                    4292   ; EnableBreakPoints() ;
000026BA  4EB8 1E98 4293          jsr       _EnableBreakPoints
                    4294   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
000026BE  0255 7FFF 4295          and.w     #32767,(A5)
                    4296   ; printf("\r\nSingle Step  :[OFF]") ;
000026C2  4879 0000 4297          pea       @m68kde~2_125.L
000026C6  6D72      
000026C8  4E92      4298          jsr       (A2)
000026CA  584F      4299          addq.w    #4,A7
                    4300   ; printf("\r\nBreak Points :[Enabled]");
000026CC  4879 0000 4301          pea       @m68kde~2_123.L
000026D0  6D2E      
000026D2  4E92      4302          jsr       (A2)
000026D4  584F      4303          addq.w    #4,A7
                    4304   ; printf("\r\nProgram Running.....") ;
000026D6  4879 0000 4305          pea       @m68kde~2_116.L
000026DA  6C3A      
000026DC  4E92      4306          jsr       (A2)
000026DE  584F      4307          addq.w    #4,A7
                    4308   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
000026E0  4879 0000 4309          pea       @m68kde~2_117.L
000026E4  6C52      
000026E6  4E92      4310          jsr       (A2)
000026E8  584F      4311          addq.w    #4,A7
                    4312   ; return ;
000026EA  6014      4313          bra.s     menu_38
                    4314   menu_43:
                    4315   ; }
                    4316   ; else if( c == (char)('W'))              // Watchpoint command
000026EC  0C02 0057 4317          cmp.b     #87,D2
000026F0  6606      4318          bne.s     menu_45
                    4319   ; Watchpoint() ;
000026F2  4EB8 22F2 4320          jsr       _Watchpoint
000026F6  6004      4321          bra.s     menu_46
                    4322   menu_45:
                    4323   ; else
                    4324   ; UnknownCommand() ;
000026F8  4EB8 224A 4325          jsr       _UnknownCommand
                    4326   menu_46:
000026FC  6000 FDB0 4327          bra       menu_1
                    4328   menu_38:
00002700  4CDF 3C0C 4329          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00002704  4E75      4330          rts
                    4331   ; }
                    4332   ; }
                    4333   ; void PrintErrorMessageandAbort(char *string) {
                    4334   _PrintErrorMessageandAbort:
00002706  4E56 0000 4335          link      A6,#0
                    4336   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
0000270A  4879 0000 4337          pea       @m68kde~2_126.L
0000270E  6D88      
00002710  4EB9 0000 4338          jsr       _printf
00002714  551E      
00002716  584F      4339          addq.w    #4,A7
                    4340   ; printf("%s\r\n", string) ;
00002718  2F2E 0008 4341          move.l    8(A6),-(A7)
0000271C  4879 0000 4342          pea       @m68kde~2_127.L
00002720  6DA4      
00002722  4EB9 0000 4343          jsr       _printf
00002726  551E      
00002728  504F      4344          addq.w    #8,A7
                    4345   ; menu() ;
0000272A  4EB8 2492 4346          jsr       _menu
0000272E  4E5E      4347          unlk      A6
00002730  4E75      4348          rts
                    4349   ; }
                    4350   ; void IRQMessage(int level) {
                    4351   _IRQMessage:
00002732  4E56 0000 4352          link      A6,#0
                    4353   ; printf("\r\n\r\nProgram ABORT !!!!!");
00002736  4879 0000 4354          pea       @m68kde~2_128.L
0000273A  6DAA      
0000273C  4EB9 0000 4355          jsr       _printf
00002740  551E      
00002742  584F      4356          addq.w    #4,A7
                    4357   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
00002744  2F2E 0008 4358          move.l    8(A6),-(A7)
00002748  4879 0000 4359          pea       @m68kde~2_129.L
0000274C  6DC2      
0000274E  4EB9 0000 4360          jsr       _printf
00002752  551E      
00002754  504F      4361          addq.w    #8,A7
                    4362   ; menu() ;
00002756  4EB8 2492 4363          jsr       _menu
0000275A  4E5E      4364          unlk      A6
0000275C  4E75      4365          rts
                    4366   ; }
                    4367   ; void UnhandledIRQ1(void) {
                    4368   _UnhandledIRQ1:
                    4369   ; IRQMessage(1);
0000275E  4878 0001 4370          pea       1
00002762  4EB8 2732 4371          jsr       _IRQMessage
00002766  584F      4372          addq.w    #4,A7
00002768  4E75      4373          rts
                    4374   ; }
                    4375   ; void UnhandledIRQ2(void) {
                    4376   _UnhandledIRQ2:
                    4377   ; IRQMessage(2);
0000276A  4878 0002 4378          pea       2
0000276E  4EB8 2732 4379          jsr       _IRQMessage
00002772  584F      4380          addq.w    #4,A7
00002774  4E75      4381          rts
                    4382   ; }
                    4383   ; void UnhandledIRQ3(void){
                    4384   _UnhandledIRQ3:
                    4385   ; IRQMessage(3);
00002776  4878 0003 4386          pea       3
0000277A  4EB8 2732 4387          jsr       _IRQMessage
0000277E  584F      4388          addq.w    #4,A7
00002780  4E75      4389          rts
                    4390   ; }
                    4391   ; void UnhandledIRQ4(void) {
                    4392   _UnhandledIRQ4:
                    4393   ; IRQMessage(4);
00002782  4878 0004 4394          pea       4
00002786  4EB8 2732 4395          jsr       _IRQMessage
0000278A  584F      4396          addq.w    #4,A7
0000278C  4E75      4397          rts
                    4398   ; }
                    4399   ; void UnhandledIRQ5(void) {
                    4400   _UnhandledIRQ5:
                    4401   ; IRQMessage(5);
0000278E  4878 0005 4402          pea       5
00002792  4EB8 2732 4403          jsr       _IRQMessage
00002796  584F      4404          addq.w    #4,A7
00002798  4E75      4405          rts
                    4406   ; }
                    4407   ; void UnhandledIRQ6(void) {
                    4408   _UnhandledIRQ6:
                    4409   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
0000279A  4879 0000 4410          pea       @m68kde~2_130.L
0000279E  6DE6      
000027A0  4EB8 2706 4411          jsr       _PrintErrorMessageandAbort
000027A4  584F      4412          addq.w    #4,A7
                    4413   ; menu() ;
000027A6  4EB8 2492 4414          jsr       _menu
000027AA  4E75      4415          rts
                    4416   ; }
                    4417   ; void UnhandledIRQ7(void) {
                    4418   _UnhandledIRQ7:
                    4419   ; IRQMessage(7);
000027AC  4878 0007 4420          pea       7
000027B0  4EB8 2732 4421          jsr       _IRQMessage
000027B4  584F      4422          addq.w    #4,A7
000027B6  4E75      4423          rts
                    4424   ; }
                    4425   ; void UnhandledTrap(void) {
                    4426   _UnhandledTrap:
                    4427   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
000027B8  4879 0000 4428          pea       @m68kde~2_131.L
000027BC  6E26      
000027BE  4EB8 2706 4429          jsr       _PrintErrorMessageandAbort
000027C2  584F      4430          addq.w    #4,A7
000027C4  4E75      4431          rts
                    4432   ; }
                    4433   ; void BusError() {
                    4434   _BusError:
                    4435   ; PrintErrorMessageandAbort("BUS Error!") ;
000027C6  4879 0000 4436          pea       @m68kde~2_132.L
000027CA  6E3C      
000027CC  4EB8 2706 4437          jsr       _PrintErrorMessageandAbort
000027D0  584F      4438          addq.w    #4,A7
000027D2  4E75      4439          rts
                    4440   ; }
                    4441   ; void AddressError() {
                    4442   _AddressError:
                    4443   ; PrintErrorMessageandAbort("ADDRESS Error!") ;
000027D4  4879 0000 4444          pea       @m68kde~2_133.L
000027D8  6E48      
000027DA  4EB8 2706 4445          jsr       _PrintErrorMessageandAbort
000027DE  584F      4446          addq.w    #4,A7
000027E0  4E75      4447          rts
                    4448   ; }
                    4449   ; void IllegalInstruction() {
                    4450   _IllegalInstruction:
                    4451   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
000027E2  4879 0000 4452          pea       @m68kde~2_134.L
000027E6  6E58      
000027E8  4EB8 2706 4453          jsr       _PrintErrorMessageandAbort
000027EC  584F      4454          addq.w    #4,A7
000027EE  4E75      4455          rts
                    4456   ; }
                    4457   ; void Dividebyzero() {
                    4458   _Dividebyzero:
                    4459   ; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
000027F0  4879 0000 4460          pea       @m68kde~2_135.L
000027F4  6E6C      
000027F6  4EB8 2706 4461          jsr       _PrintErrorMessageandAbort
000027FA  584F      4462          addq.w    #4,A7
000027FC  4E75      4463          rts
                    4464   ; }
                    4465   ; void Check() {
                    4466   _Check:
                    4467   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
000027FE  4879 0000 4468          pea       @m68kde~2_136.L
00002802  6E7C      
00002804  4EB8 2706 4469          jsr       _PrintErrorMessageandAbort
00002808  584F      4470          addq.w    #4,A7
0000280A  4E75      4471          rts
                    4472   ; }
                    4473   ; void Trapv() {
                    4474   _Trapv:
                    4475   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
0000280C  4879 0000 4476          pea       @m68kde~2_137.L
00002810  6E8E      
00002812  4EB8 2706 4477          jsr       _PrintErrorMessageandAbort
00002816  584F      4478          addq.w    #4,A7
00002818  4E75      4479          rts
                    4480   ; }
                    4481   ; void PrivError() {
                    4482   _PrivError:
                    4483   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
0000281A  4879 0000 4484          pea       @m68kde~2_138.L
0000281E  6EA0      
00002820  4EB8 2706 4485          jsr       _PrintErrorMessageandAbort
00002824  584F      4486          addq.w    #4,A7
00002826  4E75      4487          rts
                    4488   ; }
                    4489   ; void UnitIRQ() {
                    4490   _UnitIRQ:
                    4491   ; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
00002828  4879 0000 4492          pea       @m68kde~2_139.L
0000282C  6EB4      
0000282E  4EB8 2706 4493          jsr       _PrintErrorMessageandAbort
00002832  584F      4494          addq.w    #4,A7
00002834  4E75      4495          rts
                    4496   ; }
                    4497   ; void Spurious() {
                    4498   _Spurious:
                    4499   ; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
00002836  4879 0000 4500          pea       @m68kde~2_140.L
0000283A  6EC6      
0000283C  4EB8 2706 4501          jsr       _PrintErrorMessageandAbort
00002840  584F      4502          addq.w    #4,A7
00002842  4E75      4503          rts
                    4504   ; }
                    4505   ; void EnterString(void)
                    4506   ; {
                    4507   _EnterString:
00002844  4E56 FFFC 4508          link      A6,#-4
00002848  2F02      4509          move.l    D2,-(A7)
                    4510   ; unsigned char *Start;
                    4511   ; unsigned char c;
                    4512   ; printf("\r\nStart Address in Memory: ") ;
0000284A  4879 0000 4513          pea       @m68kde~2_141.L
0000284E  6ED4      
00002850  4EB9 0000 4514          jsr       _printf
00002854  551E      
00002856  584F      4515          addq.w    #4,A7
                    4516   ; Start = Get8HexDigits(0) ;
00002858  42A7      4517          clr.l     -(A7)
0000285A  4EB8 0CA4 4518          jsr       _Get8HexDigits
0000285E  584F      4519          addq.w    #4,A7
00002860  2400      4520          move.l    D0,D2
                    4521   ; printf("\r\nEnter String (ESC to end) :") ;
00002862  4879 0000 4522          pea       @m68kde~2_142.L
00002866  6EF0      
00002868  4EB9 0000 4523          jsr       _printf
0000286C  551E      
0000286E  584F      4524          addq.w    #4,A7
                    4525   ; while((c = getchar()) != 0x1b)
                    4526   EnterString_1:
00002870  4EB9 0000 4527          jsr       _getch
00002874  5440      
00002876  1D40 FFFF 4528          move.b    D0,-1(A6)
0000287A  0C00 001B 4529          cmp.b     #27,D0
0000287E  670A      4530          beq.s     EnterString_3
                    4531   ; *Start++ = c ;
00002880  2042      4532          move.l    D2,A0
00002882  5282      4533          addq.l    #1,D2
00002884  10AE FFFF 4534          move.b    -1(A6),(A0)
00002888  60E6      4535          bra       EnterString_1
                    4536   EnterString_3:
                    4537   ; *Start = 0x00;  // terminate with a null
0000288A  2042      4538          move.l    D2,A0
0000288C  4210      4539          clr.b     (A0)
0000288E  241F      4540          move.l    (A7)+,D2
00002890  4E5E      4541          unlk      A6
00002892  4E75      4542          rts
                    4543   ; }
                    4544   ; void MemoryTest(void)
                    4545   ; {
                    4546   _MemoryTest:
00002894  4E75      4547          rts
                    4548   ; // unsigned char *BytePtr;
                    4549   ; // unsigned short int *WordPtr;
                    4550   ; // unsigned int *LongPtr;
                    4551   ; // unsigned int counter1=0x400 ; // counter 1 to 0x400 to print every 1000 times
                    4552   ; // register unsigned int i ;
                    4553   ; // unsigned int Start, End, dataSize, s_start, s_end, d_start, d_end ;
                    4554   ; // char c ; // for user input
                    4555   ; // unsigned long int pattern ; // pattern to write to memory
                    4556   ; // start:
                    4557   ; // printf("\r\nMemory Test") ;
                    4558   ; // while(1) {
                    4559   ; //     printf("\r\nEnter Testing Area") ;
                    4560   ; //     printf("\r\n (S) SRAM   (D) DRAM") ;
                    4561   ; //     printf("\r\n#") ;
                    4562   ; //     c = toupper(_getch()) ;
                    4563   ; //     if (c == 'S') {
                    4564   ; //         s_start = 0xf0000000 ;
                    4565   ; //         s_end = 0xf003ffff ;
                    4566   ; //         while(1) {
                    4567   ; //             printf("\r\nEnter Start Address  0xf0000000 - 0xf003ffff: ") ;
                    4568   ; //             Start = Get8HexDigits(0) ;
                    4569   ; //             if (Start < s_start || Start > s_end) {
                    4570   ; //                 printf("\r\nInvalid Start Address, please try again.") ; // if invalid address, print error message and continue
                    4571   ; //                 continue ;
                    4572   ; //             }
                    4573   ; //             printf("\r\nEnter End Address 0xf0000000 - 0xf003ffff: ") ;
                    4574   ; //             End = Get8HexDigits(0) ;
                    4575   ; //             if (End < s_start || End > s_end ) {
                    4576   ; //                 printf("\r\nInvalid End Address, please try again.") ;
                    4577   ; //                 continue ;
                    4578   ; //             }
                    4579   ; //             if (Start >= End) {
                    4580   ; //                 printf("\r\nInvalid Range, please try again.") ;
                    4581   ; //                 continue ;
                    4582   ; //             }
                    4583   ; //             break ;
                    4584   ; //         }
                    4585   ; //         break;
                    4586   ; //     }
                    4587   ; //     else if (c == 'D') {
                    4588   ; //         d_start = 0x08000000 ;
                    4589   ; //         d_end = 0x0bffffff ;
                    4590   ; //         while(1) {
                    4591   ; //             printf("\r\nEnter Start Address  0x08000000 - 0x0bffffff: ") ;
                    4592   ; //             Start = Get8HexDigits(0) ;
                    4593   ; //             if (Start < d_start || Start > d_end) {
                    4594   ; //                 printf("\r\nInvalid Start Address, please try again.") ; // if invalid address, print error message and continue
                    4595   ; //                 continue ;
                    4596   ; //             }
                    4597   ; //             printf("\r\nEnter End Address 0x08000000 - 0x0bffffff: ") ;
                    4598   ; //             End = Get8HexDigits(0) ;
                    4599   ; //             if (End < d_start || End > d_end ) {
                    4600   ; //                 printf("\r\nInvalid End Address, please try again.") ;
                    4601   ; //                 continue ;
                    4602   ; //             }
                    4603   ; //             if (Start >= End) {
                    4604   ; //                 printf("\r\nInvalid Range, please try again.") ;
                    4605   ; //                 continue ;
                    4606   ; //             }
                    4607   ; //             break ;
                    4608   ; //         }
                    4609   ; //         break ;
                    4610   ; //     }
                    4611   ; //     else {
                    4612   ; //         printf("\r\nInvalid input, please try again.") ;
                    4613   ; //     }
                    4614   ; // }
                    4615   ; // while(1) {
                    4616   ; //     printf("\r\nchoose pattern of test data: \r\n1: 55\r\n2: AA\r\n3: FF\r\n4: 00") ;
                    4617   ; //     printf("\r\n#") ;
                    4618   ; //     c = toupper(_getch()) ;
                    4619   ; //     if(c == '1') {
                    4620   ; //         pattern = 0x55 ;
                    4621   ; //         break ;
                    4622   ; //     }
                    4623   ; //     else if (c == '2') {
                    4624   ; //         pattern = 0xAA ;
                    4625   ; //         break ;
                    4626   ; //     }
                    4627   ; //     else if (c == '3') {
                    4628   ; //         pattern = 0xFF ;
                    4629   ; //         break ;
                    4630   ; //     }
                    4631   ; //     else if (c == '4') {
                    4632   ; //         pattern = 0x00 ;
                    4633   ; //         break ;
                    4634   ; //     }
                    4635   ; //     else {
                    4636   ; //         printf("\r\nInvalid input, please try again.") ;
                    4637   ; //     }
                    4638   ; // }
                    4639   ; // printf("\r\npattern selected: 0x%x", pattern) ;
                    4640   ; // while(1) {
                    4641   ; //     printf("\r\nEnter 'B', 'W', or 'L' for bytes, words, or long words: ") ; // choose data type
                    4642   ; //     printf("\r\n#") ;
                    4643   ; //     c = toupper(_getch()) ;
                    4644   ; //     if (c == 'B') {
                    4645   ; //         dataSize = 1 ;
                    4646   ; //         printf("\r\ndata type selected: Bytes") ; // print data type selected
                    4647   ; //         break ;
                    4648   ; //     }
                    4649   ; //     else if (c == 'W') {
                    4650   ; //         dataSize = 2 ;
                    4651   ; //         pattern = pattern | (pattern << 8) ;
                    4652   ; //         printf("\r\ndata type selected: Words") ; // extend pattern to 16 bits
                    4653   ; //         if (Start & 1 || End & 1) {
                    4654   ; //             printf("\r\nInvalid Start Address, must be even number, please try again.") ; // if address is odd, print error message and continue
                    4655   ; //             goto start ;
                    4656   ; //         }
                    4657   ; //         break ;
                    4658   ; //     }
                    4659   ; //     else if (c == 'L') {
                    4660   ; //         dataSize = 4 ;
                    4661   ; //         pattern = pattern | (pattern << 8)  ; // extend pattern to 32 bits
                    4662   ; //         pattern = pattern | (pattern << 16) ;
                    4663   ; //         printf("\r\ndata type selected: Long Words") ;
                    4664   ; //         if (Start & 1 || End & 1) {
                    4665   ; //             printf("\r\nInvalid Start Address, must be even number, please try again.") ; // if address is odd, print error message and continue
                    4666   ; //             goto start ;
                    4667   ; //         }
                    4668   ; //         if ((End - Start) / dataSize <= 0) {
                    4669   ; //             printf("\r\nInvalid Range, please start over.") ;
                    4670   ; //             goto start ;
                    4671   ; //         }
                    4672   ; //         break;
                    4673   ; //     }
                    4674   ; //     else {
                    4675   ; //         printf("\r\nInvalid input, please try again.") ;
                    4676   ; //     }
                    4677   ; // }
                    4678   ; // if (dataSize == 4) {
                    4679   ; //     LongPtr = (unsigned int *)Start ;
                    4680   ; // }
                    4681   ; // else if (dataSize == 2) {
                    4682   ; //     WordPtr = (unsigned short int *)Start ;
                    4683   ; // }
                    4684   ; // else {
                    4685   ; //     BytePtr = (unsigned char *)Start ;
                    4686   ; // }
                    4687   ; // while(1) {
                    4688   ; //     if (dataSize == 4) {
                    4689   ; //         if (LongPtr >= (unsigned int *)End) {
                    4690   ; //             printf("\r\nWrite Complete") ;
                    4691   ; //             break ;
                    4692   ; //         }
                    4693   ; //     }
                    4694   ; //     else if (dataSize == 2) {
                    4695   ; //         if (WordPtr >= (unsigned short int *)End) {
                    4696   ; //             printf("\r\nWrite Complete") ;
                    4697   ; //             break ;
                    4698   ; //         }
                    4699   ; //     }
                    4700   ; //     else {
                    4701   ; //         if (BytePtr >= (unsigned char *)End) {
                    4702   ; //             printf("\r\nWrite Complete") ;
                    4703   ; //             break ;
                    4704   ; //         }
                    4705   ; //     }
                    4706   ; //     if (dataSize == 4) {
                    4707   ; //         *LongPtr = pattern ;
                    4708   ; //     }
                    4709   ; //     else if (dataSize == 2) {
                    4710   ; //         *WordPtr = pattern ;
                    4711   ; //     }
                    4712   ; //     else {
                    4713   ; //         *BytePtr = pattern ;
                    4714   ; //     }
                    4715   ; //     counter1++;
                    4716   ; //     if (counter1 == 0x401){
                    4717   ; //         if (dataSize == 4) {
                    4718   ; //             printf("\r\nWrite: 0x%x from addr 0x%x", *LongPtr, LongPtr) ; // when counter reaches 0x400, print the value read from memory
                    4719   ; //             counter1 = 1 ;
                    4720   ; //         }
                    4721   ; //         else if (dataSize == 2) {
                    4722   ; //         printf("\r\nWrite: 0x%x from addr 0x%x", *WordPtr, WordPtr) ; // when counter reaches 0x400, print the value read from memory
                    4723   ; //         counter1 = 1 ;
                    4724   ; //         }
                    4725   ; //         else {
                    4726   ; //             printf("\r\nWrite: 0x%x from addr 0x%x", *BytePtr, BytePtr) ; // when counter reaches 0x400, print the value read from memory
                    4727   ; //             counter1 = 1 ;
                    4728   ; //         }
                    4729   ; //     }
                    4730   ; //     if (dataSize == 4) {
                    4731   ; //         LongPtr++ ;
                    4732   ; //     }
                    4733   ; //     else if (dataSize == 2) {
                    4734   ; //         WordPtr++ ;
                    4735   ; //     }
                    4736   ; //     else {
                    4737   ; //         BytePtr++ ;
                    4738   ; //     }
                    4739   ; // }
                    4740   ; // if (dataSize == 4) {
                    4741   ; //     LongPtr = (unsigned int *)Start ;
                    4742   ; // }
                    4743   ; // else if (dataSize == 2) {
                    4744   ; //     WordPtr = (unsigned short int *)Start ;
                    4745   ; // }
                    4746   ; // else {
                    4747   ; //     BytePtr = (unsigned char *)Start ;
                    4748   ; // }
                    4749   ; // counter1 = 0x400 ;
                    4750   ; // while(1) {
                    4751   ; //     if (dataSize == 4) {
                    4752   ; //         if (LongPtr >= (unsigned int *)End) {
                    4753   ; //             printf("\r\nRead Complete") ; // when counter reaches 0x400, print the value read from memory
                    4754   ; //             break ;
                    4755   ; //         }
                    4756   ; //     }
                    4757   ; //     else if (dataSize == 2) {
                    4758   ; //         if (WordPtr >= (unsigned short int *)End) {
                    4759   ; //             printf("\r\nRead Complete") ; // when counter reaches 0x400, print the value read from memory
                    4760   ; //             break ;
                    4761   ; //         }
                    4762   ; //     }
                    4763   ; //     else {
                    4764   ; //         if (BytePtr >= (unsigned char *)End) {
                    4765   ; //             printf("\r\nRead Complete") ; // when counter reaches 0x400, print the value read from memory
                    4766   ; //             break ;
                    4767   ; //         }
                    4768   ; //     }
                    4769   ; //     // Error checking
                    4770   ; //     if (dataSize == 4) {
                    4771   ; //         if (*LongPtr != pattern) {
                    4772   ; //             printf("\r\nError: 0x%x at addr 0x%x, should be 0x%x", *LongPtr, LongPtr, pattern) ; // if value read from memory is not the same as the value written, print error message
                    4773   ; //             break ;
                    4774   ; //         }
                    4775   ; //     }
                    4776   ; //     else if (dataSize == 2) {
                    4777   ; //         if (*WordPtr != pattern) {
                    4778   ; //             printf("\r\nError: 0x%x at addr 0x%x, should be 0x%x", *WordPtr, WordPtr, pattern) ; // if value read from memory is not the same as the value written, print error message
                    4779   ; //             break ;
                    4780   ; //         }
                    4781   ; //     }
                    4782   ; //     else {
                    4783   ; //         if (*BytePtr != pattern) {
                    4784   ; //             printf("\r\nError: 0x%x at addr 0x%x, should be 0x%x", *BytePtr, BytePtr, pattern) ; // if value read from memory is not the same as the value written, print error message
                    4785   ; //             break ;
                    4786   ; //         }
                    4787   ; //     }
                    4788   ; //     counter1++;
                    4789   ; //     if (counter1 == 0x401){
                    4790   ; //         if (dataSize == 4) {
                    4791   ; //             printf("\r\nRead: 0x%x from addr 0x%x", *LongPtr, LongPtr) ; // when counter reaches 0x400, print the value read from memory
                    4792   ; //             counter1 = 1 ;
                    4793   ; //         }
                    4794   ; //         else if (dataSize == 2) {
                    4795   ; //             printf("\r\nRead: 0x%x from addr 0x%x", *WordPtr, WordPtr) ; // when counter reaches 0x400, print the value read from memory
                    4796   ; //             counter1 = 1 ;
                    4797   ; //         }
                    4798   ; //         else {
                    4799   ; //             printf("\r\nRead: 0x%x from addr 0x%x", *BytePtr, BytePtr) ; // when counter reaches 0x400, print the value read from memory
                    4800   ; //             counter1 = 1 ;
                    4801   ; //         }
                    4802   ; //     }
                    4803   ; //     if (dataSize == 4) {
                    4804   ; //         LongPtr++ ;
                    4805   ; //     }
                    4806   ; //     else if (dataSize == 2) {
                    4807   ; //         WordPtr++ ;
                    4808   ; //     }
                    4809   ; //     else {
                    4810   ; //         BytePtr++ ;
                    4811   ; //     }
                    4812   ; // }
                    4813   ; }
                    4814   ; void main(void)
                    4815   ; {
                    4816   _main:
00002896  4E56 FFF4 4817          link      A6,#-12
0000289A  48E7 3030 4818          movem.l   D2/D3/A2/A3,-(A7)
0000289E  45F8 0A30 4819          lea       _InstallExceptionHandler.L,A2
000028A2  47F9 0000 4820          lea       _printf.L,A3
000028A6  551E      
                    4821   ; char c ;
                    4822   ; int i, j ;
                    4823   ; char *BugMessage = "CPEN 412 Assignment 4a";
000028A8  41F9 0000 4824          lea       @m68kde~2_143.L,A0
000028AC  6F0E      
000028AE  2608      4825          move.l    A0,D3
                    4826   ; char *CopyrightMessage = "Bob Bao 18981365";
000028B0  41F9 0000 4827          lea       @m68kde~2_144.L,A0
000028B4  6F26      
000028B6  2D48 FFFC 4828          move.l    A0,-4(A6)
                    4829   ; KillAllBreakPoints() ;
000028BA  4EB8 1EE0 4830          jsr       _KillAllBreakPoints
                    4831   ; i = x = y = z = PortA_Count = 0;
000028BE  42B9 0B00 4832          clr.l     _PortA_Count.L
000028C2  00D4      
000028C4  42B9 0B00 4833          clr.l     _z.L
000028C8  00D0      
000028CA  42B9 0B00 4834          clr.l     _y.L
000028CE  00CC      
000028D0  42B9 0B00 4835          clr.l     _x.L
000028D4  00C8      
000028D6  4282      4836          clr.l     D2
                    4837   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
000028D8  42B9 0B00 4838          clr.l     _GoFlag.L
000028DC  00DC      
000028DE  42B9 0B00 4839          clr.l     _Trace.L
000028E2  00D8      
                    4840   ; Echo = 1 ;
000028E4  23FC 0000 4841          move.l    #1,_Echo.L
000028E8  0001 0B00 
000028EC  00E0      
                    4842   ; d0=d1=d2=d3=d4=d5=d6=d7=0 ;
000028EE  42B9 0B00 4843          clr.l     _d7.L
000028F2  0100      
000028F4  42B9 0B00 4844          clr.l     _d6.L
000028F8  00FC      
000028FA  42B9 0B00 4845          clr.l     _d5.L
000028FE  00F8      
00002900  42B9 0B00 4846          clr.l     _d4.L
00002904  00F4      
00002906  42B9 0B00 4847          clr.l     _d3.L
0000290A  00F0      
0000290C  42B9 0B00 4848          clr.l     _d2.L
00002910  00EC      
00002912  42B9 0B00 4849          clr.l     _d1.L
00002916  00E8      
00002918  42B9 0B00 4850          clr.l     _d0.L
0000291C  00E4      
                    4851   ; a0=a1=a2=a3=a4=a5=a6=0 ;
0000291E  42B9 0B00 4852          clr.l     _a6.L
00002922  011C      
00002924  42B9 0B00 4853          clr.l     _a5.L
00002928  0118      
0000292A  42B9 0B00 4854          clr.l     _a4.L
0000292E  0114      
00002930  42B9 0B00 4855          clr.l     _a3.L
00002934  0110      
00002936  42B9 0B00 4856          clr.l     _a2.L
0000293A  010C      
0000293C  42B9 0B00 4857          clr.l     _a1.L
00002940  0108      
00002942  42B9 0B00 4858          clr.l     _a0.L
00002946  0104      
                    4859   ; PC = ProgramStart, SSP=TopOfStack, USP = TopOfStack;
00002948  23FC 0800 4860          move.l    #134217728,_PC.L
0000294C  0000 0B00 
00002950  0120      
00002952  23FC 0C00 4861          move.l    #201326592,_SSP.L
00002956  0000 0B00 
0000295A  0124      
0000295C  23FC 0C00 4862          move.l    #201326592,_USP.L
00002960  0000 0B00 
00002964  0128      
                    4863   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
00002966  33FC 2000 4864          move.w    #8192,_SR.L
0000296A  0B00 012C 
                    4865   ; // Initialise Breakpoint variables
                    4866   ; for(i = 0; i < 8; i++)  {
0000296E  4282      4867          clr.l     D2
                    4868   main_1:
00002970  0C82 0000 4869          cmp.l     #8,D2
00002974  0008      
00002976  6C00 004C 4870          bge       main_3
                    4871   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
0000297A  2002      4872          move.l    D2,D0
0000297C  E588      4873          lsl.l     #2,D0
0000297E  41F9 0B00 4874          lea       _BreakPointAddress.L,A0
00002982  012E      
00002984  42B0 0800 4875          clr.l     0(A0,D0.L)
                    4876   ; WatchPointAddress[i] = 0 ;
00002988  2002      4877          move.l    D2,D0
0000298A  E588      4878          lsl.l     #2,D0
0000298C  41F9 0B00 4879          lea       _WatchPointAddress.L,A0
00002990  0182      
00002992  42B0 0800 4880          clr.l     0(A0,D0.L)
                    4881   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
00002996  2002      4882          move.l    D2,D0
00002998  E388      4883          lsl.l     #1,D0
0000299A  41F9 0B00 4884          lea       _BreakPointInstruction.L,A0
0000299E  014E      
000029A0  4270 0800 4885          clr.w     0(A0,D0.L)
                    4886   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
000029A4  2002      4887          move.l    D2,D0
000029A6  E588      4888          lsl.l     #2,D0
000029A8  41F9 0B00 4889          lea       _BreakPointSetOrCleared.L,A0
000029AC  015E      
000029AE  42B0 0800 4890          clr.l     0(A0,D0.L)
                    4891   ; WatchPointSetOrCleared[i] = 0;
000029B2  2002      4892          move.l    D2,D0
000029B4  E588      4893          lsl.l     #2,D0
000029B6  41F9 0B00 4894          lea       _WatchPointSetOrCleared.L,A0
000029BA  01A2      
000029BC  42B0 0800 4895          clr.l     0(A0,D0.L)
000029C0  5282      4896          addq.l    #1,D2
000029C2  60AC      4897          bra       main_1
                    4898   main_3:
                    4899   ; }
                    4900   ; Init_RS232() ;     // initialise the RS232 port
000029C4  4EB8 0B12 4901          jsr       _Init_RS232
                    4902   ; Init_LCD() ;
000029C8  4EB8 095E 4903          jsr       _Init_LCD
                    4904   ; for( i = 32; i < 48; i++)
000029CC  7420      4905          moveq     #32,D2
                    4906   main_4:
000029CE  0C82 0000 4907          cmp.l     #48,D2
000029D2  0030      
000029D4  6C0E      4908          bge.s     main_6
                    4909   ; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
000029D6  2F02      4910          move.l    D2,-(A7)
000029D8  4878 27B8 4911          pea       _UnhandledTrap.L
000029DC  4E92      4912          jsr       (A2)
000029DE  504F      4913          addq.w    #8,A7
000029E0  5282      4914          addq.l    #1,D2
000029E2  60EA      4915          bra       main_4
                    4916   main_6:
                    4917   ; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
000029E4  4878 002F 4918          pea       47
000029E8  4878 2492 4919          pea       _menu.L
000029EC  4E92      4920          jsr       (A2)
000029EE  504F      4921          addq.w    #8,A7
                    4922   ; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
000029F0  4878 0019 4923          pea       25
000029F4  4878 275E 4924          pea       _UnhandledIRQ1.L
000029F8  4E92      4925          jsr       (A2)
000029FA  504F      4926          addq.w    #8,A7
                    4927   ; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
000029FC  4878 001A 4928          pea       26
00002A00  4878 276A 4929          pea       _UnhandledIRQ2.L
00002A04  4E92      4930          jsr       (A2)
00002A06  504F      4931          addq.w    #8,A7
                    4932   ; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
00002A08  4878 001B 4933          pea       27
00002A0C  4878 2776 4934          pea       _UnhandledIRQ3.L
00002A10  4E92      4935          jsr       (A2)
00002A12  504F      4936          addq.w    #8,A7
                    4937   ; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
00002A14  4878 001C 4938          pea       28
00002A18  4878 2782 4939          pea       _UnhandledIRQ4.L
00002A1C  4E92      4940          jsr       (A2)
00002A1E  504F      4941          addq.w    #8,A7
                    4942   ; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
00002A20  4878 001D 4943          pea       29
00002A24  4878 278E 4944          pea       _UnhandledIRQ5.L
00002A28  4E92      4945          jsr       (A2)
00002A2A  504F      4946          addq.w    #8,A7
                    4947   ; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
00002A2C  4878 001E 4948          pea       30
00002A30  4878 279A 4949          pea       _UnhandledIRQ6.L
00002A34  4E92      4950          jsr       (A2)
00002A36  504F      4951          addq.w    #8,A7
                    4952   ; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
00002A38  4878 001F 4953          pea       31
00002A3C  4878 27AC 4954          pea       _UnhandledIRQ7.L
00002A40  4E92      4955          jsr       (A2)
00002A42  504F      4956          addq.w    #8,A7
                    4957   ; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
00002A44  4878 002E 4958          pea       46
00002A48  4878 2184 4959          pea       _HandleBreakPoint.L
00002A4C  4E92      4960          jsr       (A2)
00002A4E  504F      4961          addq.w    #8,A7
                    4962   ; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
00002A50  4878 001D 4963          pea       29
00002A54  4878 1828 4964          pea       _DumpRegistersandPause.L
00002A58  4E92      4965          jsr       (A2)
00002A5A  504F      4966          addq.w    #8,A7
                    4967   ; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
00002A5C  4878 0002 4968          pea       2
00002A60  4878 27C6 4969          pea       _BusError.L
00002A64  4E92      4970          jsr       (A2)
00002A66  504F      4971          addq.w    #8,A7
                    4972   ; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
00002A68  4878 0003 4973          pea       3
00002A6C  4878 27D4 4974          pea       _AddressError.L
00002A70  4E92      4975          jsr       (A2)
00002A72  504F      4976          addq.w    #8,A7
                    4977   ; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
00002A74  4878 0004 4978          pea       4
00002A78  4878 27E2 4979          pea       _IllegalInstruction.L
00002A7C  4E92      4980          jsr       (A2)
00002A7E  504F      4981          addq.w    #8,A7
                    4982   ; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
00002A80  4878 0005 4983          pea       5
00002A84  4878 27F0 4984          pea       _Dividebyzero.L
00002A88  4E92      4985          jsr       (A2)
00002A8A  504F      4986          addq.w    #8,A7
                    4987   ; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
00002A8C  4878 0006 4988          pea       6
00002A90  4878 27FE 4989          pea       _Check.L
00002A94  4E92      4990          jsr       (A2)
00002A96  504F      4991          addq.w    #8,A7
                    4992   ; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
00002A98  4878 0007 4993          pea       7
00002A9C  4878 280C 4994          pea       _Trapv.L
00002AA0  4E92      4995          jsr       (A2)
00002AA2  504F      4996          addq.w    #8,A7
                    4997   ; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
00002AA4  4878 0008 4998          pea       8
00002AA8  4878 281A 4999          pea       _PrivError.L
00002AAC  4E92      5000          jsr       (A2)
00002AAE  504F      5001          addq.w    #8,A7
                    5002   ; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
00002AB0  4878 000F 5003          pea       15
00002AB4  4878 2828 5004          pea       _UnitIRQ.L
00002AB8  4E92      5005          jsr       (A2)
00002ABA  504F      5006          addq.w    #8,A7
                    5007   ; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
00002ABC  4878 0018 5008          pea       24
00002AC0  4878 27FE 5009          pea       _Check.L
00002AC4  4E92      5010          jsr       (A2)
00002AC6  504F      5011          addq.w    #8,A7
                    5012   ; FlushKeyboard() ;                        // dump unread characters from keyboard
00002AC8  4EB8 0BA6 5013          jsr       _FlushKeyboard
                    5014   ; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
00002ACC  4239 0040 5015          clr.b     4194314
00002AD0  000A      
                    5016   ; // SPI_Init();
                    5017   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    5018   ; while(((char)(PortB & 0x02)) == (char)(0x02))    {
                    5019   main_7:
00002AD2  1039 0040 5020          move.b    4194306,D0
00002AD6  0002      
00002AD8  C03C 0002 5021          and.b     #2,D0
00002ADC  0C00 0002 5022          cmp.b     #2,D0
00002AE0  662A      5023          bne.s     main_9
                    5024   ; LoadFromFlashChip();
00002AE2  4EB8 12DA 5025          jsr       _LoadFromFlashChip
                    5026   ; printf("\r\nRunning.....") ;
00002AE6  4879 0000 5027          pea       @m68kde~2_145.L
00002AEA  6F38      
00002AEC  4E93      5028          jsr       (A3)
00002AEE  584F      5029          addq.w    #4,A7
                    5030   ; Oline1("Running.....") ;
00002AF0  4879 0000 5031          pea       @m68kde~2_146.L
00002AF4  6F48      
00002AF6  4EB8 0A02 5032          jsr       _Oline1
00002AFA  584F      5033          addq.w    #4,A7
                    5034   ; GoFlag = 1;
00002AFC  23FC 0000 5035          move.l    #1,_GoFlag.L
00002B00  0001 0B00 
00002B04  00DC      
                    5036   ; go() ;
00002B06  4EB8 08B8 5037          jsr       _go
00002B0A  60C6      5038          bra       main_7
                    5039   main_9:
                    5040   ; }
                    5041   ; // otherwise start the debug monitor
                    5042   ; Oline0(BugMessage) ;
00002B0C  2F03      5043          move.l    D3,-(A7)
00002B0E  4EB8 09D4 5044          jsr       _Oline0
00002B12  584F      5045          addq.w    #4,A7
                    5046   ; Oline1("By: PJ Davies") ;
00002B14  4879 0000 5047          pea       @m68kde~2_147.L
00002B18  6F56      
00002B1A  4EB8 0A02 5048          jsr       _Oline1
00002B1E  584F      5049          addq.w    #4,A7
                    5050   ; printf("\r\n%s", BugMessage) ;
00002B20  2F03      5051          move.l    D3,-(A7)
00002B22  4879 0000 5052          pea       @m68kde~2_148.L
00002B26  6F64      
00002B28  4E93      5053          jsr       (A3)
00002B2A  504F      5054          addq.w    #8,A7
                    5055   ; printf("\r\n%s", CopyrightMessage) ;
00002B2C  2F2E FFFC 5056          move.l    -4(A6),-(A7)
00002B30  4879 0000 5057          pea       @m68kde~2_148.L
00002B34  6F64      
00002B36  4E93      5058          jsr       (A3)
00002B38  504F      5059          addq.w    #8,A7
                    5060   ; menu();
00002B3A  4EB8 2492 5061          jsr       _menu
00002B3E  4CDF 0C0C 5062          movem.l   (A7)+,D2/D3/A2/A3
00002B42  4E5E      5063          unlk      A6
00002B44  4E75      5064          rts
                    5065   ; }
                    5066   ; void FormatInstruction(void)    // for disassembly
                    5067   ; {
                    5068   _FormatInstruction:
00002B46  4E56 FEC0 5069          link      A6,#-320
00002B4A  48E7 3C20 5070          movem.l   D2/D3/D4/D5/A2,-(A7)
00002B4E  45EE FEC0 5071          lea       -320(A6),A2
                    5072   ; short i, ilen = 0 ;
00002B52  4245      5073          clr.w     D5
                    5074   ; char *iptr = Instruction ;
00002B54  41F9 0B00 5075          lea       _Instruction.L,A0
00002B58  04E2      
00002B5A  2608      5076          move.l    A0,D3
                    5077   ; char *Formatted[80], *fptr ;
                    5078   ; fptr = Formatted ;
00002B5C  280A      5079          move.l    A2,D4
                    5080   ; for(i = 0; i < (short)(80); i ++)
00002B5E  4242      5081          clr.w     D2
                    5082   FormatInstruction_1:
00002B60  0C42 0050 5083          cmp.w     #80,D2
00002B64  6C0E      5084          bge.s     FormatInstruction_3
                    5085   ; Formatted[i] = (char)(0);          // set formatted string to null
00002B66  48C2      5086          ext.l     D2
00002B68  2002      5087          move.l    D2,D0
00002B6A  E588      5088          lsl.l     #2,D0
00002B6C  42B2 0800 5089          clr.l     0(A2,D0.L)
00002B70  5242      5090          addq.w    #1,D2
00002B72  60EC      5091          bra       FormatInstruction_1
                    5092   FormatInstruction_3:
                    5093   ; while((*iptr != ' '))   {   // while ot a space char
                    5094   FormatInstruction_4:
00002B74  2043      5095          move.l    D3,A0
00002B76  1010      5096          move.b    (A0),D0
00002B78  0C00 0020 5097          cmp.b     #32,D0
00002B7C  6718      5098          beq.s     FormatInstruction_6
                    5099   ; *fptr++ = *iptr++ ;     // copy string until space or end encountered
00002B7E  2043      5100          move.l    D3,A0
00002B80  5283      5101          addq.l    #1,D3
00002B82  2244      5102          move.l    D4,A1
00002B84  5284      5103          addq.l    #1,D4
00002B86  1290      5104          move.b    (A0),(A1)
                    5105   ; ilen ++ ;               // count length of string as we go
00002B88  5245      5106          addq.w    #1,D5
                    5107   ; if(*iptr == 0)          // if we got the end and copied the NUL then return
00002B8A  2043      5108          move.l    D3,A0
00002B8C  1010      5109          move.b    (A0),D0
00002B8E  6604      5110          bne.s     FormatInstruction_7
                    5111   ; return ;
00002B90  6000 003E 5112          bra       FormatInstruction_9
                    5113   FormatInstruction_7:
00002B94  60DE      5114          bra       FormatInstruction_4
                    5115   FormatInstruction_6:
                    5116   ; }
                    5117   ; // must still be more text to process otherwise we would have returned above if got to the end
                    5118   ; for(i = 0; i < ((short)(8) - ilen); i++)
00002B96  4242      5119          clr.w     D2
                    5120   FormatInstruction_10:
00002B98  7008      5121          moveq     #8,D0
00002B9A  4880      5122          ext.w     D0
00002B9C  9045      5123          sub.w     D5,D0
00002B9E  B440      5124          cmp.w     D0,D2
00002BA0  6C0C      5125          bge.s     FormatInstruction_12
                    5126   ; *fptr++ = ' ' ;        // make sure first operand appears in field 8 of formatted string
00002BA2  2044      5127          move.l    D4,A0
00002BA4  5284      5128          addq.l    #1,D4
00002BA6  10BC 0020 5129          move.b    #32,(A0)
00002BAA  5242      5130          addq.w    #1,D2
00002BAC  60EA      5131          bra       FormatInstruction_10
                    5132   FormatInstruction_12:
                    5133   ; // now skip over any spaces in original unformatted string before copying the rest
                    5134   ; while((*iptr == ' '))
                    5135   FormatInstruction_13:
00002BAE  2043      5136          move.l    D3,A0
00002BB0  1010      5137          move.b    (A0),D0
00002BB2  0C00 0020 5138          cmp.b     #32,D0
00002BB6  6604      5139          bne.s     FormatInstruction_15
                    5140   ; iptr++ ;
00002BB8  5283      5141          addq.l    #1,D3
00002BBA  60F2      5142          bra       FormatInstruction_13
                    5143   FormatInstruction_15:
                    5144   ; strcat(fptr,iptr) ;
00002BBC  2F03      5145          move.l    D3,-(A7)
00002BBE  2F04      5146          move.l    D4,-(A7)
00002BC0  4EB9 0000 5147          jsr       _strcat
00002BC4  54DC      
00002BC6  504F      5148          addq.w    #8,A7
                    5149   ; strcpyInstruction(Formatted) ;
00002BC8  2F0A      5150          move.l    A2,-(A7)
00002BCA  4EB8 0CE6 5151          jsr       _strcpyInstruction
00002BCE  584F      5152          addq.w    #4,A7
                    5153   FormatInstruction_9:
00002BD0  4CDF 043C 5154          movem.l   (A7)+,D2/D3/D4/D5/A2
00002BD4  4E5E      5155          unlk      A6
00002BD6  4E75      5156          rts
                    5157   ; }
                    5158   ; unsigned short int Decode2BitOperandSize(unsigned short int OpCode)
                    5159   ; {
                    5160   _Decode2BitOperandSize:
00002BD8  4E56 0000 5161          link      A6,#0
00002BDC  48E7 3020 5162          movem.l   D2/D3/A2,-(A7)
00002BE0  362E 000A 5163          move.w    10(A6),D3
00002BE4  C6BC 0000 5164          and.l     #65535,D3
00002BE8  FFFF      
00002BEA  45F8 0CCC 5165          lea       _strcatInstruction.L,A2
                    5166   ; unsigned short int DataSize ;       // used to determine the size of data following say an immediate instruction such as addi etc
                    5167   ; OpCode = (OpCode & (unsigned short int)(0x00C0)) >> 6 ;             // get bits 7 and 6 into positions 1,0
00002BEE  3003      5168          move.w    D3,D0
00002BF0  C07C 00C0 5169          and.w     #192,D0
00002BF4  EC48      5170          lsr.w     #6,D0
00002BF6  3600      5171          move.w    D0,D3
                    5172   ; if(OpCode == (unsigned short int)(0))   {
00002BF8  4A43      5173          tst.w     D3
00002BFA  660E      5174          bne.s     Decode2BitOperandSize_1
                    5175   ; strcatInstruction(".B ") ;
00002BFC  4879 0000 5176          pea       @m68kde~2_149.L
00002C00  6F6A      
00002C02  4E92      5177          jsr       (A2)
00002C04  584F      5178          addq.w    #4,A7
                    5179   ; DataSize = 1 ;
00002C06  7401      5180          moveq     #1,D2
00002C08  6020      5181          bra.s     Decode2BitOperandSize_4
                    5182   Decode2BitOperandSize_1:
                    5183   ; }
                    5184   ; else if(OpCode == (unsigned short int)(1)) {
00002C0A  0C43 0001 5185          cmp.w     #1,D3
00002C0E  660E      5186          bne.s     Decode2BitOperandSize_3
                    5187   ; strcatInstruction(".W ") ;
00002C10  4879 0000 5188          pea       @m68kde~2_150.L
00002C14  6F6E      
00002C16  4E92      5189          jsr       (A2)
00002C18  584F      5190          addq.w    #4,A7
                    5191   ; DataSize = 1 ;
00002C1A  7401      5192          moveq     #1,D2
00002C1C  600C      5193          bra.s     Decode2BitOperandSize_4
                    5194   Decode2BitOperandSize_3:
                    5195   ; }
                    5196   ; else {
                    5197   ; strcatInstruction(".L ") ;
00002C1E  4879 0000 5198          pea       @m68kde~2_151.L
00002C22  6F72      
00002C24  4E92      5199          jsr       (A2)
00002C26  584F      5200          addq.w    #4,A7
                    5201   ; DataSize = 2 ;
00002C28  7402      5202          moveq     #2,D2
                    5203   Decode2BitOperandSize_4:
                    5204   ; }
                    5205   ; return DataSize;
00002C2A  3002      5206          move.w    D2,D0
00002C2C  4CDF 040C 5207          movem.l   (A7)+,D2/D3/A2
00002C30  4E5E      5208          unlk      A6
00002C32  4E75      5209          rts
                    5210   ; }
                    5211   ; void Decode3BitDataRegister(unsigned short int OpCode)                // Data Register in Bits 11, 10 and 9
                    5212   ; {
                    5213   _Decode3BitDataRegister:
00002C34  4E56 FFFC 5214          link      A6,#-4
00002C38  2F0A      5215          move.l    A2,-(A7)
00002C3A  45EE FFFC 5216          lea       -4(A6),A2
                    5217   ; unsigned char RegNumber[3] ;
                    5218   ; RegNumber[0] = 'D' ;
00002C3E  14BC 0044 5219          move.b    #68,(A2)
                    5220   ; RegNumber[1] = (unsigned char)(0x30) + (unsigned char)((OpCode & 0x0E00) >> 9) ;   // get data register number in bits 2,1,0 and convert to ASCII equiv
00002C42  7030      5221          moveq     #48,D0
00002C44  322E 000A 5222          move.w    10(A6),D1
00002C48  C27C 0E00 5223          and.w     #3584,D1
00002C4C  E049      5224          lsr.w     #8,D1
00002C4E  E249      5225          lsr.w     #1,D1
00002C50  D001      5226          add.b     D1,D0
00002C52  1540 0001 5227          move.b    D0,1(A2)
                    5228   ; RegNumber[2] = 0 ;
00002C56  422A 0002 5229          clr.b     2(A2)
                    5230   ; strcatInstruction(RegNumber) ;        // write register number to the disassembled instruction
00002C5A  2F0A      5231          move.l    A2,-(A7)
00002C5C  4EB8 0CCC 5232          jsr       _strcatInstruction
00002C60  584F      5233          addq.w    #4,A7
00002C62  245F      5234          move.l    (A7)+,A2
00002C64  4E5E      5235          unlk      A6
00002C66  4E75      5236          rts
                    5237   ; }
                    5238   ; void Decode3BitAddressRegister(unsigned short int Reg)                // Address Register in Bits 2,1,0
                    5239   ; {
                    5240   _Decode3BitAddressRegister:
00002C68  4E56 FFFC 5241          link      A6,#-4
00002C6C  2F0A      5242          move.l    A2,-(A7)
00002C6E  45EE FFFC 5243          lea       -4(A6),A2
                    5244   ; unsigned char RegNumber[3];
                    5245   ; RegNumber[0] = 'A' ;
00002C72  14BC 0041 5246          move.b    #65,(A2)
                    5247   ; RegNumber[1] = (unsigned char)(0x30) + (unsigned char)(Reg) ;   // get data register number in bits 2,1,0 and convert to ASCII equiv
00002C76  7030      5248          moveq     #48,D0
00002C78  322E 000A 5249          move.w    10(A6),D1
00002C7C  D001      5250          add.b     D1,D0
00002C7E  1540 0001 5251          move.b    D0,1(A2)
                    5252   ; RegNumber[2] = 0 ;
00002C82  422A 0002 5253          clr.b     2(A2)
                    5254   ; strcatInstruction(RegNumber) ;        // write register number to the disassembled instruction
00002C86  2F0A      5255          move.l    A2,-(A7)
00002C88  4EB8 0CCC 5256          jsr       _strcatInstruction
00002C8C  584F      5257          addq.w    #4,A7
00002C8E  245F      5258          move.l    (A7)+,A2
00002C90  4E5E      5259          unlk      A6
00002C92  4E75      5260          rts
                    5261   ; }
                    5262   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5263   ; // Special function is used to print 8,16, 32 bit operands after move #
                    5264   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5265   ; void DecodeBWLDataAfterOpCodeForMove(unsigned short int *OpCode )
                    5266   ; {
                    5267   _DecodeBWLDataAfterOpCodeForMove:
00002C94  4E56 0000 5268          link      A6,#0
00002C98  48E7 3030 5269          movem.l   D2/D3/A2/A3,-(A7)
00002C9C  242E 0008 5270          move.l    8(A6),D2
00002CA0  45F9 0B00 5271          lea       _TempString.L,A2
00002CA4  0546      
00002CA6  47F9 0000 5272          lea       _sprintf.L,A3
00002CAA  54A8      
                    5273   ; unsigned char OperandSize ;
                    5274   ; OperandSize = (*OpCode >> 12) & (unsigned short int)(0x0003) ;               // get bits 13,12 into 1,0 as these define size of #operand
00002CAC  2042      5275          move.l    D2,A0
00002CAE  3010      5276          move.w    (A0),D0
00002CB0  E048      5277          lsr.w     #8,D0
00002CB2  E848      5278          lsr.w     #4,D0
00002CB4  C07C 0003 5279          and.w     #3,D0
00002CB8  1600      5280          move.b    D0,D3
                    5281   ; InstructionSize += 1;
00002CBA  52B9 0B00 5282          addq.l    #1,_InstructionSize.L
00002CBE  017E      
                    5283   ; if(OperandSize == (char)(1))                // #byte value
00002CC0  0C03 0001 5284          cmp.b     #1,D3
00002CC4  6620      5285          bne.s     DecodeBWLDataAfterOpCodeForMove_1
                    5286   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
00002CC6  2042      5287          move.l    D2,A0
00002CC8  3228 0002 5288          move.w    2(A0),D1
00002CCC  C2BC 0000 5289          and.l     #65535,D1
00002CD0  FFFF      
00002CD2  2F01      5290          move.l    D1,-(A7)
00002CD4  4879 0000 5291          pea       @m68kde~2_152.L
00002CD8  6F76      
00002CDA  2F0A      5292          move.l    A2,-(A7)
00002CDC  4E93      5293          jsr       (A3)
00002CDE  DEFC 000C 5294          add.w     #12,A7
00002CE2  6000 0068 5295          bra       DecodeBWLDataAfterOpCodeForMove_5
                    5296   DecodeBWLDataAfterOpCodeForMove_1:
                    5297   ; else if(OperandSize == (char)(3))          // #word value
00002CE6  0C03 0003 5298          cmp.b     #3,D3
00002CEA  6620      5299          bne.s     DecodeBWLDataAfterOpCodeForMove_3
                    5300   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
00002CEC  2042      5301          move.l    D2,A0
00002CEE  3228 0002 5302          move.w    2(A0),D1
00002CF2  C2BC 0000 5303          and.l     #65535,D1
00002CF6  FFFF      
00002CF8  2F01      5304          move.l    D1,-(A7)
00002CFA  4879 0000 5305          pea       @m68kde~2_152.L
00002CFE  6F76      
00002D00  2F0A      5306          move.l    A2,-(A7)
00002D02  4E93      5307          jsr       (A3)
00002D04  DEFC 000C 5308          add.w     #12,A7
00002D08  6000 0042 5309          bra       DecodeBWLDataAfterOpCodeForMove_5
                    5310   DecodeBWLDataAfterOpCodeForMove_3:
                    5311   ; else if(OperandSize == (char)(2)) {                                       // long value
00002D0C  0C03 0002 5312          cmp.b     #2,D3
00002D10  6600 003A 5313          bne       DecodeBWLDataAfterOpCodeForMove_5
                    5314   ; sprintf(TempString, "#$%X", ((unsigned int)(OpCode[1]) << 16) | (unsigned int)(OpCode[2])); // create 3
00002D14  2042      5315          move.l    D2,A0
00002D16  3228 0002 5316          move.w    2(A0),D1
00002D1A  C2BC 0000 5317          and.l     #65535,D1
00002D1E  FFFF      
00002D20  E189      5318          lsl.l     #8,D1
00002D22  E189      5319          lsl.l     #8,D1
00002D24  2042      5320          move.l    D2,A0
00002D26  2F00      5321          move.l    D0,-(A7)
00002D28  3028 0004 5322          move.w    4(A0),D0
00002D2C  C0BC 0000 5323          and.l     #65535,D0
00002D30  FFFF      
00002D32  8280      5324          or.l      D0,D1
00002D34  201F      5325          move.l    (A7)+,D0
00002D36  2F01      5326          move.l    D1,-(A7)
00002D38  4879 0000 5327          pea       @m68kde~2_152.L
00002D3C  6F76      
00002D3E  2F0A      5328          move.l    A2,-(A7)
00002D40  4E93      5329          jsr       (A3)
00002D42  DEFC 000C 5330          add.w     #12,A7
                    5331   ; InstructionSize += 1;
00002D46  52B9 0B00 5332          addq.l    #1,_InstructionSize.L
00002D4A  017E      
                    5333   DecodeBWLDataAfterOpCodeForMove_5:
                    5334   ; }
                    5335   ; strcatInstruction(TempString) ;
00002D4C  2F0A      5336          move.l    A2,-(A7)
00002D4E  4EB8 0CCC 5337          jsr       _strcatInstruction
00002D52  584F      5338          addq.w    #4,A7
00002D54  4CDF 0C0C 5339          movem.l   (A7)+,D2/D3/A2/A3
00002D58  4E5E      5340          unlk      A6
00002D5A  4E75      5341          rts
                    5342   ; }
                    5343   ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5344   ; // This function is used to print 8,16, 32 bit operands after the opcode, this is in instruction like ADD # where immediate addressing is used as source
                    5345   ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5346   ; void DecodeBWLDataAfterOpCode(unsigned short int *OpCode )
                    5347   ; {
                    5348   _DecodeBWLDataAfterOpCode:
00002D5C  4E56 0000 5349          link      A6,#0
00002D60  48E7 3038 5350          movem.l   D2/D3/A2/A3/A4,-(A7)
00002D64  262E 0008 5351          move.l    8(A6),D3
00002D68  45F9 0B00 5352          lea       _TempString.L,A2
00002D6C  0546      
00002D6E  47F9 0000 5353          lea       _sprintf.L,A3
00002D72  54A8      
00002D74  49F9 0B00 5354          lea       _InstructionSize.L,A4
00002D78  017E      
                    5355   ; unsigned char OperandSize ;
                    5356   ; OperandSize = (*OpCode & (unsigned short int)(0x01C0)) >> 6 ;               // get bits 8,7 and 6 into positions 1,0, these define size of operand
00002D7A  2043      5357          move.l    D3,A0
00002D7C  3010      5358          move.w    (A0),D0
00002D7E  C07C 01C0 5359          and.w     #448,D0
00002D82  EC48      5360          lsr.w     #6,D0
00002D84  1400      5361          move.b    D0,D2
                    5362   ; InstructionSize += 1;
00002D86  5294      5363          addq.l    #1,(A4)
                    5364   ; if((OperandSize == (char)(0)) || (OperandSize == (char)(4)))                // #byte value
00002D88  4A02      5365          tst.b     D2
00002D8A  6706      5366          beq.s     DecodeBWLDataAfterOpCode_3
00002D8C  0C02 0004 5367          cmp.b     #4,D2
00002D90  6620      5368          bne.s     DecodeBWLDataAfterOpCode_1
                    5369   DecodeBWLDataAfterOpCode_3:
                    5370   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
00002D92  2043      5371          move.l    D3,A0
00002D94  3228 0002 5372          move.w    2(A0),D1
00002D98  C2BC 0000 5373          and.l     #65535,D1
00002D9C  FFFF      
00002D9E  2F01      5374          move.l    D1,-(A7)
00002DA0  4879 0000 5375          pea       @m68kde~2_152.L
00002DA4  6F76      
00002DA6  2F0A      5376          move.l    A2,-(A7)
00002DA8  4E93      5377          jsr       (A3)
00002DAA  DEFC 000C 5378          add.w     #12,A7
00002DAE  6000 007C 5379          bra       DecodeBWLDataAfterOpCode_7
                    5380   DecodeBWLDataAfterOpCode_1:
                    5381   ; // #word value 7 is used by divs.w instruction (not divu)
                    5382   ; // however used by instructions like adda, cmpa, suba # to mean long value -
                    5383   ; // bugger - have to build a special case and look at opcode to see what instruction is
                    5384   ; else if((OperandSize == (char)(1)) || (OperandSize == (char)(5)) || (OperandSize == (char)(3)))         //# byte or word value
00002DB2  0C02 0001 5385          cmp.b     #1,D2
00002DB6  670C      5386          beq.s     DecodeBWLDataAfterOpCode_6
00002DB8  0C02 0005 5387          cmp.b     #5,D2
00002DBC  6706      5388          beq.s     DecodeBWLDataAfterOpCode_6
00002DBE  0C02 0003 5389          cmp.b     #3,D2
00002DC2  6620      5390          bne.s     DecodeBWLDataAfterOpCode_4
                    5391   DecodeBWLDataAfterOpCode_6:
                    5392   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
00002DC4  2043      5393          move.l    D3,A0
00002DC6  3228 0002 5394          move.w    2(A0),D1
00002DCA  C2BC 0000 5395          and.l     #65535,D1
00002DCE  FFFF      
00002DD0  2F01      5396          move.l    D1,-(A7)
00002DD2  4879 0000 5397          pea       @m68kde~2_152.L
00002DD6  6F76      
00002DD8  2F0A      5398          move.l    A2,-(A7)
00002DDA  4E93      5399          jsr       (A3)
00002DDC  DEFC 000C 5400          add.w     #12,A7
00002DE0  6000 004A 5401          bra       DecodeBWLDataAfterOpCode_7
                    5402   DecodeBWLDataAfterOpCode_4:
                    5403   ; else if((OperandSize == (char)(2))  || (OperandSize == (char)(6)) || (OperandSize == (char)(7)))    {    //# long value
00002DE4  0C02 0002 5404          cmp.b     #2,D2
00002DE8  670E      5405          beq.s     DecodeBWLDataAfterOpCode_9
00002DEA  0C02 0006 5406          cmp.b     #6,D2
00002DEE  6708      5407          beq.s     DecodeBWLDataAfterOpCode_9
00002DF0  0C02 0007 5408          cmp.b     #7,D2
00002DF4  6600 0036 5409          bne       DecodeBWLDataAfterOpCode_7
                    5410   DecodeBWLDataAfterOpCode_9:
                    5411   ; sprintf(TempString, "#$%X", ((unsigned int)(OpCode[1]) << 16) | (unsigned int)(OpCode[2]) ); // create 3
00002DF8  2043      5412          move.l    D3,A0
00002DFA  3228 0002 5413          move.w    2(A0),D1
00002DFE  C2BC 0000 5414          and.l     #65535,D1
00002E02  FFFF      
00002E04  E189      5415          lsl.l     #8,D1
00002E06  E189      5416          lsl.l     #8,D1
00002E08  2043      5417          move.l    D3,A0
00002E0A  2F00      5418          move.l    D0,-(A7)
00002E0C  3028 0004 5419          move.w    4(A0),D0
00002E10  C0BC 0000 5420          and.l     #65535,D0
00002E14  FFFF      
00002E16  8280      5421          or.l      D0,D1
00002E18  201F      5422          move.l    (A7)+,D0
00002E1A  2F01      5423          move.l    D1,-(A7)
00002E1C  4879 0000 5424          pea       @m68kde~2_152.L
00002E20  6F76      
00002E22  2F0A      5425          move.l    A2,-(A7)
00002E24  4E93      5426          jsr       (A3)
00002E26  DEFC 000C 5427          add.w     #12,A7
                    5428   ; InstructionSize += 1;
00002E2A  5294      5429          addq.l    #1,(A4)
                    5430   DecodeBWLDataAfterOpCode_7:
                    5431   ; }
                    5432   ; // special case for divs - bugger!!!
                    5433   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0x81C0)) // it's the divs instruction
00002E2C  2043      5434          move.l    D3,A0
00002E2E  3010      5435          move.w    (A0),D0
00002E30  C07C F1C0 5436          and.w     #61888,D0
00002E34  0C40 81C0 5437          cmp.w     #33216,D0
00002E38  6622      5438          bne.s     DecodeBWLDataAfterOpCode_10
                    5439   ; {
                    5440   ; InstructionSize = 2 ;
00002E3A  28BC 0000 5441          move.l    #2,(A4)
00002E3E  0002      
                    5442   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
00002E40  2043      5443          move.l    D3,A0
00002E42  3228 0002 5444          move.w    2(A0),D1
00002E46  C2BC 0000 5445          and.l     #65535,D1
00002E4A  FFFF      
00002E4C  2F01      5446          move.l    D1,-(A7)
00002E4E  4879 0000 5447          pea       @m68kde~2_152.L
00002E52  6F76      
00002E54  2F0A      5448          move.l    A2,-(A7)
00002E56  4E93      5449          jsr       (A3)
00002E58  DEFC 000C 5450          add.w     #12,A7
                    5451   DecodeBWLDataAfterOpCode_10:
                    5452   ; }
                    5453   ; strcatInstruction(TempString) ;
00002E5C  2F0A      5454          move.l    A2,-(A7)
00002E5E  4EB8 0CCC 5455          jsr       _strcatInstruction
00002E62  584F      5456          addq.w    #4,A7
00002E64  4CDF 1C0C 5457          movem.l   (A7)+,D2/D3/A2/A3/A4
00002E68  4E5E      5458          unlk      A6
00002E6A  4E75      5459          rts
                    5460   ; }
                    5461   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5462   ; // This function decodes the MODE|EA bits opcode in bits 5,4,3,2,1,0 or 11-6
                    5463   ; // DataSize is used to gain access to the operand used by EA, e.g. ADDI  #$2344422,$234234
                    5464   ; // since the data following the opcode is actually the immediate data which could be 1 or 2 words
                    5465   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5466   ; void Decode6BitEA(unsigned short int *OpCode, int EAChoice, unsigned short int DataSize, unsigned short int IsItMoveInstruction)     // decode Mode/Register
                    5467   ; {
                    5468   _Decode6BitEA:
00002E6C  4E56 FFF4 5469          link      A6,#-12
00002E70  48E7 3F3C 5470          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00002E74  45F8 0CCC 5471          lea       _strcatInstruction.L,A2
00002E78  47F9 0B00 5472          lea       _TempString.L,A3
00002E7C  0546      
00002E7E  282E 0008 5473          move.l    8(A6),D4
00002E82  49F9 0000 5474          lea       _sprintf.L,A4
00002E86  54A8      
00002E88  4BF9 0B00 5475          lea       _InstructionSize.L,A5
00002E8C  017E      
00002E8E  3C2E 0012 5476          move.w    18(A6),D6
00002E92  CCBC 0000 5477          and.l     #65535,D6
00002E96  FFFF      
                    5478   ; unsigned char OperandMode, OperandRegister, OperandSize;
                    5479   ; short int ExWord1, ExWord2 ;                       // get any extra 16 bit word associated with EA
                    5480   ; unsigned char RegNumber[3];
                    5481   ; signed char offset ;
                    5482   ; unsigned short int Xn, XnSize ;
                    5483   ; if(EAChoice == 0)   {   // if EA in bits 5-0
00002E98  202E 000C 5484          move.l    12(A6),D0
00002E9C  6620      5485          bne.s     Decode6BitEA_1
                    5486   ; OperandMode = ((unsigned char)(*OpCode >> 3) & (unsigned short int)(0x7)) ;    // get bits 5,4,3 into position 2,1,0
00002E9E  2044      5487          move.l    D4,A0
00002EA0  3010      5488          move.w    (A0),D0
00002EA2  E648      5489          lsr.w     #3,D0
00002EA4  C07C 00FF 5490          and.w     #255,D0
00002EA8  C07C 0007 5491          and.w     #7,D0
00002EAC  1A00      5492          move.b    D0,D5
                    5493   ; OperandRegister = ((unsigned char)(*OpCode) & (unsigned short int)(0x7)) ;
00002EAE  2044      5494          move.l    D4,A0
00002EB0  3010      5495          move.w    (A0),D0
00002EB2  C07C 00FF 5496          and.w     #255,D0
00002EB6  C07C 0007 5497          and.w     #7,D0
00002EBA  1600      5498          move.b    D0,D3
00002EBC  6022      5499          bra.s     Decode6BitEA_2
                    5500   Decode6BitEA_1:
                    5501   ; }
                    5502   ; else    {               // else EA in bits 11-6
                    5503   ; OperandMode = ((unsigned char)(*OpCode >> 6) & (unsigned short int)(0x7)) ;
00002EBE  2044      5504          move.l    D4,A0
00002EC0  3010      5505          move.w    (A0),D0
00002EC2  EC48      5506          lsr.w     #6,D0
00002EC4  C07C 00FF 5507          and.w     #255,D0
00002EC8  C07C 0007 5508          and.w     #7,D0
00002ECC  1A00      5509          move.b    D0,D5
                    5510   ; OperandRegister = ((unsigned char)(*OpCode >> 9) & (unsigned short int)(0x7)) ;
00002ECE  2044      5511          move.l    D4,A0
00002ED0  3010      5512          move.w    (A0),D0
00002ED2  E048      5513          lsr.w     #8,D0
00002ED4  E248      5514          lsr.w     #1,D0
00002ED6  C07C 00FF 5515          and.w     #255,D0
00002EDA  C07C 0007 5516          and.w     #7,D0
00002EDE  1600      5517          move.b    D0,D3
                    5518   Decode6BitEA_2:
                    5519   ; }
                    5520   ; if(EAChoice == 0)    {
00002EE0  202E 000C 5521          move.l    12(A6),D0
00002EE4  6600 0034 5522          bne       Decode6BitEA_3
                    5523   ; ExWord1 = OpCode[1+DataSize] ;
00002EE8  2044      5524          move.l    D4,A0
00002EEA  7001      5525          moveq     #1,D0
00002EEC  4880      5526          ext.w     D0
00002EEE  48C0      5527          ext.l     D0
00002EF0  CCBC 0000 5528          and.l     #65535,D6
00002EF4  FFFF      
00002EF6  D086      5529          add.l     D6,D0
00002EF8  E388      5530          lsl.l     #1,D0
00002EFA  3430 0800 5531          move.w    0(A0,D0.L),D2
                    5532   ; ExWord2 = OpCode[2+DataSize] ;
00002EFE  2044      5533          move.l    D4,A0
00002F00  7002      5534          moveq     #2,D0
00002F02  4880      5535          ext.w     D0
00002F04  48C0      5536          ext.l     D0
00002F06  CCBC 0000 5537          and.l     #65535,D6
00002F0A  FFFF      
00002F0C  D086      5538          add.l     D6,D0
00002F0E  E388      5539          lsl.l     #1,D0
00002F10  3D70 0800 5540          move.w    0(A0,D0.L),-8(A6)
00002F14  FFF8      
00002F16  6000 007E 5541          bra       Decode6BitEA_7
                    5542   Decode6BitEA_3:
                    5543   ; }
                    5544   ; else if(EAChoice == 1)   {
00002F1A  202E 000C 5545          move.l    12(A6),D0
00002F1E  0C80 0000 5546          cmp.l     #1,D0
00002F22  0001      
00002F24  6600 0034 5547          bne       Decode6BitEA_5
                    5548   ; ExWord1 = OpCode[3+DataSize] ;
00002F28  2044      5549          move.l    D4,A0
00002F2A  7003      5550          moveq     #3,D0
00002F2C  4880      5551          ext.w     D0
00002F2E  48C0      5552          ext.l     D0
00002F30  CCBC 0000 5553          and.l     #65535,D6
00002F34  FFFF      
00002F36  D086      5554          add.l     D6,D0
00002F38  E388      5555          lsl.l     #1,D0
00002F3A  3430 0800 5556          move.w    0(A0,D0.L),D2
                    5557   ; ExWord2 = OpCode[4+DataSize] ;
00002F3E  2044      5558          move.l    D4,A0
00002F40  7004      5559          moveq     #4,D0
00002F42  4880      5560          ext.w     D0
00002F44  48C0      5561          ext.l     D0
00002F46  CCBC 0000 5562          and.l     #65535,D6
00002F4A  FFFF      
00002F4C  D086      5563          add.l     D6,D0
00002F4E  E388      5564          lsl.l     #1,D0
00002F50  3D70 0800 5565          move.w    0(A0,D0.L),-8(A6)
00002F54  FFF8      
00002F56  6000 003E 5566          bra       Decode6BitEA_7
                    5567   Decode6BitEA_5:
                    5568   ; }
                    5569   ; else if(EAChoice == 2)   {  // for move instruction
00002F5A  202E 000C 5570          move.l    12(A6),D0
00002F5E  0C80 0000 5571          cmp.l     #2,D0
00002F62  0002      
00002F64  6600 0030 5572          bne       Decode6BitEA_7
                    5573   ; ExWord1 = OpCode[1+DataSize] ;
00002F68  2044      5574          move.l    D4,A0
00002F6A  7001      5575          moveq     #1,D0
00002F6C  4880      5576          ext.w     D0
00002F6E  48C0      5577          ext.l     D0
00002F70  CCBC 0000 5578          and.l     #65535,D6
00002F74  FFFF      
00002F76  D086      5579          add.l     D6,D0
00002F78  E388      5580          lsl.l     #1,D0
00002F7A  3430 0800 5581          move.w    0(A0,D0.L),D2
                    5582   ; ExWord2 = OpCode[2+DataSize] ;
00002F7E  2044      5583          move.l    D4,A0
00002F80  7002      5584          moveq     #2,D0
00002F82  4880      5585          ext.w     D0
00002F84  48C0      5586          ext.l     D0
00002F86  CCBC 0000 5587          and.l     #65535,D6
00002F8A  FFFF      
00002F8C  D086      5588          add.l     D6,D0
00002F8E  E388      5589          lsl.l     #1,D0
00002F90  3D70 0800 5590          move.w    0(A0,D0.L),-8(A6)
00002F94  FFF8      
                    5591   Decode6BitEA_7:
                    5592   ; }
                    5593   ; if(OperandMode == (unsigned char)(0)) {                    // Effective Address = Dn
00002F96  4A05      5594          tst.b     D5
00002F98  661E      5595          bne.s     Decode6BitEA_9
                    5596   ; RegNumber[0] = 'D' ;
00002F9A  1D7C 0044 5597          move.b    #68,-6+0(A6)
00002F9E  FFFA      
                    5598   ; RegNumber[1] = (unsigned char)(0x30 + OperandRegister) ;
00002FA0  7030      5599          moveq     #48,D0
00002FA2  D003      5600          add.b     D3,D0
00002FA4  1D40 FFFB 5601          move.b    D0,-6+1(A6)
                    5602   ; RegNumber[2] = 0 ;
00002FA8  422E FFFC 5603          clr.b     -6+2(A6)
                    5604   ; strcatInstruction(RegNumber) ;
00002FAC  486E FFFA 5605          pea       -6(A6)
00002FB0  4E92      5606          jsr       (A2)
00002FB2  584F      5607          addq.w    #4,A7
00002FB4  6000 02D6 5608          bra       Decode6BitEA_44
                    5609   Decode6BitEA_9:
                    5610   ; }
                    5611   ; else if(OperandMode == (unsigned char)(1)) {                    // Effective Address = An
00002FB8  0C05 0001 5612          cmp.b     #1,D5
00002FBC  6616      5613          bne.s     Decode6BitEA_11
                    5614   ; Decode3BitAddressRegister(OperandRegister) ;
00002FBE  C67C 00FF 5615          and.w     #255,D3
00002FC2  C6BC 0000 5616          and.l     #65535,D3
00002FC6  FFFF      
00002FC8  2F03      5617          move.l    D3,-(A7)
00002FCA  4EB8 2C68 5618          jsr       _Decode3BitAddressRegister
00002FCE  584F      5619          addq.w    #4,A7
00002FD0  6000 02BA 5620          bra       Decode6BitEA_44
                    5621   Decode6BitEA_11:
                    5622   ; }
                    5623   ; else if(OperandMode == (unsigned char)(2)) {                    // Effective Address = (An)
00002FD4  0C05 0002 5624          cmp.b     #2,D5
00002FD8  662A      5625          bne.s     Decode6BitEA_13
                    5626   ; strcatInstruction("(") ;
00002FDA  4879 0000 5627          pea       @m68kde~2_153.L
00002FDE  6F7C      
00002FE0  4E92      5628          jsr       (A2)
00002FE2  584F      5629          addq.w    #4,A7
                    5630   ; Decode3BitAddressRegister(OperandRegister) ;
00002FE4  C67C 00FF 5631          and.w     #255,D3
00002FE8  C6BC 0000 5632          and.l     #65535,D3
00002FEC  FFFF      
00002FEE  2F03      5633          move.l    D3,-(A7)
00002FF0  4EB8 2C68 5634          jsr       _Decode3BitAddressRegister
00002FF4  584F      5635          addq.w    #4,A7
                    5636   ; strcatInstruction(")") ;
00002FF6  4879 0000 5637          pea       @m68kde~2_154.L
00002FFA  6F7E      
00002FFC  4E92      5638          jsr       (A2)
00002FFE  584F      5639          addq.w    #4,A7
00003000  6000 028A 5640          bra       Decode6BitEA_44
                    5641   Decode6BitEA_13:
                    5642   ; }
                    5643   ; else if(OperandMode == (unsigned char)(3)) {                    // Effective Address = (An)+
00003004  0C05 0003 5644          cmp.b     #3,D5
00003008  662A      5645          bne.s     Decode6BitEA_15
                    5646   ; strcatInstruction("(") ;
0000300A  4879 0000 5647          pea       @m68kde~2_153.L
0000300E  6F7C      
00003010  4E92      5648          jsr       (A2)
00003012  584F      5649          addq.w    #4,A7
                    5650   ; Decode3BitAddressRegister(OperandRegister) ;
00003014  C67C 00FF 5651          and.w     #255,D3
00003018  C6BC 0000 5652          and.l     #65535,D3
0000301C  FFFF      
0000301E  2F03      5653          move.l    D3,-(A7)
00003020  4EB8 2C68 5654          jsr       _Decode3BitAddressRegister
00003024  584F      5655          addq.w    #4,A7
                    5656   ; strcatInstruction(")+") ;
00003026  4879 0000 5657          pea       @m68kde~2_155.L
0000302A  6F80      
0000302C  4E92      5658          jsr       (A2)
0000302E  584F      5659          addq.w    #4,A7
00003030  6000 025A 5660          bra       Decode6BitEA_44
                    5661   Decode6BitEA_15:
                    5662   ; }
                    5663   ; else if(OperandMode == (unsigned char)(4)) {                    // Effective Address = -(An)
00003034  0C05 0004 5664          cmp.b     #4,D5
00003038  662A      5665          bne.s     Decode6BitEA_17
                    5666   ; strcatInstruction("-(") ;
0000303A  4879 0000 5667          pea       @m68kde~2_156.L
0000303E  6F84      
00003040  4E92      5668          jsr       (A2)
00003042  584F      5669          addq.w    #4,A7
                    5670   ; Decode3BitAddressRegister(OperandRegister) ;
00003044  C67C 00FF 5671          and.w     #255,D3
00003048  C6BC 0000 5672          and.l     #65535,D3
0000304C  FFFF      
0000304E  2F03      5673          move.l    D3,-(A7)
00003050  4EB8 2C68 5674          jsr       _Decode3BitAddressRegister
00003054  584F      5675          addq.w    #4,A7
                    5676   ; strcatInstruction(")") ;
00003056  4879 0000 5677          pea       @m68kde~2_154.L
0000305A  6F7E      
0000305C  4E92      5678          jsr       (A2)
0000305E  584F      5679          addq.w    #4,A7
00003060  6000 022A 5680          bra       Decode6BitEA_44
                    5681   Decode6BitEA_17:
                    5682   ; }
                    5683   ; else if(OperandMode == (unsigned char)(5)) {                    // Effective Address = (d16, An)
00003064  0C05 0005 5684          cmp.b     #5,D5
00003068  6626      5685          bne.s     Decode6BitEA_19
                    5686   ; sprintf(TempString, "%d(A%d)", ExWord1, OperandRegister) ;
0000306A  C6BC 0000 5687          and.l     #255,D3
0000306E  00FF      
00003070  2F03      5688          move.l    D3,-(A7)
00003072  48C2      5689          ext.l     D2
00003074  2F02      5690          move.l    D2,-(A7)
00003076  4879 0000 5691          pea       @m68kde~2_157.L
0000307A  6F88      
0000307C  2F0B      5692          move.l    A3,-(A7)
0000307E  4E94      5693          jsr       (A4)
00003080  DEFC 0010 5694          add.w     #16,A7
                    5695   ; strcatInstruction(TempString) ;
00003084  2F0B      5696          move.l    A3,-(A7)
00003086  4E92      5697          jsr       (A2)
00003088  584F      5698          addq.w    #4,A7
                    5699   ; InstructionSize += 1;
0000308A  5295      5700          addq.l    #1,(A5)
0000308C  6000 01FE 5701          bra       Decode6BitEA_44
                    5702   Decode6BitEA_19:
                    5703   ; }
                    5704   ; else if(OperandMode == (unsigned char)(6)) {                    // Effective Address = (d8, An, Xn)
00003090  0C05 0006 5705          cmp.b     #6,D5
00003094  6600 00AA 5706          bne       Decode6BitEA_21
                    5707   ; offset = ExWord1 & (short int)(0x00FF);
00003098  3002      5708          move.w    D2,D0
0000309A  C07C 00FF 5709          and.w     #255,D0
0000309E  1D40 FFFD 5710          move.b    D0,-3(A6)
                    5711   ; sprintf(TempString, "%d(A%d,", offset, OperandRegister) ;
000030A2  C6BC 0000 5712          and.l     #255,D3
000030A6  00FF      
000030A8  2F03      5713          move.l    D3,-(A7)
000030AA  122E FFFD 5714          move.b    -3(A6),D1
000030AE  4881      5715          ext.w     D1
000030B0  48C1      5716          ext.l     D1
000030B2  2F01      5717          move.l    D1,-(A7)
000030B4  4879 0000 5718          pea       @m68kde~2_158.L
000030B8  6F90      
000030BA  2F0B      5719          move.l    A3,-(A7)
000030BC  4E94      5720          jsr       (A4)
000030BE  DEFC 0010 5721          add.w     #16,A7
                    5722   ; strcatInstruction(TempString) ;
000030C2  2F0B      5723          move.l    A3,-(A7)
000030C4  4E92      5724          jsr       (A2)
000030C6  584F      5725          addq.w    #4,A7
                    5726   ; InstructionSize += 1;
000030C8  5295      5727          addq.l    #1,(A5)
                    5728   ; // decode the Xn bit
                    5729   ; if((ExWord1 & (unsigned short int)(0x8000)) == (unsigned short int)(0x0000))
000030CA  3002      5730          move.w    D2,D0
000030CC  C07C 8000 5731          and.w     #32768,D0
000030D0  660C      5732          bne.s     Decode6BitEA_23
                    5733   ; strcatInstruction("D") ;
000030D2  4879 0000 5734          pea       @m68kde~2_159.L
000030D6  6F98      
000030D8  4E92      5735          jsr       (A2)
000030DA  584F      5736          addq.w    #4,A7
000030DC  600A      5737          bra.s     Decode6BitEA_24
                    5738   Decode6BitEA_23:
                    5739   ; else
                    5740   ; strcatInstruction("A") ;
000030DE  4879 0000 5741          pea       @m68kde~2_160.L
000030E2  6F9A      
000030E4  4E92      5742          jsr       (A2)
000030E6  584F      5743          addq.w    #4,A7
                    5744   Decode6BitEA_24:
                    5745   ; Xn = (ExWord1 & (unsigned short int)(0x7000)) >> 12 ;        // get Xn register Number into bits 2,1,0
000030E8  3002      5746          move.w    D2,D0
000030EA  C07C 7000 5747          and.w     #28672,D0
000030EE  E048      5748          lsr.w     #8,D0
000030F0  E848      5749          lsr.w     #4,D0
000030F2  3D40 FFFE 5750          move.w    D0,-2(A6)
                    5751   ; sprintf(TempString, "%d",Xn) ;                               // generate string for reg number 0 -7
000030F6  322E FFFE 5752          move.w    -2(A6),D1
000030FA  C2BC 0000 5753          and.l     #65535,D1
000030FE  FFFF      
00003100  2F01      5754          move.l    D1,-(A7)
00003102  4879 0000 5755          pea       @m68kde~2_161.L
00003106  6F9C      
00003108  2F0B      5756          move.l    A3,-(A7)
0000310A  4E94      5757          jsr       (A4)
0000310C  DEFC 000C 5758          add.w     #12,A7
                    5759   ; strcatInstruction(TempString) ;
00003110  2F0B      5760          move.l    A3,-(A7)
00003112  4E92      5761          jsr       (A2)
00003114  584F      5762          addq.w    #4,A7
                    5763   ; XnSize = (ExWord1 & (unsigned short int)(0x0800)) >> 11 ;    // get xn size into bit 0
00003116  3002      5764          move.w    D2,D0
00003118  C07C 0800 5765          and.w     #2048,D0
0000311C  E048      5766          lsr.w     #8,D0
0000311E  E648      5767          lsr.w     #3,D0
00003120  3E00      5768          move.w    D0,D7
                    5769   ; if(XnSize == 0)
00003122  4A47      5770          tst.w     D7
00003124  660C      5771          bne.s     Decode6BitEA_25
                    5772   ; strcatInstruction(".W)") ;
00003126  4879 0000 5773          pea       @m68kde~2_162.L
0000312A  6FA0      
0000312C  4E92      5774          jsr       (A2)
0000312E  584F      5775          addq.w    #4,A7
00003130  600A      5776          bra.s     Decode6BitEA_26
                    5777   Decode6BitEA_25:
                    5778   ; else
                    5779   ; strcatInstruction(".L)") ;
00003132  4879 0000 5780          pea       @m68kde~2_163.L
00003136  6FA4      
00003138  4E92      5781          jsr       (A2)
0000313A  584F      5782          addq.w    #4,A7
                    5783   Decode6BitEA_26:
0000313C  6000 014E 5784          bra       Decode6BitEA_44
                    5785   Decode6BitEA_21:
                    5786   ; }
                    5787   ; else if(OperandMode == (unsigned char)(7)) {
00003140  0C05 0007 5788          cmp.b     #7,D5
00003144  6600 0146 5789          bne       Decode6BitEA_44
                    5790   ; if(OperandRegister == 0) {                               // EA = (xxx).W
00003148  4A03      5791          tst.b     D3
0000314A  661E      5792          bne.s     Decode6BitEA_29
                    5793   ; sprintf(TempString, "$%X", ExWord1) ;
0000314C  48C2      5794          ext.l     D2
0000314E  2F02      5795          move.l    D2,-(A7)
00003150  4879 0000 5796          pea       @m68kde~2_164.L
00003154  6FA8      
00003156  2F0B      5797          move.l    A3,-(A7)
00003158  4E94      5798          jsr       (A4)
0000315A  DEFC 000C 5799          add.w     #12,A7
                    5800   ; strcatInstruction(TempString) ;
0000315E  2F0B      5801          move.l    A3,-(A7)
00003160  4E92      5802          jsr       (A2)
00003162  584F      5803          addq.w    #4,A7
                    5804   ; InstructionSize += 1;
00003164  5295      5805          addq.l    #1,(A5)
00003166  6000 0124 5806          bra       Decode6BitEA_44
                    5807   Decode6BitEA_29:
                    5808   ; }
                    5809   ; else if(OperandRegister == 1)   {                         // EA = (xxx).L
0000316A  0C03 0001 5810          cmp.b     #1,D3
0000316E  6600 0032 5811          bne       Decode6BitEA_31
                    5812   ; sprintf(TempString, "$%X", ((unsigned int)(ExWord1) << 16) | (unsigned int)(ExWord2)); // create 32 bit address
00003172  3202      5813          move.w    D2,D1
00003174  48C1      5814          ext.l     D1
00003176  E189      5815          lsl.l     #8,D1
00003178  E189      5816          lsl.l     #8,D1
0000317A  2F00      5817          move.l    D0,-(A7)
0000317C  302E FFF8 5818          move.w    -8(A6),D0
00003180  48C0      5819          ext.l     D0
00003182  8280      5820          or.l      D0,D1
00003184  201F      5821          move.l    (A7)+,D0
00003186  2F01      5822          move.l    D1,-(A7)
00003188  4879 0000 5823          pea       @m68kde~2_164.L
0000318C  6FA8      
0000318E  2F0B      5824          move.l    A3,-(A7)
00003190  4E94      5825          jsr       (A4)
00003192  DEFC 000C 5826          add.w     #12,A7
                    5827   ; strcatInstruction(TempString) ;
00003196  2F0B      5828          move.l    A3,-(A7)
00003198  4E92      5829          jsr       (A2)
0000319A  584F      5830          addq.w    #4,A7
                    5831   ; InstructionSize += 2;
0000319C  5495      5832          addq.l    #2,(A5)
0000319E  6000 00EC 5833          bra       Decode6BitEA_44
                    5834   Decode6BitEA_31:
                    5835   ; }
                    5836   ; else if(OperandRegister == 4) {                                 // source EA = #Immediate addressing
000031A2  0C03 0004 5837          cmp.b     #4,D3
000031A6  661C      5838          bne.s     Decode6BitEA_33
                    5839   ; if(IsItMoveInstruction == 0)        //not move instruction
000031A8  302E 0016 5840          move.w    22(A6),D0
000031AC  660A      5841          bne.s     Decode6BitEA_35
                    5842   ; DecodeBWLDataAfterOpCode(OpCode);
000031AE  2F04      5843          move.l    D4,-(A7)
000031B0  4EB8 2D5C 5844          jsr       _DecodeBWLDataAfterOpCode
000031B4  584F      5845          addq.w    #4,A7
000031B6  6008      5846          bra.s     Decode6BitEA_36
                    5847   Decode6BitEA_35:
                    5848   ; else
                    5849   ; DecodeBWLDataAfterOpCodeForMove(OpCode);
000031B8  2F04      5850          move.l    D4,-(A7)
000031BA  4EB8 2C94 5851          jsr       _DecodeBWLDataAfterOpCodeForMove
000031BE  584F      5852          addq.w    #4,A7
                    5853   Decode6BitEA_36:
000031C0  6000 00CA 5854          bra       Decode6BitEA_44
                    5855   Decode6BitEA_33:
                    5856   ; }
                    5857   ; else if(OperandRegister == 2) {                                 // source EA = (d16,PC)
000031C4  0C03 0002 5858          cmp.b     #2,D3
000031C8  661E      5859          bne.s     Decode6BitEA_37
                    5860   ; sprintf(TempString, "%d(PC)", ExWord1) ;
000031CA  48C2      5861          ext.l     D2
000031CC  2F02      5862          move.l    D2,-(A7)
000031CE  4879 0000 5863          pea       @m68kde~2_165.L
000031D2  6FAC      
000031D4  2F0B      5864          move.l    A3,-(A7)
000031D6  4E94      5865          jsr       (A4)
000031D8  DEFC 000C 5866          add.w     #12,A7
                    5867   ; strcatInstruction(TempString) ;
000031DC  2F0B      5868          move.l    A3,-(A7)
000031DE  4E92      5869          jsr       (A2)
000031E0  584F      5870          addq.w    #4,A7
                    5871   ; InstructionSize += 1;
000031E2  5295      5872          addq.l    #1,(A5)
000031E4  6000 00A6 5873          bra       Decode6BitEA_44
                    5874   Decode6BitEA_37:
                    5875   ; }
                    5876   ; else if(OperandRegister == 3) {                                 // source EA = (d8,PC, Xn)
000031E8  0C03 0003 5877          cmp.b     #3,D3
000031EC  6600 009E 5878          bne       Decode6BitEA_44
                    5879   ; offset = ExWord1 & (short int)(0x00FF);
000031F0  3002      5880          move.w    D2,D0
000031F2  C07C 00FF 5881          and.w     #255,D0
000031F6  1D40 FFFD 5882          move.b    D0,-3(A6)
                    5883   ; sprintf(TempString, "%d(PC,", offset ) ;
000031FA  122E FFFD 5884          move.b    -3(A6),D1
000031FE  4881      5885          ext.w     D1
00003200  48C1      5886          ext.l     D1
00003202  2F01      5887          move.l    D1,-(A7)
00003204  4879 0000 5888          pea       @m68kde~2_166.L
00003208  6FB4      
0000320A  2F0B      5889          move.l    A3,-(A7)
0000320C  4E94      5890          jsr       (A4)
0000320E  DEFC 000C 5891          add.w     #12,A7
                    5892   ; strcatInstruction(TempString) ;
00003212  2F0B      5893          move.l    A3,-(A7)
00003214  4E92      5894          jsr       (A2)
00003216  584F      5895          addq.w    #4,A7
                    5896   ; InstructionSize += 1;
00003218  5295      5897          addq.l    #1,(A5)
                    5898   ; // decode the Xn bit
                    5899   ; if((ExWord1 & (unsigned short int)(0x8000)) == (unsigned short int)(0x0000))
0000321A  3002      5900          move.w    D2,D0
0000321C  C07C 8000 5901          and.w     #32768,D0
00003220  660C      5902          bne.s     Decode6BitEA_41
                    5903   ; strcatInstruction("D") ;
00003222  4879 0000 5904          pea       @m68kde~2_159.L
00003226  6F98      
00003228  4E92      5905          jsr       (A2)
0000322A  584F      5906          addq.w    #4,A7
0000322C  600A      5907          bra.s     Decode6BitEA_42
                    5908   Decode6BitEA_41:
                    5909   ; else
                    5910   ; strcatInstruction("A") ;
0000322E  4879 0000 5911          pea       @m68kde~2_160.L
00003232  6F9A      
00003234  4E92      5912          jsr       (A2)
00003236  584F      5913          addq.w    #4,A7
                    5914   Decode6BitEA_42:
                    5915   ; Xn = (ExWord1 & (unsigned short int)(0x7000)) >> 12 ;        // get Xn register Number into bits 2,1,0
00003238  3002      5916          move.w    D2,D0
0000323A  C07C 7000 5917          and.w     #28672,D0
0000323E  E048      5918          lsr.w     #8,D0
00003240  E848      5919          lsr.w     #4,D0
00003242  3D40 FFFE 5920          move.w    D0,-2(A6)
                    5921   ; sprintf(TempString, "%d",Xn) ;                               // generate string for reg number 0 -7
00003246  322E FFFE 5922          move.w    -2(A6),D1
0000324A  C2BC 0000 5923          and.l     #65535,D1
0000324E  FFFF      
00003250  2F01      5924          move.l    D1,-(A7)
00003252  4879 0000 5925          pea       @m68kde~2_161.L
00003256  6F9C      
00003258  2F0B      5926          move.l    A3,-(A7)
0000325A  4E94      5927          jsr       (A4)
0000325C  DEFC 000C 5928          add.w     #12,A7
                    5929   ; strcatInstruction(TempString) ;
00003260  2F0B      5930          move.l    A3,-(A7)
00003262  4E92      5931          jsr       (A2)
00003264  584F      5932          addq.w    #4,A7
                    5933   ; XnSize = (ExWord1 & (unsigned short int)(0x0800)) >> 11 ;    // get xn size into bit 0
00003266  3002      5934          move.w    D2,D0
00003268  C07C 0800 5935          and.w     #2048,D0
0000326C  E048      5936          lsr.w     #8,D0
0000326E  E648      5937          lsr.w     #3,D0
00003270  3E00      5938          move.w    D0,D7
                    5939   ; if(XnSize == 0)
00003272  4A47      5940          tst.w     D7
00003274  660C      5941          bne.s     Decode6BitEA_43
                    5942   ; strcatInstruction(".W)") ;
00003276  4879 0000 5943          pea       @m68kde~2_162.L
0000327A  6FA0      
0000327C  4E92      5944          jsr       (A2)
0000327E  584F      5945          addq.w    #4,A7
00003280  600A      5946          bra.s     Decode6BitEA_44
                    5947   Decode6BitEA_43:
                    5948   ; else
                    5949   ; strcatInstruction(".L)") ;
00003282  4879 0000 5950          pea       @m68kde~2_163.L
00003286  6FA4      
00003288  4E92      5951          jsr       (A2)
0000328A  584F      5952          addq.w    #4,A7
                    5953   Decode6BitEA_44:
0000328C  4CDF 3CFC 5954          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003290  4E5E      5955          unlk      A6
00003292  4E75      5956          rts
                    5957   ; }
                    5958   ; }
                    5959   ; }
                    5960   ; void Decode3BitOperandMode(unsigned short int *OpCode)               // used with instructions like ADD determines source/destination
                    5961   ; {
                    5962   _Decode3BitOperandMode:
00003294  4E56 FFFC 5963          link      A6,#-4
00003298  2F02      5964          move.l    D2,-(A7)
0000329A  242E 0008 5965          move.l    8(A6),D2
                    5966   ; unsigned short int OperandMode;
                    5967   ; OperandMode = (*OpCode & (unsigned short int)(0x0100)) >> 8 ;    // get bit 8 into position 0, defines source and destination
0000329E  2042      5968          move.l    D2,A0
000032A0  3010      5969          move.w    (A0),D0
000032A2  C07C 0100 5970          and.w     #256,D0
000032A6  E048      5971          lsr.w     #8,D0
000032A8  3D40 FFFE 5972          move.w    D0,-2(A6)
                    5973   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
000032AC  2042      5974          move.l    D2,A0
000032AE  3210      5975          move.w    (A0),D1
000032B0  C2BC 0000 5976          and.l     #65535,D1
000032B4  FFFF      
000032B6  2F01      5977          move.l    D1,-(A7)
000032B8  4EB8 2BD8 5978          jsr       _Decode2BitOperandSize
000032BC  584F      5979          addq.w    #4,A7
                    5980   ; if(OperandMode == 0)     {                                      // Destination is a Data Register
000032BE  302E FFFE 5981          move.w    -2(A6),D0
000032C2  6600 0032 5982          bne       Decode3BitOperandMode_1
                    5983   ; Decode6BitEA(OpCode,0,0,0) ;
000032C6  42A7      5984          clr.l     -(A7)
000032C8  42A7      5985          clr.l     -(A7)
000032CA  42A7      5986          clr.l     -(A7)
000032CC  2F02      5987          move.l    D2,-(A7)
000032CE  4EB8 2E6C 5988          jsr       _Decode6BitEA
000032D2  DEFC 0010 5989          add.w     #16,A7
                    5990   ; strcatInstruction(",") ;
000032D6  4879 0000 5991          pea       @m68kde~2_167.L
000032DA  6FBC      
000032DC  4EB8 0CCC 5992          jsr       _strcatInstruction
000032E0  584F      5993          addq.w    #4,A7
                    5994   ; Decode3BitDataRegister(*OpCode) ;
000032E2  2042      5995          move.l    D2,A0
000032E4  3210      5996          move.w    (A0),D1
000032E6  C2BC 0000 5997          and.l     #65535,D1
000032EA  FFFF      
000032EC  2F01      5998          move.l    D1,-(A7)
000032EE  4EB8 2C34 5999          jsr       _Decode3BitDataRegister
000032F2  584F      6000          addq.w    #4,A7
000032F4  602E      6001          bra.s     Decode3BitOperandMode_2
                    6002   Decode3BitOperandMode_1:
                    6003   ; }
                    6004   ; else {                                                         // Destination is in EA
                    6005   ; Decode3BitDataRegister(*OpCode) ;
000032F6  2042      6006          move.l    D2,A0
000032F8  3210      6007          move.w    (A0),D1
000032FA  C2BC 0000 6008          and.l     #65535,D1
000032FE  FFFF      
00003300  2F01      6009          move.l    D1,-(A7)
00003302  4EB8 2C34 6010          jsr       _Decode3BitDataRegister
00003306  584F      6011          addq.w    #4,A7
                    6012   ; strcatInstruction(",") ;
00003308  4879 0000 6013          pea       @m68kde~2_167.L
0000330C  6FBC      
0000330E  4EB8 0CCC 6014          jsr       _strcatInstruction
00003312  584F      6015          addq.w    #4,A7
                    6016   ; Decode6BitEA(OpCode,0,0,0) ;
00003314  42A7      6017          clr.l     -(A7)
00003316  42A7      6018          clr.l     -(A7)
00003318  42A7      6019          clr.l     -(A7)
0000331A  2F02      6020          move.l    D2,-(A7)
0000331C  4EB8 2E6C 6021          jsr       _Decode6BitEA
00003320  DEFC 0010 6022          add.w     #16,A7
                    6023   Decode3BitOperandMode_2:
00003324  241F      6024          move.l    (A7)+,D2
00003326  4E5E      6025          unlk      A6
00003328  4E75      6026          rts
                    6027   ; }
                    6028   ; }
                    6029   ; void DecodeBranchCondition(unsigned short int Condition)
                    6030   ; {
                    6031   _DecodeBranchCondition:
0000332A  4E56 0000 6032          link      A6,#0
0000332E  48E7 2020 6033          movem.l   D2/A2,-(A7)
00003332  45F8 0CCC 6034          lea       _strcatInstruction.L,A2
00003336  342E 000A 6035          move.w    10(A6),D2
0000333A  C4BC 0000 6036          and.l     #65535,D2
0000333E  FFFF      
                    6037   ; if(Condition == (unsigned short int)(0x04))
00003340  0C42 0004 6038          cmp.w     #4,D2
00003344  660E      6039          bne.s     DecodeBranchCondition_1
                    6040   ; strcatInstruction("CC") ;
00003346  4879 0000 6041          pea       @m68kde~2_168.L
0000334A  6FBE      
0000334C  4E92      6042          jsr       (A2)
0000334E  584F      6043          addq.w    #4,A7
00003350  6000 011C 6044          bra       DecodeBranchCondition_30
                    6045   DecodeBranchCondition_1:
                    6046   ; else if(Condition == (unsigned short int)(0x05))
00003354  0C42 0005 6047          cmp.w     #5,D2
00003358  660E      6048          bne.s     DecodeBranchCondition_3
                    6049   ; strcatInstruction("CS") ;
0000335A  4879 0000 6050          pea       @m68kde~2_169.L
0000335E  6FC2      
00003360  4E92      6051          jsr       (A2)
00003362  584F      6052          addq.w    #4,A7
00003364  6000 0108 6053          bra       DecodeBranchCondition_30
                    6054   DecodeBranchCondition_3:
                    6055   ; else if(Condition == (unsigned short int)(0x07))
00003368  0C42 0007 6056          cmp.w     #7,D2
0000336C  660E      6057          bne.s     DecodeBranchCondition_5
                    6058   ; strcatInstruction("EQ") ;
0000336E  4879 0000 6059          pea       @m68kde~2_170.L
00003372  6FC6      
00003374  4E92      6060          jsr       (A2)
00003376  584F      6061          addq.w    #4,A7
00003378  6000 00F4 6062          bra       DecodeBranchCondition_30
                    6063   DecodeBranchCondition_5:
                    6064   ; else if(Condition == (unsigned short int)(0x0C))
0000337C  0C42 000C 6065          cmp.w     #12,D2
00003380  660E      6066          bne.s     DecodeBranchCondition_7
                    6067   ; strcatInstruction("GE") ;
00003382  4879 0000 6068          pea       @m68kde~2_171.L
00003386  6FCA      
00003388  4E92      6069          jsr       (A2)
0000338A  584F      6070          addq.w    #4,A7
0000338C  6000 00E0 6071          bra       DecodeBranchCondition_30
                    6072   DecodeBranchCondition_7:
                    6073   ; else if(Condition == (unsigned short int)(0x0E))
00003390  0C42 000E 6074          cmp.w     #14,D2
00003394  660E      6075          bne.s     DecodeBranchCondition_9
                    6076   ; strcatInstruction("GT") ;
00003396  4879 0000 6077          pea       @m68kde~2_172.L
0000339A  6FCE      
0000339C  4E92      6078          jsr       (A2)
0000339E  584F      6079          addq.w    #4,A7
000033A0  6000 00CC 6080          bra       DecodeBranchCondition_30
                    6081   DecodeBranchCondition_9:
                    6082   ; else if(Condition == (unsigned short int)(0x02))
000033A4  0C42 0002 6083          cmp.w     #2,D2
000033A8  660E      6084          bne.s     DecodeBranchCondition_11
                    6085   ; strcatInstruction("HI") ;
000033AA  4879 0000 6086          pea       @m68kde~2_173.L
000033AE  6FD2      
000033B0  4E92      6087          jsr       (A2)
000033B2  584F      6088          addq.w    #4,A7
000033B4  6000 00B8 6089          bra       DecodeBranchCondition_30
                    6090   DecodeBranchCondition_11:
                    6091   ; else if(Condition == (unsigned short int)(0x0F))
000033B8  0C42 000F 6092          cmp.w     #15,D2
000033BC  660E      6093          bne.s     DecodeBranchCondition_13
                    6094   ; strcatInstruction("LE") ;
000033BE  4879 0000 6095          pea       @m68kde~2_174.L
000033C2  6FD6      
000033C4  4E92      6096          jsr       (A2)
000033C6  584F      6097          addq.w    #4,A7
000033C8  6000 00A4 6098          bra       DecodeBranchCondition_30
                    6099   DecodeBranchCondition_13:
                    6100   ; else if(Condition == (unsigned short int)(0x03))
000033CC  0C42 0003 6101          cmp.w     #3,D2
000033D0  660E      6102          bne.s     DecodeBranchCondition_15
                    6103   ; strcatInstruction("LS") ;
000033D2  4879 0000 6104          pea       @m68kde~2_175.L
000033D6  6FDA      
000033D8  4E92      6105          jsr       (A2)
000033DA  584F      6106          addq.w    #4,A7
000033DC  6000 0090 6107          bra       DecodeBranchCondition_30
                    6108   DecodeBranchCondition_15:
                    6109   ; else if(Condition == (unsigned short int)(0x0D))
000033E0  0C42 000D 6110          cmp.w     #13,D2
000033E4  660E      6111          bne.s     DecodeBranchCondition_17
                    6112   ; strcatInstruction("LT") ;
000033E6  4879 0000 6113          pea       @m68kde~2_176.L
000033EA  6FDE      
000033EC  4E92      6114          jsr       (A2)
000033EE  584F      6115          addq.w    #4,A7
000033F0  6000 007C 6116          bra       DecodeBranchCondition_30
                    6117   DecodeBranchCondition_17:
                    6118   ; else if(Condition == (unsigned short int)(0x0B))
000033F4  0C42 000B 6119          cmp.w     #11,D2
000033F8  660E      6120          bne.s     DecodeBranchCondition_19
                    6121   ; strcatInstruction("MI") ;
000033FA  4879 0000 6122          pea       @m68kde~2_177.L
000033FE  6FE2      
00003400  4E92      6123          jsr       (A2)
00003402  584F      6124          addq.w    #4,A7
00003404  6000 0068 6125          bra       DecodeBranchCondition_30
                    6126   DecodeBranchCondition_19:
                    6127   ; else if(Condition == (unsigned short int)(0x06))
00003408  0C42 0006 6128          cmp.w     #6,D2
0000340C  660E      6129          bne.s     DecodeBranchCondition_21
                    6130   ; strcatInstruction("NE") ;
0000340E  4879 0000 6131          pea       @m68kde~2_178.L
00003412  6FE6      
00003414  4E92      6132          jsr       (A2)
00003416  584F      6133          addq.w    #4,A7
00003418  6000 0054 6134          bra       DecodeBranchCondition_30
                    6135   DecodeBranchCondition_21:
                    6136   ; else if(Condition == (unsigned short int)(0x0A))
0000341C  0C42 000A 6137          cmp.w     #10,D2
00003420  660E      6138          bne.s     DecodeBranchCondition_23
                    6139   ; strcatInstruction("PL") ;
00003422  4879 0000 6140          pea       @m68kde~2_179.L
00003426  6FEA      
00003428  4E92      6141          jsr       (A2)
0000342A  584F      6142          addq.w    #4,A7
0000342C  6000 0040 6143          bra       DecodeBranchCondition_30
                    6144   DecodeBranchCondition_23:
                    6145   ; else if(Condition == (unsigned short int)(0x09))
00003430  0C42 0009 6146          cmp.w     #9,D2
00003434  660C      6147          bne.s     DecodeBranchCondition_25
                    6148   ; strcatInstruction("VS") ;
00003436  4879 0000 6149          pea       @m68kde~2_180.L
0000343A  6FEE      
0000343C  4E92      6150          jsr       (A2)
0000343E  584F      6151          addq.w    #4,A7
00003440  602C      6152          bra.s     DecodeBranchCondition_30
                    6153   DecodeBranchCondition_25:
                    6154   ; else if(Condition == (unsigned short int)(0x08))
00003442  0C42 0008 6155          cmp.w     #8,D2
00003446  660C      6156          bne.s     DecodeBranchCondition_27
                    6157   ; strcatInstruction("VC") ;
00003448  4879 0000 6158          pea       @m68kde~2_181.L
0000344C  6FF2      
0000344E  4E92      6159          jsr       (A2)
00003450  584F      6160          addq.w    #4,A7
00003452  601A      6161          bra.s     DecodeBranchCondition_30
                    6162   DecodeBranchCondition_27:
                    6163   ; else if(Condition == (unsigned short int)(0))
00003454  4A42      6164          tst.w     D2
00003456  660C      6165          bne.s     DecodeBranchCondition_29
                    6166   ; strcatInstruction("RA") ;
00003458  4879 0000 6167          pea       @m68kde~2_182.L
0000345C  6FF6      
0000345E  4E92      6168          jsr       (A2)
00003460  584F      6169          addq.w    #4,A7
00003462  600A      6170          bra.s     DecodeBranchCondition_30
                    6171   DecodeBranchCondition_29:
                    6172   ; else
                    6173   ; strcatInstruction("SR");
00003464  4879 0000 6174          pea       @m68kde~2_183.L
00003468  6FFA      
0000346A  4E92      6175          jsr       (A2)
0000346C  584F      6176          addq.w    #4,A7
                    6177   DecodeBranchCondition_30:
                    6178   ; strcatInstruction(" ") ;
0000346E  4879 0000 6179          pea       @m68kde~2_29.L
00003472  6184      
00003474  4E92      6180          jsr       (A2)
00003476  584F      6181          addq.w    #4,A7
00003478  4CDF 0404 6182          movem.l   (A7)+,D2/A2
0000347C  4E5E      6183          unlk      A6
0000347E  4E75      6184          rts
                    6185   ; }
                    6186   ; void DisassembleInstruction( short int *OpCode)         // pointer to Opcode
                    6187   ; {
                    6188   _DisassembleInstruction:
00003480  4E56 FFD8 6189          link      A6,#-40
00003484  48E7 3F3C 6190          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003488  242E 0008 6191          move.l    8(A6),D2
0000348C  45F9 0B00 6192          lea       _InstructionSize.L,A2
00003490  017E      
00003492  47F8 0CE6 6193          lea       _strcpyInstruction.L,A3
00003496  49F9 0B00 6194          lea       _TempString.L,A4
0000349A  0546      
0000349C  4BF9 0000 6195          lea       _sprintf.L,A5
000034A0  54A8      
                    6196   ; unsigned short int MSBits = (*OpCode >> 12);    //mask off the lower 12 bits leaving top 4 bit to analyse
000034A2  2042      6197          move.l    D2,A0
000034A4  3010      6198          move.w    (A0),D0
000034A6  E040      6199          asr.w     #8,D0
000034A8  E840      6200          asr.w     #4,D0
000034AA  3D40 FFDA 6201          move.w    D0,-38(A6)
                    6202   ; unsigned short int LS12Bits = (*OpCode & (unsigned short int)(0x0FFF));
000034AE  2042      6203          move.l    D2,A0
000034B0  3010      6204          move.w    (A0),D0
000034B2  C07C 0FFF 6205          and.w     #4095,D0
000034B6  3D40 FFDC 6206          move.w    D0,-36(A6)
                    6207   ; unsigned short int SourceBits, DestBits, Size ;
                    6208   ; unsigned char *Mode, Condition;
                    6209   ; unsigned short int Register, OpMode, EAMode, EARegister, Rx, Ry, EXGOpMode, DataSize, SourceReg;
                    6210   ; unsigned short int DataRegister, AddressRegister;
                    6211   ; signed char Displacement8Bit ;  // used for Bcc type instruction signed 8 bit displacement
                    6212   ; signed short int Displacement16Bit;
                    6213   ; short int Mask, DoneSlash;
                    6214   ; int i;
                    6215   ; strcpyInstruction("Unknown") ;
000034BA  4879 0000 6216          pea       @m68kde~2_184.L
000034BE  6FFE      
000034C0  4E93      6217          jsr       (A3)
000034C2  584F      6218          addq.w    #4,A7
                    6219   ; /////////////////////////////////////////////////////////////////////////////////
                    6220   ; // if instruction is ABCD
                    6221   ; /////////////////////////////////////////////////////////////////////////////////
                    6222   ; if((*OpCode & (unsigned short int)(0xF1F0 )) == (unsigned short int)(0xC100))   {
000034C4  2042      6223          move.l    D2,A0
000034C6  3010      6224          move.w    (A0),D0
000034C8  C07C F1F0 6225          and.w     #61936,D0
000034CC  0C40 C100 6226          cmp.w     #49408,D0
000034D0  6600 008C 6227          bne       DisassembleInstruction_4
                    6228   ; DestBits = (*OpCode >> 9) & (unsigned short int )(0x0007) ;
000034D4  2042      6229          move.l    D2,A0
000034D6  3010      6230          move.w    (A0),D0
000034D8  E040      6231          asr.w     #8,D0
000034DA  E240      6232          asr.w     #1,D0
000034DC  C07C 0007 6233          and.w     #7,D0
000034E0  3D40 FFE0 6234          move.w    D0,-32(A6)
                    6235   ; SourceBits = (*OpCode & (unsigned short int )(0x0007));
000034E4  2042      6236          move.l    D2,A0
000034E6  3010      6237          move.w    (A0),D0
000034E8  C07C 0007 6238          and.w     #7,D0
000034EC  3D40 FFDE 6239          move.w    D0,-34(A6)
                    6240   ; Mode = (*OpCode >> 3) & (unsigned short int )(0x0001) ;
000034F0  2042      6241          move.l    D2,A0
000034F2  3010      6242          move.w    (A0),D0
000034F4  E640      6243          asr.w     #3,D0
000034F6  48C0      6244          ext.l     D0
000034F8  C0BC 0000 6245          and.l     #1,D0
000034FC  0001      
000034FE  2D40 FFE4 6246          move.l    D0,-28(A6)
                    6247   ; if(Mode == 0)
00003502  202E FFE4 6248          move.l    -28(A6),D0
00003506  662C      6249          bne.s     DisassembleInstruction_3
                    6250   ; sprintf(Instruction, "ABCD D%d,D%d", SourceBits, DestBits) ;
00003508  322E FFE0 6251          move.w    -32(A6),D1
0000350C  C2BC 0000 6252          and.l     #65535,D1
00003510  FFFF      
00003512  2F01      6253          move.l    D1,-(A7)
00003514  322E FFDE 6254          move.w    -34(A6),D1
00003518  C2BC 0000 6255          and.l     #65535,D1
0000351C  FFFF      
0000351E  2F01      6256          move.l    D1,-(A7)
00003520  4879 0000 6257          pea       @m68kde~2_185.L
00003524  7006      
00003526  4879 0B00 6258          pea       _Instruction.L
0000352A  04E2      
0000352C  4E95      6259          jsr       (A5)
0000352E  DEFC 0010 6260          add.w     #16,A7
00003532  602A      6261          bra.s     DisassembleInstruction_4
                    6262   DisassembleInstruction_3:
                    6263   ; else
                    6264   ; sprintf(Instruction, "ABCD -(A%d),-(A%d)", SourceBits, DestBits) ;
00003534  322E FFE0 6265          move.w    -32(A6),D1
00003538  C2BC 0000 6266          and.l     #65535,D1
0000353C  FFFF      
0000353E  2F01      6267          move.l    D1,-(A7)
00003540  322E FFDE 6268          move.w    -34(A6),D1
00003544  C2BC 0000 6269          and.l     #65535,D1
00003548  FFFF      
0000354A  2F01      6270          move.l    D1,-(A7)
0000354C  4879 0000 6271          pea       @m68kde~2_186.L
00003550  7014      
00003552  4879 0B00 6272          pea       _Instruction.L
00003556  04E2      
00003558  4E95      6273          jsr       (A5)
0000355A  DEFC 0010 6274          add.w     #16,A7
                    6275   DisassembleInstruction_4:
                    6276   ; }
                    6277   ; /////////////////////////////////////////////////////////////////////////////////
                    6278   ; // if instruction is ADD or ADDA
                    6279   ; /////////////////////////////////////////////////////////////////////////////////
                    6280   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xD000))   {
0000355E  2042      6281          move.l    D2,A0
00003560  3010      6282          move.w    (A0),D0
00003562  C07C F000 6283          and.w     #61440,D0
00003566  0C40 D000 6284          cmp.w     #53248,D0
0000356A  6600 008C 6285          bne       DisassembleInstruction_8
                    6286   ; InstructionSize = 1;
0000356E  24BC 0000 6287          move.l    #1,(A2)
00003572  0001      
                    6288   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0007)) ;
00003574  2042      6289          move.l    D2,A0
00003576  3010      6290          move.w    (A0),D0
00003578  EC40      6291          asr.w     #6,D0
0000357A  C07C 0007 6292          and.w     #7,D0
0000357E  3600      6293          move.w    D0,D3
                    6294   ; if( (OpMode == (unsigned short int)(0x0003)) || (OpMode == (unsigned short int)(0x0007)))      // if destination is an address register then use ADDA otherwise use ADD
00003580  0C43 0003 6295          cmp.w     #3,D3
00003584  6708      6296          beq.s     DisassembleInstruction_9
00003586  0C43 0007 6297          cmp.w     #7,D3
0000358A  6600 005A 6298          bne       DisassembleInstruction_7
                    6299   DisassembleInstruction_9:
                    6300   ; {
                    6301   ; if(OpMode == (unsigned short int)(0x0003))
0000358E  0C43 0003 6302          cmp.w     #3,D3
00003592  660C      6303          bne.s     DisassembleInstruction_10
                    6304   ; strcpyInstruction("ADDA.W ") ;
00003594  4879 0000 6305          pea       @m68kde~2_187.L
00003598  7028      
0000359A  4E93      6306          jsr       (A3)
0000359C  584F      6307          addq.w    #4,A7
0000359E  600A      6308          bra.s     DisassembleInstruction_11
                    6309   DisassembleInstruction_10:
                    6310   ; else
                    6311   ; strcpyInstruction("ADDA.L ") ;
000035A0  4879 0000 6312          pea       @m68kde~2_188.L
000035A4  7030      
000035A6  4E93      6313          jsr       (A3)
000035A8  584F      6314          addq.w    #4,A7
                    6315   DisassembleInstruction_11:
                    6316   ; Decode6BitEA(OpCode,0,0,0)  ;
000035AA  42A7      6317          clr.l     -(A7)
000035AC  42A7      6318          clr.l     -(A7)
000035AE  42A7      6319          clr.l     -(A7)
000035B0  2F02      6320          move.l    D2,-(A7)
000035B2  4EB8 2E6C 6321          jsr       _Decode6BitEA
000035B6  DEFC 0010 6322          add.w     #16,A7
                    6323   ; sprintf(TempString, ",A%X", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
000035BA  2042      6324          move.l    D2,A0
000035BC  3210      6325          move.w    (A0),D1
000035BE  E041      6326          asr.w     #8,D1
000035C0  E241      6327          asr.w     #1,D1
000035C2  C27C 0007 6328          and.w     #7,D1
000035C6  C2BC 0000 6329          and.l     #65535,D1
000035CA  FFFF      
000035CC  2F01      6330          move.l    D1,-(A7)
000035CE  4879 0000 6331          pea       @m68kde~2_189.L
000035D2  7038      
000035D4  2F0C      6332          move.l    A4,-(A7)
000035D6  4E95      6333          jsr       (A5)
000035D8  DEFC 000C 6334          add.w     #12,A7
                    6335   ; strcatInstruction(TempString) ;
000035DC  2F0C      6336          move.l    A4,-(A7)
000035DE  4EB8 0CCC 6337          jsr       _strcatInstruction
000035E2  584F      6338          addq.w    #4,A7
000035E4  6012      6339          bra.s     DisassembleInstruction_8
                    6340   DisassembleInstruction_7:
                    6341   ; }
                    6342   ; else {
                    6343   ; strcpyInstruction("ADD") ;
000035E6  4879 0000 6344          pea       @m68kde~2_190.L
000035EA  703E      
000035EC  4E93      6345          jsr       (A3)
000035EE  584F      6346          addq.w    #4,A7
                    6347   ; Decode3BitOperandMode(OpCode) ;
000035F0  2F02      6348          move.l    D2,-(A7)
000035F2  4EB8 3294 6349          jsr       _Decode3BitOperandMode
000035F6  584F      6350          addq.w    #4,A7
                    6351   DisassembleInstruction_8:
                    6352   ; }
                    6353   ; }
                    6354   ; /////////////////////////////////////////////////////////////////////////////////
                    6355   ; // if instruction is ADDI or ANDI or CMPI or EORI or ORI or SUBI
                    6356   ; /////////////////////////////////////////////////////////////////////////////////
                    6357   ; if( (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0600) |
000035F8  2042      6358          move.l    D2,A0
000035FA  3010      6359          move.w    (A0),D0
000035FC  C07C FF00 6360          and.w     #65280,D0
00003600  0C40 0600 6361          cmp.w     #1536,D0
00003604  6604      6362          bne.s     DisassembleInstruction_14
00003606  7001      6363          moveq     #1,D0
00003608  6002      6364          bra.s     DisassembleInstruction_15
                    6365   DisassembleInstruction_14:
0000360A  4280      6366          clr.l     D0
                    6367   DisassembleInstruction_15:
0000360C  2042      6368          move.l    D2,A0
0000360E  3210      6369          move.w    (A0),D1
00003610  C27C FF00 6370          and.w     #65280,D1
00003614  0C41 0200 6371          cmp.w     #512,D1
00003618  6604      6372          bne.s     DisassembleInstruction_16
0000361A  7201      6373          moveq     #1,D1
0000361C  6002      6374          bra.s     DisassembleInstruction_17
                    6375   DisassembleInstruction_16:
0000361E  4281      6376          clr.l     D1
                    6377   DisassembleInstruction_17:
00003620  8041      6378          or.w      D1,D0
00003622  2042      6379          move.l    D2,A0
00003624  3210      6380          move.w    (A0),D1
00003626  C27C FF00 6381          and.w     #65280,D1
0000362A  0C41 0C00 6382          cmp.w     #3072,D1
0000362E  6604      6383          bne.s     DisassembleInstruction_18
00003630  7201      6384          moveq     #1,D1
00003632  6002      6385          bra.s     DisassembleInstruction_19
                    6386   DisassembleInstruction_18:
00003634  4281      6387          clr.l     D1
                    6388   DisassembleInstruction_19:
00003636  8041      6389          or.w      D1,D0
00003638  2042      6390          move.l    D2,A0
0000363A  3210      6391          move.w    (A0),D1
0000363C  C27C FF00 6392          and.w     #65280,D1
00003640  0C41 0A00 6393          cmp.w     #2560,D1
00003644  6604      6394          bne.s     DisassembleInstruction_20
00003646  7201      6395          moveq     #1,D1
00003648  6002      6396          bra.s     DisassembleInstruction_21
                    6397   DisassembleInstruction_20:
0000364A  4281      6398          clr.l     D1
                    6399   DisassembleInstruction_21:
0000364C  8041      6400          or.w      D1,D0
0000364E  2042      6401          move.l    D2,A0
00003650  3210      6402          move.w    (A0),D1
00003652  C27C FF00 6403          and.w     #65280,D1
00003656  6604      6404          bne.s     DisassembleInstruction_22
00003658  7201      6405          moveq     #1,D1
0000365A  6002      6406          bra.s     DisassembleInstruction_23
                    6407   DisassembleInstruction_22:
0000365C  4281      6408          clr.l     D1
                    6409   DisassembleInstruction_23:
0000365E  8041      6410          or.w      D1,D0
00003660  2042      6411          move.l    D2,A0
00003662  3210      6412          move.w    (A0),D1
00003664  C27C FF00 6413          and.w     #65280,D1
00003668  0C41 0400 6414          cmp.w     #1024,D1
0000366C  6604      6415          bne.s     DisassembleInstruction_24
0000366E  7201      6416          moveq     #1,D1
00003670  6002      6417          bra.s     DisassembleInstruction_25
                    6418   DisassembleInstruction_24:
00003672  4281      6419          clr.l     D1
                    6420   DisassembleInstruction_25:
00003674  8041      6421          or.w      D1,D0
00003676  6700 00E4 6422          beq       DisassembleInstruction_12
                    6423   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0200) |
                    6424   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0C00) |
                    6425   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0A00) |
                    6426   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0000) |
                    6427   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0400))
                    6428   ; {
                    6429   ; InstructionSize = 1;
0000367A  24BC 0000 6430          move.l    #1,(A2)
0000367E  0001      
                    6431   ; if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0600))
00003680  2042      6432          move.l    D2,A0
00003682  3010      6433          move.w    (A0),D0
00003684  C07C FF00 6434          and.w     #65280,D0
00003688  0C40 0600 6435          cmp.w     #1536,D0
0000368C  660E      6436          bne.s     DisassembleInstruction_26
                    6437   ; strcpyInstruction("ADDI") ;
0000368E  4879 0000 6438          pea       @m68kde~2_191.L
00003692  7042      
00003694  4E93      6439          jsr       (A3)
00003696  584F      6440          addq.w    #4,A7
00003698  6000 0084 6441          bra       DisassembleInstruction_36
                    6442   DisassembleInstruction_26:
                    6443   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0200))
0000369C  2042      6444          move.l    D2,A0
0000369E  3010      6445          move.w    (A0),D0
000036A0  C07C FF00 6446          and.w     #65280,D0
000036A4  0C40 0200 6447          cmp.w     #512,D0
000036A8  660E      6448          bne.s     DisassembleInstruction_28
                    6449   ; strcpyInstruction("ANDI") ;
000036AA  4879 0000 6450          pea       @m68kde~2_192.L
000036AE  7048      
000036B0  4E93      6451          jsr       (A3)
000036B2  584F      6452          addq.w    #4,A7
000036B4  6000 0068 6453          bra       DisassembleInstruction_36
                    6454   DisassembleInstruction_28:
                    6455   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0C00))
000036B8  2042      6456          move.l    D2,A0
000036BA  3010      6457          move.w    (A0),D0
000036BC  C07C FF00 6458          and.w     #65280,D0
000036C0  0C40 0C00 6459          cmp.w     #3072,D0
000036C4  660E      6460          bne.s     DisassembleInstruction_30
                    6461   ; strcpyInstruction("CMPI") ;
000036C6  4879 0000 6462          pea       @m68kde~2_193.L
000036CA  704E      
000036CC  4E93      6463          jsr       (A3)
000036CE  584F      6464          addq.w    #4,A7
000036D0  6000 004C 6465          bra       DisassembleInstruction_36
                    6466   DisassembleInstruction_30:
                    6467   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0A00))
000036D4  2042      6468          move.l    D2,A0
000036D6  3010      6469          move.w    (A0),D0
000036D8  C07C FF00 6470          and.w     #65280,D0
000036DC  0C40 0A00 6471          cmp.w     #2560,D0
000036E0  660E      6472          bne.s     DisassembleInstruction_32
                    6473   ; strcpyInstruction("EORI") ;
000036E2  4879 0000 6474          pea       @m68kde~2_194.L
000036E6  7054      
000036E8  4E93      6475          jsr       (A3)
000036EA  584F      6476          addq.w    #4,A7
000036EC  6000 0030 6477          bra       DisassembleInstruction_36
                    6478   DisassembleInstruction_32:
                    6479   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0000))
000036F0  2042      6480          move.l    D2,A0
000036F2  3010      6481          move.w    (A0),D0
000036F4  C07C FF00 6482          and.w     #65280,D0
000036F8  660C      6483          bne.s     DisassembleInstruction_34
                    6484   ; strcpyInstruction("ORI") ;
000036FA  4879 0000 6485          pea       @m68kde~2_195.L
000036FE  705A      
00003700  4E93      6486          jsr       (A3)
00003702  584F      6487          addq.w    #4,A7
00003704  6018      6488          bra.s     DisassembleInstruction_36
                    6489   DisassembleInstruction_34:
                    6490   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0400))
00003706  2042      6491          move.l    D2,A0
00003708  3010      6492          move.w    (A0),D0
0000370A  C07C FF00 6493          and.w     #65280,D0
0000370E  0C40 0400 6494          cmp.w     #1024,D0
00003712  660A      6495          bne.s     DisassembleInstruction_36
                    6496   ; strcpyInstruction("SUBI") ;
00003714  4879 0000 6497          pea       @m68kde~2_196.L
00003718  705E      
0000371A  4E93      6498          jsr       (A3)
0000371C  584F      6499          addq.w    #4,A7
                    6500   DisassembleInstruction_36:
                    6501   ; DataSize = Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
0000371E  2042      6502          move.l    D2,A0
00003720  3210      6503          move.w    (A0),D1
00003722  C2BC 0000 6504          and.l     #65535,D1
00003726  FFFF      
00003728  2F01      6505          move.l    D1,-(A7)
0000372A  4EB8 2BD8 6506          jsr       _Decode2BitOperandSize
0000372E  584F      6507          addq.w    #4,A7
00003730  3E00      6508          move.w    D0,D7
                    6509   ; DecodeBWLDataAfterOpCode(OpCode);                                // go add the 8,16,32 bit data to instruction string
00003732  2F02      6510          move.l    D2,-(A7)
00003734  4EB8 2D5C 6511          jsr       _DecodeBWLDataAfterOpCode
00003738  584F      6512          addq.w    #4,A7
                    6513   ; strcatInstruction(",") ;
0000373A  4879 0000 6514          pea       @m68kde~2_167.L
0000373E  6FBC      
00003740  4EB8 0CCC 6515          jsr       _strcatInstruction
00003744  584F      6516          addq.w    #4,A7
                    6517   ; Decode6BitEA(OpCode,0,DataSize,0) ;                                         // decode EA
00003746  42A7      6518          clr.l     -(A7)
00003748  CEBC 0000 6519          and.l     #65535,D7
0000374C  FFFF      
0000374E  2F07      6520          move.l    D7,-(A7)
00003750  42A7      6521          clr.l     -(A7)
00003752  2F02      6522          move.l    D2,-(A7)
00003754  4EB8 2E6C 6523          jsr       _Decode6BitEA
00003758  DEFC 0010 6524          add.w     #16,A7
                    6525   DisassembleInstruction_12:
                    6526   ; }
                    6527   ; /////////////////////////////////////////////////////////////////////////////////
                    6528   ; // if instruction is ADDI #data,SR
                    6529   ; /////////////////////////////////////////////////////////////////////////////////
                    6530   ; if(*OpCode  == (unsigned short int)(0x027c))   {
0000375C  2042      6531          move.l    D2,A0
0000375E  3010      6532          move.w    (A0),D0
00003760  0C40 027C 6533          cmp.w     #636,D0
00003764  6622      6534          bne.s     DisassembleInstruction_38
                    6535   ; InstructionSize = 2;
00003766  24BC 0000 6536          move.l    #2,(A2)
0000376A  0002      
                    6537   ; sprintf(Instruction, "ANDI #$%X,SR", OpCode[1]);
0000376C  2042      6538          move.l    D2,A0
0000376E  3228 0002 6539          move.w    2(A0),D1
00003772  48C1      6540          ext.l     D1
00003774  2F01      6541          move.l    D1,-(A7)
00003776  4879 0000 6542          pea       @m68kde~2_197.L
0000377A  7064      
0000377C  4879 0B00 6543          pea       _Instruction.L
00003780  04E2      
00003782  4E95      6544          jsr       (A5)
00003784  DEFC 000C 6545          add.w     #12,A7
                    6546   DisassembleInstruction_38:
                    6547   ; }
                    6548   ; /////////////////////////////////////////////////////////////////////////////////
                    6549   ; // if instruction is ADDQ
                    6550   ; /////////////////////////////////////////////////////////////////////////////////
                    6551   ; if((*OpCode & (unsigned short int)(0xF100 )) == (unsigned short int)(0x5000))   {
00003788  2042      6552          move.l    D2,A0
0000378A  3010      6553          move.w    (A0),D0
0000378C  C07C F100 6554          and.w     #61696,D0
00003790  0C40 5000 6555          cmp.w     #20480,D0
00003794  6600 005E 6556          bne       DisassembleInstruction_40
                    6557   ; InstructionSize = 1;
00003798  24BC 0000 6558          move.l    #1,(A2)
0000379C  0001      
                    6559   ; strcpyInstruction("ADDQ") ;
0000379E  4879 0000 6560          pea       @m68kde~2_198.L
000037A2  7072      
000037A4  4E93      6561          jsr       (A3)
000037A6  584F      6562          addq.w    #4,A7
                    6563   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
000037A8  2042      6564          move.l    D2,A0
000037AA  3210      6565          move.w    (A0),D1
000037AC  C2BC 0000 6566          and.l     #65535,D1
000037B0  FFFF      
000037B2  2F01      6567          move.l    D1,-(A7)
000037B4  4EB8 2BD8 6568          jsr       _Decode2BitOperandSize
000037B8  584F      6569          addq.w    #4,A7
                    6570   ; sprintf(TempString, "#%1X,", ((*OpCode >> 9) & (unsigned short int)(0x0007)));    // print 3 bit #data in positions 11,10,9 in opcode
000037BA  2042      6571          move.l    D2,A0
000037BC  3210      6572          move.w    (A0),D1
000037BE  E041      6573          asr.w     #8,D1
000037C0  E241      6574          asr.w     #1,D1
000037C2  C27C 0007 6575          and.w     #7,D1
000037C6  C2BC 0000 6576          and.l     #65535,D1
000037CA  FFFF      
000037CC  2F01      6577          move.l    D1,-(A7)
000037CE  4879 0000 6578          pea       @m68kde~2_199.L
000037D2  7078      
000037D4  2F0C      6579          move.l    A4,-(A7)
000037D6  4E95      6580          jsr       (A5)
000037D8  DEFC 000C 6581          add.w     #12,A7
                    6582   ; strcatInstruction(TempString) ;
000037DC  2F0C      6583          move.l    A4,-(A7)
000037DE  4EB8 0CCC 6584          jsr       _strcatInstruction
000037E2  584F      6585          addq.w    #4,A7
                    6586   ; Decode6BitEA(OpCode,0,0,0) ;                                           // decode EA
000037E4  42A7      6587          clr.l     -(A7)
000037E6  42A7      6588          clr.l     -(A7)
000037E8  42A7      6589          clr.l     -(A7)
000037EA  2F02      6590          move.l    D2,-(A7)
000037EC  4EB8 2E6C 6591          jsr       _Decode6BitEA
000037F0  DEFC 0010 6592          add.w     #16,A7
                    6593   DisassembleInstruction_40:
                    6594   ; }
                    6595   ; /////////////////////////////////////////////////////////////////////////////////
                    6596   ; // if instruction is ADDX
                    6597   ; /////////////////////////////////////////////////////////////////////////////////
                    6598   ; if((*OpCode & (unsigned short int)(0xF130 )) == (unsigned short int)(0xD100))   {
000037F4  2042      6599          move.l    D2,A0
000037F6  3010      6600          move.w    (A0),D0
000037F8  C07C F130 6601          and.w     #61744,D0
000037FC  0C40 D100 6602          cmp.w     #53504,D0
00003800  6600 00A4 6603          bne       DisassembleInstruction_44
                    6604   ; InstructionSize = 1;
00003804  24BC 0000 6605          move.l    #1,(A2)
00003808  0001      
                    6606   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0003)) ;
0000380A  2042      6607          move.l    D2,A0
0000380C  3010      6608          move.w    (A0),D0
0000380E  EC40      6609          asr.w     #6,D0
00003810  C07C 0003 6610          and.w     #3,D0
00003814  3600      6611          move.w    D0,D3
                    6612   ; if(OpMode != (unsigned short int)(0x0003)) // if size = 11 then it's ADDA not ADDX
00003816  0C43 0003 6613          cmp.w     #3,D3
0000381A  6700 008A 6614          beq       DisassembleInstruction_44
                    6615   ; {
                    6616   ; strcpyInstruction("ADDX") ;
0000381E  4879 0000 6617          pea       @m68kde~2_200.L
00003822  707E      
00003824  4E93      6618          jsr       (A3)
00003826  584F      6619          addq.w    #4,A7
                    6620   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
00003828  2042      6621          move.l    D2,A0
0000382A  3210      6622          move.w    (A0),D1
0000382C  C2BC 0000 6623          and.l     #65535,D1
00003830  FFFF      
00003832  2F01      6624          move.l    D1,-(A7)
00003834  4EB8 2BD8 6625          jsr       _Decode2BitOperandSize
00003838  584F      6626          addq.w    #4,A7
                    6627   ; if((*OpCode & (unsigned short int)(0x0008)) == (unsigned short int)(0))    // if bit 3 of opcode is 0 indicates data registers are used as source and destination
0000383A  2042      6628          move.l    D2,A0
0000383C  3010      6629          move.w    (A0),D0
0000383E  C07C 0008 6630          and.w     #8,D0
00003842  6600 0030 6631          bne       DisassembleInstruction_46
                    6632   ; sprintf(TempString, "D%X,D%X", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
00003846  2042      6633          move.l    D2,A0
00003848  3210      6634          move.w    (A0),D1
0000384A  E041      6635          asr.w     #8,D1
0000384C  E241      6636          asr.w     #1,D1
0000384E  C27C 0007 6637          and.w     #7,D1
00003852  48C1      6638          ext.l     D1
00003854  2F01      6639          move.l    D1,-(A7)
00003856  2042      6640          move.l    D2,A0
00003858  3210      6641          move.w    (A0),D1
0000385A  C27C 0007 6642          and.w     #7,D1
0000385E  48C1      6643          ext.l     D1
00003860  2F01      6644          move.l    D1,-(A7)
00003862  4879 0000 6645          pea       @m68kde~2_201.L
00003866  7084      
00003868  2F0C      6646          move.l    A4,-(A7)
0000386A  4E95      6647          jsr       (A5)
0000386C  DEFC 0010 6648          add.w     #16,A7
00003870  6000 002C 6649          bra       DisassembleInstruction_47
                    6650   DisassembleInstruction_46:
                    6651   ; else        // -(ax),-(ay) mode used
                    6652   ; sprintf(TempString, "-(A%X),-(A%X)", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
00003874  2042      6653          move.l    D2,A0
00003876  3210      6654          move.w    (A0),D1
00003878  E041      6655          asr.w     #8,D1
0000387A  E241      6656          asr.w     #1,D1
0000387C  C27C 0007 6657          and.w     #7,D1
00003880  48C1      6658          ext.l     D1
00003882  2F01      6659          move.l    D1,-(A7)
00003884  2042      6660          move.l    D2,A0
00003886  3210      6661          move.w    (A0),D1
00003888  C27C 0007 6662          and.w     #7,D1
0000388C  48C1      6663          ext.l     D1
0000388E  2F01      6664          move.l    D1,-(A7)
00003890  4879 0000 6665          pea       @m68kde~2_202.L
00003894  708C      
00003896  2F0C      6666          move.l    A4,-(A7)
00003898  4E95      6667          jsr       (A5)
0000389A  DEFC 0010 6668          add.w     #16,A7
                    6669   DisassembleInstruction_47:
                    6670   ; strcatInstruction(TempString) ;
0000389E  2F0C      6671          move.l    A4,-(A7)
000038A0  4EB8 0CCC 6672          jsr       _strcatInstruction
000038A4  584F      6673          addq.w    #4,A7
                    6674   DisassembleInstruction_44:
                    6675   ; }
                    6676   ; }
                    6677   ; /////////////////////////////////////////////////////////////////////////////////
                    6678   ; // if instruction is AND
                    6679   ; /////////////////////////////////////////////////////////////////////////////////
                    6680   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xC000))   {
000038A6  2042      6681          move.l    D2,A0
000038A8  3010      6682          move.w    (A0),D0
000038AA  C07C F000 6683          and.w     #61440,D0
000038AE  0C40 C000 6684          cmp.w     #49152,D0
000038B2  662A      6685          bne.s     DisassembleInstruction_50
                    6686   ; InstructionSize = 1;
000038B4  24BC 0000 6687          move.l    #1,(A2)
000038B8  0001      
                    6688   ; // need to differentiate between AND and ABCD using Mode bits in 5,4,3
                    6689   ; OpMode = (*OpCode >> 4) & (unsigned short int)(0x001F);
000038BA  2042      6690          move.l    D2,A0
000038BC  3010      6691          move.w    (A0),D0
000038BE  E840      6692          asr.w     #4,D0
000038C0  C07C 001F 6693          and.w     #31,D0
000038C4  3600      6694          move.w    D0,D3
                    6695   ; if(OpMode != (unsigned short int)(0x0010))   {
000038C6  0C43 0010 6696          cmp.w     #16,D3
000038CA  6712      6697          beq.s     DisassembleInstruction_50
                    6698   ; strcpyInstruction("AND") ;
000038CC  4879 0000 6699          pea       @m68kde~2_203.L
000038D0  709A      
000038D2  4E93      6700          jsr       (A3)
000038D4  584F      6701          addq.w    #4,A7
                    6702   ; Decode3BitOperandMode(OpCode) ;
000038D6  2F02      6703          move.l    D2,-(A7)
000038D8  4EB8 3294 6704          jsr       _Decode3BitOperandMode
000038DC  584F      6705          addq.w    #4,A7
                    6706   DisassembleInstruction_50:
                    6707   ; }
                    6708   ; }
                    6709   ; /////////////////////////////////////////////////////////////////////////////////
                    6710   ; // if instruction is ANDI to CCR
                    6711   ; /////////////////////////////////////////////////////////////////////////////////
                    6712   ; if(*OpCode == (unsigned short int)(0x023C))   {
000038DE  2042      6713          move.l    D2,A0
000038E0  3010      6714          move.w    (A0),D0
000038E2  0C40 023C 6715          cmp.w     #572,D0
000038E6  662A      6716          bne.s     DisassembleInstruction_52
                    6717   ; sprintf(Instruction, "ANDI #$%2X,CCR", OpCode[1] & (unsigned short int)(0x00FF)) ;
000038E8  2042      6718          move.l    D2,A0
000038EA  3228 0002 6719          move.w    2(A0),D1
000038EE  C27C 00FF 6720          and.w     #255,D1
000038F2  C2BC 0000 6721          and.l     #65535,D1
000038F6  FFFF      
000038F8  2F01      6722          move.l    D1,-(A7)
000038FA  4879 0000 6723          pea       @m68kde~2_204.L
000038FE  709E      
00003900  4879 0B00 6724          pea       _Instruction.L
00003904  04E2      
00003906  4E95      6725          jsr       (A5)
00003908  DEFC 000C 6726          add.w     #12,A7
                    6727   ; InstructionSize = 2;
0000390C  24BC 0000 6728          move.l    #2,(A2)
00003910  0002      
                    6729   DisassembleInstruction_52:
                    6730   ; }
                    6731   ; /////////////////////////////////////////////////////////////////////////////////
                    6732   ; // if instruction is ASL/ASR/LSL/LSR/ROL/ROR NOTE two versions of this with different OPCodes
                    6733   ; /////////////////////////////////////////////////////////////////////////////////
                    6734   ; if( ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE000)) |   // ASL/ASR
00003912  2042      6735          move.l    D2,A0
00003914  3010      6736          move.w    (A0),D0
00003916  C07C F018 6737          and.w     #61464,D0
0000391A  0C40 E000 6738          cmp.w     #57344,D0
0000391E  6604      6739          bne.s     DisassembleInstruction_56
00003920  7001      6740          moveq     #1,D0
00003922  6002      6741          bra.s     DisassembleInstruction_57
                    6742   DisassembleInstruction_56:
00003924  4280      6743          clr.l     D0
                    6744   DisassembleInstruction_57:
00003926  2042      6745          move.l    D2,A0
00003928  3210      6746          move.w    (A0),D1
0000392A  C27C FEC0 6747          and.w     #65216,D1
0000392E  0C41 E0C0 6748          cmp.w     #57536,D1
00003932  6604      6749          bne.s     DisassembleInstruction_58
00003934  7201      6750          moveq     #1,D1
00003936  6002      6751          bra.s     DisassembleInstruction_59
                    6752   DisassembleInstruction_58:
00003938  4281      6753          clr.l     D1
                    6754   DisassembleInstruction_59:
0000393A  8041      6755          or.w      D1,D0
0000393C  2042      6756          move.l    D2,A0
0000393E  3210      6757          move.w    (A0),D1
00003940  C27C F018 6758          and.w     #61464,D1
00003944  0C41 E008 6759          cmp.w     #57352,D1
00003948  6604      6760          bne.s     DisassembleInstruction_60
0000394A  7201      6761          moveq     #1,D1
0000394C  6002      6762          bra.s     DisassembleInstruction_61
                    6763   DisassembleInstruction_60:
0000394E  4281      6764          clr.l     D1
                    6765   DisassembleInstruction_61:
00003950  8041      6766          or.w      D1,D0
00003952  2042      6767          move.l    D2,A0
00003954  3210      6768          move.w    (A0),D1
00003956  C27C FEC0 6769          and.w     #65216,D1
0000395A  0C41 E2C0 6770          cmp.w     #58048,D1
0000395E  6604      6771          bne.s     DisassembleInstruction_62
00003960  7201      6772          moveq     #1,D1
00003962  6002      6773          bra.s     DisassembleInstruction_63
                    6774   DisassembleInstruction_62:
00003964  4281      6775          clr.l     D1
                    6776   DisassembleInstruction_63:
00003966  8041      6777          or.w      D1,D0
00003968  2042      6778          move.l    D2,A0
0000396A  3210      6779          move.w    (A0),D1
0000396C  C27C F018 6780          and.w     #61464,D1
00003970  0C41 E018 6781          cmp.w     #57368,D1
00003974  6604      6782          bne.s     DisassembleInstruction_64
00003976  7201      6783          moveq     #1,D1
00003978  6002      6784          bra.s     DisassembleInstruction_65
                    6785   DisassembleInstruction_64:
0000397A  4281      6786          clr.l     D1
                    6787   DisassembleInstruction_65:
0000397C  8041      6788          or.w      D1,D0
0000397E  2042      6789          move.l    D2,A0
00003980  3210      6790          move.w    (A0),D1
00003982  C27C FEC0 6791          and.w     #65216,D1
00003986  0C41 E6C0 6792          cmp.w     #59072,D1
0000398A  6604      6793          bne.s     DisassembleInstruction_66
0000398C  7201      6794          moveq     #1,D1
0000398E  6002      6795          bra.s     DisassembleInstruction_67
                    6796   DisassembleInstruction_66:
00003990  4281      6797          clr.l     D1
                    6798   DisassembleInstruction_67:
00003992  8041      6799          or.w      D1,D0
00003994  2042      6800          move.l    D2,A0
00003996  3210      6801          move.w    (A0),D1
00003998  C27C F018 6802          and.w     #61464,D1
0000399C  0C41 E010 6803          cmp.w     #57360,D1
000039A0  6604      6804          bne.s     DisassembleInstruction_68
000039A2  7201      6805          moveq     #1,D1
000039A4  6002      6806          bra.s     DisassembleInstruction_69
                    6807   DisassembleInstruction_68:
000039A6  4281      6808          clr.l     D1
                    6809   DisassembleInstruction_69:
000039A8  8041      6810          or.w      D1,D0
000039AA  2042      6811          move.l    D2,A0
000039AC  3210      6812          move.w    (A0),D1
000039AE  C27C FEC0 6813          and.w     #65216,D1
000039B2  0C41 E4C0 6814          cmp.w     #58560,D1
000039B6  6604      6815          bne.s     DisassembleInstruction_70
000039B8  7201      6816          moveq     #1,D1
000039BA  6002      6817          bra.s     DisassembleInstruction_71
                    6818   DisassembleInstruction_70:
000039BC  4281      6819          clr.l     D1
                    6820   DisassembleInstruction_71:
000039BE  8041      6821          or.w      D1,D0
000039C0  6700 0252 6822          beq       DisassembleInstruction_73
                    6823   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE0C0)) |
                    6824   ; ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE008)) |   // LSL/LSR
                    6825   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE2C0)) |
                    6826   ; ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE018)) |   // ROR/ROL
                    6827   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE6C0)) |
                    6828   ; ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE010)) |   // ROXR/ROXL
                    6829   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE4C0)))
                    6830   ; {
                    6831   ; InstructionSize = 1;
000039C4  24BC 0000 6832          move.l    #1,(A2)
000039C8  0001      
                    6833   ; // 2nd version e.g. ASR/ASL/LSR/LSL/ROR/ROL/ROXL/ROXR <EA> shift a word 1 bit
                    6834   ; if((*OpCode & (unsigned short int)(0x00C0)) == (unsigned short int)(0x00C0)) // if bits 7,6 == 1,1
000039CA  2042      6835          move.l    D2,A0
000039CC  3010      6836          move.w    (A0),D0
000039CE  C07C 00C0 6837          and.w     #192,D0
000039D2  0C40 00C0 6838          cmp.w     #192,D0
000039D6  6600 00EA 6839          bne       DisassembleInstruction_72
                    6840   ; {
                    6841   ; // test direction by testing bit 8
                    6842   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE0C0))    //asr/asl
000039DA  2042      6843          move.l    D2,A0
000039DC  3010      6844          move.w    (A0),D0
000039DE  C07C FEC0 6845          and.w     #65216,D0
000039E2  0C40 E0C0 6846          cmp.w     #57536,D0
000039E6  6624      6847          bne.s     DisassembleInstruction_77
                    6848   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
000039E8  2042      6849          move.l    D2,A0
000039EA  3010      6850          move.w    (A0),D0
000039EC  C07C 0100 6851          and.w     #256,D0
000039F0  0C40 0100 6852          cmp.w     #256,D0
000039F4  660C      6853          bne.s     DisassembleInstruction_76
                    6854   ; strcpyInstruction("ASL") ;
000039F6  4879 0000 6855          pea       @m68kde~2_205.L
000039FA  70AE      
000039FC  4E93      6856          jsr       (A3)
000039FE  584F      6857          addq.w    #4,A7
00003A00  600A      6858          bra.s     DisassembleInstruction_77
                    6859   DisassembleInstruction_76:
                    6860   ; else
                    6861   ; strcpyInstruction("ASR") ;
00003A02  4879 0000 6862          pea       @m68kde~2_206.L
00003A06  70B2      
00003A08  4E93      6863          jsr       (A3)
00003A0A  584F      6864          addq.w    #4,A7
                    6865   DisassembleInstruction_77:
                    6866   ; // test direction by testing bit 8
                    6867   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE2C0))    //lsr/lsl
00003A0C  2042      6868          move.l    D2,A0
00003A0E  3010      6869          move.w    (A0),D0
00003A10  C07C FEC0 6870          and.w     #65216,D0
00003A14  0C40 E2C0 6871          cmp.w     #58048,D0
00003A18  6624      6872          bne.s     DisassembleInstruction_81
                    6873   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003A1A  2042      6874          move.l    D2,A0
00003A1C  3010      6875          move.w    (A0),D0
00003A1E  C07C 0100 6876          and.w     #256,D0
00003A22  0C40 0100 6877          cmp.w     #256,D0
00003A26  660C      6878          bne.s     DisassembleInstruction_80
                    6879   ; strcpyInstruction("LSL") ;
00003A28  4879 0000 6880          pea       @m68kde~2_207.L
00003A2C  70B6      
00003A2E  4E93      6881          jsr       (A3)
00003A30  584F      6882          addq.w    #4,A7
00003A32  600A      6883          bra.s     DisassembleInstruction_81
                    6884   DisassembleInstruction_80:
                    6885   ; else
                    6886   ; strcpyInstruction("LSR") ;
00003A34  4879 0000 6887          pea       @m68kde~2_208.L
00003A38  70BA      
00003A3A  4E93      6888          jsr       (A3)
00003A3C  584F      6889          addq.w    #4,A7
                    6890   DisassembleInstruction_81:
                    6891   ; // test direction by testing bit 8
                    6892   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE6C0))    //ror/rol
00003A3E  2042      6893          move.l    D2,A0
00003A40  3010      6894          move.w    (A0),D0
00003A42  C07C FEC0 6895          and.w     #65216,D0
00003A46  0C40 E6C0 6896          cmp.w     #59072,D0
00003A4A  6624      6897          bne.s     DisassembleInstruction_85
                    6898   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003A4C  2042      6899          move.l    D2,A0
00003A4E  3010      6900          move.w    (A0),D0
00003A50  C07C 0100 6901          and.w     #256,D0
00003A54  0C40 0100 6902          cmp.w     #256,D0
00003A58  660C      6903          bne.s     DisassembleInstruction_84
                    6904   ; strcpyInstruction("ROL") ;
00003A5A  4879 0000 6905          pea       @m68kde~2_209.L
00003A5E  70BE      
00003A60  4E93      6906          jsr       (A3)
00003A62  584F      6907          addq.w    #4,A7
00003A64  600A      6908          bra.s     DisassembleInstruction_85
                    6909   DisassembleInstruction_84:
                    6910   ; else
                    6911   ; strcpyInstruction("ROR") ;
00003A66  4879 0000 6912          pea       @m68kde~2_210.L
00003A6A  70C2      
00003A6C  4E93      6913          jsr       (A3)
00003A6E  584F      6914          addq.w    #4,A7
                    6915   DisassembleInstruction_85:
                    6916   ; // test direction by testing bit 8
                    6917   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE4C0))    //roxr/roxl
00003A70  2042      6918          move.l    D2,A0
00003A72  3010      6919          move.w    (A0),D0
00003A74  C07C FEC0 6920          and.w     #65216,D0
00003A78  0C40 E4C0 6921          cmp.w     #58560,D0
00003A7C  6624      6922          bne.s     DisassembleInstruction_89
                    6923   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003A7E  2042      6924          move.l    D2,A0
00003A80  3010      6925          move.w    (A0),D0
00003A82  C07C 0100 6926          and.w     #256,D0
00003A86  0C40 0100 6927          cmp.w     #256,D0
00003A8A  660C      6928          bne.s     DisassembleInstruction_88
                    6929   ; strcpyInstruction("ROXL") ;
00003A8C  4879 0000 6930          pea       @m68kde~2_211.L
00003A90  70C6      
00003A92  4E93      6931          jsr       (A3)
00003A94  584F      6932          addq.w    #4,A7
00003A96  600A      6933          bra.s     DisassembleInstruction_89
                    6934   DisassembleInstruction_88:
                    6935   ; else
                    6936   ; strcpyInstruction("ROXR") ;
00003A98  4879 0000 6937          pea       @m68kde~2_212.L
00003A9C  70CC      
00003A9E  4E93      6938          jsr       (A3)
00003AA0  584F      6939          addq.w    #4,A7
                    6940   DisassembleInstruction_89:
                    6941   ; strcatInstruction("  ") ;
00003AA2  4879 0000 6942          pea       @m68kde~2_15.L
00003AA6  5FD8      
00003AA8  4EB8 0CCC 6943          jsr       _strcatInstruction
00003AAC  584F      6944          addq.w    #4,A7
                    6945   ; Decode6BitEA(OpCode,0, 0,0) ;
00003AAE  42A7      6946          clr.l     -(A7)
00003AB0  42A7      6947          clr.l     -(A7)
00003AB2  42A7      6948          clr.l     -(A7)
00003AB4  2F02      6949          move.l    D2,-(A7)
00003AB6  4EB8 2E6C 6950          jsr       _Decode6BitEA
00003ABA  DEFC 0010 6951          add.w     #16,A7
00003ABE  6000 0154 6952          bra       DisassembleInstruction_73
                    6953   DisassembleInstruction_72:
                    6954   ; }
                    6955   ; // first version of above instructions, bit 5 is 0
                    6956   ; else
                    6957   ; {
                    6958   ; // test instruction and direction by testing bits 4,3
                    6959   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0))    //asr/asl
00003AC2  2042      6960          move.l    D2,A0
00003AC4  3010      6961          move.w    (A0),D0
00003AC6  C07C 0018 6962          and.w     #24,D0
00003ACA  6624      6963          bne.s     DisassembleInstruction_93
                    6964   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003ACC  2042      6965          move.l    D2,A0
00003ACE  3010      6966          move.w    (A0),D0
00003AD0  C07C 0100 6967          and.w     #256,D0
00003AD4  0C40 0100 6968          cmp.w     #256,D0
00003AD8  660C      6969          bne.s     DisassembleInstruction_92
                    6970   ; strcpyInstruction("ASL") ;
00003ADA  4879 0000 6971          pea       @m68kde~2_205.L
00003ADE  70AE      
00003AE0  4E93      6972          jsr       (A3)
00003AE2  584F      6973          addq.w    #4,A7
00003AE4  600A      6974          bra.s     DisassembleInstruction_93
                    6975   DisassembleInstruction_92:
                    6976   ; else
                    6977   ; strcpyInstruction("ASR") ;
00003AE6  4879 0000 6978          pea       @m68kde~2_206.L
00003AEA  70B2      
00003AEC  4E93      6979          jsr       (A3)
00003AEE  584F      6980          addq.w    #4,A7
                    6981   DisassembleInstruction_93:
                    6982   ; // test instruction and direction by testing bits 4,3
                    6983   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0008))    //lsr/lsl
00003AF0  2042      6984          move.l    D2,A0
00003AF2  3010      6985          move.w    (A0),D0
00003AF4  C07C 0018 6986          and.w     #24,D0
00003AF8  0C40 0008 6987          cmp.w     #8,D0
00003AFC  6624      6988          bne.s     DisassembleInstruction_97
                    6989   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003AFE  2042      6990          move.l    D2,A0
00003B00  3010      6991          move.w    (A0),D0
00003B02  C07C 0100 6992          and.w     #256,D0
00003B06  0C40 0100 6993          cmp.w     #256,D0
00003B0A  660C      6994          bne.s     DisassembleInstruction_96
                    6995   ; strcpyInstruction("LSL") ;
00003B0C  4879 0000 6996          pea       @m68kde~2_207.L
00003B10  70B6      
00003B12  4E93      6997          jsr       (A3)
00003B14  584F      6998          addq.w    #4,A7
00003B16  600A      6999          bra.s     DisassembleInstruction_97
                    7000   DisassembleInstruction_96:
                    7001   ; else
                    7002   ; strcpyInstruction("LSR") ;
00003B18  4879 0000 7003          pea       @m68kde~2_208.L
00003B1C  70BA      
00003B1E  4E93      7004          jsr       (A3)
00003B20  584F      7005          addq.w    #4,A7
                    7006   DisassembleInstruction_97:
                    7007   ; // test instruction and direction by testing bits 4,3
                    7008   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0018))    //ror/rol
00003B22  2042      7009          move.l    D2,A0
00003B24  3010      7010          move.w    (A0),D0
00003B26  C07C 0018 7011          and.w     #24,D0
00003B2A  0C40 0018 7012          cmp.w     #24,D0
00003B2E  6624      7013          bne.s     DisassembleInstruction_101
                    7014   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003B30  2042      7015          move.l    D2,A0
00003B32  3010      7016          move.w    (A0),D0
00003B34  C07C 0100 7017          and.w     #256,D0
00003B38  0C40 0100 7018          cmp.w     #256,D0
00003B3C  660C      7019          bne.s     DisassembleInstruction_100
                    7020   ; strcpyInstruction("ROL") ;
00003B3E  4879 0000 7021          pea       @m68kde~2_209.L
00003B42  70BE      
00003B44  4E93      7022          jsr       (A3)
00003B46  584F      7023          addq.w    #4,A7
00003B48  600A      7024          bra.s     DisassembleInstruction_101
                    7025   DisassembleInstruction_100:
                    7026   ; else
                    7027   ; strcpyInstruction("ROR") ;
00003B4A  4879 0000 7028          pea       @m68kde~2_210.L
00003B4E  70C2      
00003B50  4E93      7029          jsr       (A3)
00003B52  584F      7030          addq.w    #4,A7
                    7031   DisassembleInstruction_101:
                    7032   ; // test instruction and direction by testing bits 4,3
                    7033   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0010))    //roxr/roxl
00003B54  2042      7034          move.l    D2,A0
00003B56  3010      7035          move.w    (A0),D0
00003B58  C07C 0018 7036          and.w     #24,D0
00003B5C  0C40 0010 7037          cmp.w     #16,D0
00003B60  6624      7038          bne.s     DisassembleInstruction_105
                    7039   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003B62  2042      7040          move.l    D2,A0
00003B64  3010      7041          move.w    (A0),D0
00003B66  C07C 0100 7042          and.w     #256,D0
00003B6A  0C40 0100 7043          cmp.w     #256,D0
00003B6E  660C      7044          bne.s     DisassembleInstruction_104
                    7045   ; strcpyInstruction("ROXL") ;
00003B70  4879 0000 7046          pea       @m68kde~2_211.L
00003B74  70C6      
00003B76  4E93      7047          jsr       (A3)
00003B78  584F      7048          addq.w    #4,A7
00003B7A  600A      7049          bra.s     DisassembleInstruction_105
                    7050   DisassembleInstruction_104:
                    7051   ; else
                    7052   ; strcpyInstruction("ROXR") ;
00003B7C  4879 0000 7053          pea       @m68kde~2_212.L
00003B80  70CC      
00003B82  4E93      7054          jsr       (A3)
00003B84  584F      7055          addq.w    #4,A7
                    7056   DisassembleInstruction_105:
                    7057   ; Decode2BitOperandSize(*OpCode) ;
00003B86  2042      7058          move.l    D2,A0
00003B88  3210      7059          move.w    (A0),D1
00003B8A  C2BC 0000 7060          and.l     #65535,D1
00003B8E  FFFF      
00003B90  2F01      7061          move.l    D1,-(A7)
00003B92  4EB8 2BD8 7062          jsr       _Decode2BitOperandSize
00003B96  584F      7063          addq.w    #4,A7
                    7064   ; if((*OpCode & (unsigned short int)(0x0020)) == (unsigned short int)(0)) {   // if shift count defined by #value (bit 5 = 0), e.g. asl #3,d0
00003B98  2042      7065          move.l    D2,A0
00003B9A  3010      7066          move.w    (A0),D0
00003B9C  C07C 0020 7067          and.w     #32,D0
00003BA0  6600 0038 7068          bne       DisassembleInstruction_106
                    7069   ; sprintf(TempString,"#$%X,D%X",
00003BA4  2042      7070          move.l    D2,A0
00003BA6  3210      7071          move.w    (A0),D1
00003BA8  C27C 0007 7072          and.w     #7,D1
00003BAC  C2BC 0000 7073          and.l     #65535,D1
00003BB0  FFFF      
00003BB2  2F01      7074          move.l    D1,-(A7)
00003BB4  2042      7075          move.l    D2,A0
00003BB6  3210      7076          move.w    (A0),D1
00003BB8  E041      7077          asr.w     #8,D1
00003BBA  E241      7078          asr.w     #1,D1
00003BBC  C27C 0007 7079          and.w     #7,D1
00003BC0  C2BC 0000 7080          and.l     #65535,D1
00003BC4  FFFF      
00003BC6  2F01      7081          move.l    D1,-(A7)
00003BC8  4879 0000 7082          pea       @m68kde~2_213.L
00003BCC  70D2      
00003BCE  2F0C      7083          move.l    A4,-(A7)
00003BD0  4E95      7084          jsr       (A5)
00003BD2  DEFC 0010 7085          add.w     #16,A7
00003BD6  6000 0034 7086          bra       DisassembleInstruction_107
                    7087   DisassembleInstruction_106:
                    7088   ; ((*OpCode >> 9) & (unsigned short int)(0x0007)),
                    7089   ; (*OpCode & (unsigned short int)(0x0007))) ;
                    7090   ; }
                    7091   ; else {                                                                      // if shift is for example ASR D1,D2
                    7092   ; sprintf(TempString,"D%X,D%X",
00003BDA  2042      7093          move.l    D2,A0
00003BDC  3210      7094          move.w    (A0),D1
00003BDE  C27C 0007 7095          and.w     #7,D1
00003BE2  C2BC 0000 7096          and.l     #65535,D1
00003BE6  FFFF      
00003BE8  2F01      7097          move.l    D1,-(A7)
00003BEA  2042      7098          move.l    D2,A0
00003BEC  3210      7099          move.w    (A0),D1
00003BEE  E041      7100          asr.w     #8,D1
00003BF0  E241      7101          asr.w     #1,D1
00003BF2  C27C 0007 7102          and.w     #7,D1
00003BF6  C2BC 0000 7103          and.l     #65535,D1
00003BFA  FFFF      
00003BFC  2F01      7104          move.l    D1,-(A7)
00003BFE  4879 0000 7105          pea       @m68kde~2_201.L
00003C02  7084      
00003C04  2F0C      7106          move.l    A4,-(A7)
00003C06  4E95      7107          jsr       (A5)
00003C08  DEFC 0010 7108          add.w     #16,A7
                    7109   DisassembleInstruction_107:
                    7110   ; ((*OpCode >> 9) & (unsigned short int)(0x0007)),
                    7111   ; (*OpCode & (unsigned short int)(0x0007))) ;
                    7112   ; }
                    7113   ; strcatInstruction(TempString) ;
00003C0C  2F0C      7114          move.l    A4,-(A7)
00003C0E  4EB8 0CCC 7115          jsr       _strcatInstruction
00003C12  584F      7116          addq.w    #4,A7
                    7117   DisassembleInstruction_73:
                    7118   ; }
                    7119   ; }
                    7120   ; /////////////////////////////////////////////////////////////////////////////////
                    7121   ; // if instruction is BCC and BSR and BRA
                    7122   ; /////////////////////////////////////////////////////////////////////////////////
                    7123   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0x6000))
00003C14  2042      7124          move.l    D2,A0
00003C16  3010      7125          move.w    (A0),D0
00003C18  C07C F000 7126          and.w     #61440,D0
00003C1C  0C40 6000 7127          cmp.w     #24576,D0
00003C20  6600 00A0 7128          bne       DisassembleInstruction_108
                    7129   ; {
                    7130   ; InstructionSize = 1;
00003C24  24BC 0000 7131          move.l    #1,(A2)
00003C28  0001      
                    7132   ; Condition = ((*OpCode >> 8) & (unsigned short int)(0xF)) ;
00003C2A  2042      7133          move.l    D2,A0
00003C2C  3010      7134          move.w    (A0),D0
00003C2E  E040      7135          asr.w     #8,D0
00003C30  C07C 000F 7136          and.w     #15,D0
00003C34  1D40 FFE9 7137          move.b    D0,-23(A6)
                    7138   ; strcpyInstruction("B") ;
00003C38  4879 0000 7139          pea       @m68kde~2_214.L
00003C3C  70DC      
00003C3E  4E93      7140          jsr       (A3)
00003C40  584F      7141          addq.w    #4,A7
                    7142   ; DecodeBranchCondition(Condition) ;
00003C42  122E FFE9 7143          move.b    -23(A6),D1
00003C46  C27C 00FF 7144          and.w     #255,D1
00003C4A  C2BC 0000 7145          and.l     #65535,D1
00003C4E  FFFF      
00003C50  2F01      7146          move.l    D1,-(A7)
00003C52  4EB8 332A 7147          jsr       _DecodeBranchCondition
00003C56  584F      7148          addq.w    #4,A7
                    7149   ; Displacement8Bit = (*OpCode & (unsigned short int)(0xFF)) ;
00003C58  2042      7150          move.l    D2,A0
00003C5A  3010      7151          move.w    (A0),D0
00003C5C  C07C 00FF 7152          and.w     #255,D0
00003C60  1D40 FFFB 7153          move.b    D0,-5(A6)
                    7154   ; if(Displacement8Bit == (unsigned short int)(0))  {           // if 16 bit displacement
00003C64  102E FFFB 7155          move.b    -5(A6),D0
00003C68  4880      7156          ext.w     D0
00003C6A  4A40      7157          tst.w     D0
00003C6C  662A      7158          bne.s     DisassembleInstruction_110
                    7159   ; sprintf(TempString, "$%X", (int)(OpCode) + (int)(OpCode[1]) +  2) ;
00003C6E  2202      7160          move.l    D2,D1
00003C70  2042      7161          move.l    D2,A0
00003C72  2F00      7162          move.l    D0,-(A7)
00003C74  3028 0002 7163          move.w    2(A0),D0
00003C78  48C0      7164          ext.l     D0
00003C7A  D280      7165          add.l     D0,D1
00003C7C  201F      7166          move.l    (A7)+,D0
00003C7E  5481      7167          addq.l    #2,D1
00003C80  2F01      7168          move.l    D1,-(A7)
00003C82  4879 0000 7169          pea       @m68kde~2_164.L
00003C86  6FA8      
00003C88  2F0C      7170          move.l    A4,-(A7)
00003C8A  4E95      7171          jsr       (A5)
00003C8C  DEFC 000C 7172          add.w     #12,A7
                    7173   ; InstructionSize = 2 ;
00003C90  24BC 0000 7174          move.l    #2,(A2)
00003C94  0002      
00003C96  6022      7175          bra.s     DisassembleInstruction_111
                    7176   DisassembleInstruction_110:
                    7177   ; }
                    7178   ; else
                    7179   ; sprintf(TempString, "$%X", (int)(OpCode) + Displacement8Bit + 2) ;           // 8 bit displacement
00003C98  2202      7180          move.l    D2,D1
00003C9A  2F00      7181          move.l    D0,-(A7)
00003C9C  102E FFFB 7182          move.b    -5(A6),D0
00003CA0  4880      7183          ext.w     D0
00003CA2  48C0      7184          ext.l     D0
00003CA4  D280      7185          add.l     D0,D1
00003CA6  201F      7186          move.l    (A7)+,D0
00003CA8  5481      7187          addq.l    #2,D1
00003CAA  2F01      7188          move.l    D1,-(A7)
00003CAC  4879 0000 7189          pea       @m68kde~2_164.L
00003CB0  6FA8      
00003CB2  2F0C      7190          move.l    A4,-(A7)
00003CB4  4E95      7191          jsr       (A5)
00003CB6  DEFC 000C 7192          add.w     #12,A7
                    7193   DisassembleInstruction_111:
                    7194   ; strcatInstruction(TempString) ;
00003CBA  2F0C      7195          move.l    A4,-(A7)
00003CBC  4EB8 0CCC 7196          jsr       _strcatInstruction
00003CC0  584F      7197          addq.w    #4,A7
                    7198   DisassembleInstruction_108:
                    7199   ; }
                    7200   ; /////////////////////////////////////////////////////////////////////////////////
                    7201   ; // if instruction is BCHG dn,<EA>
                    7202   ; /////////////////////////////////////////////////////////////////////////////////
                    7203   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x0140))   {
00003CC2  2042      7204          move.l    D2,A0
00003CC4  3010      7205          move.w    (A0),D0
00003CC6  C07C F1C0 7206          and.w     #61888,D0
00003CCA  0C40 0140 7207          cmp.w     #320,D0
00003CCE  6600 004C 7208          bne       DisassembleInstruction_112
                    7209   ; InstructionSize = 1;
00003CD2  24BC 0000 7210          move.l    #1,(A2)
00003CD6  0001      
                    7211   ; strcpyInstruction("BCHG ") ;
00003CD8  4879 0000 7212          pea       @m68kde~2_215.L
00003CDC  70DE      
00003CDE  4E93      7213          jsr       (A3)
00003CE0  584F      7214          addq.w    #4,A7
                    7215   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00003CE2  2042      7216          move.l    D2,A0
00003CE4  3210      7217          move.w    (A0),D1
00003CE6  E041      7218          asr.w     #8,D1
00003CE8  E241      7219          asr.w     #1,D1
00003CEA  C27C 0007 7220          and.w     #7,D1
00003CEE  C2BC 0000 7221          and.l     #65535,D1
00003CF2  FFFF      
00003CF4  2F01      7222          move.l    D1,-(A7)
00003CF6  4879 0000 7223          pea       @m68kde~2_216.L
00003CFA  70E4      
00003CFC  2F0C      7224          move.l    A4,-(A7)
00003CFE  4E95      7225          jsr       (A5)
00003D00  DEFC 000C 7226          add.w     #12,A7
                    7227   ; strcatInstruction(TempString) ;
00003D04  2F0C      7228          move.l    A4,-(A7)
00003D06  4EB8 0CCC 7229          jsr       _strcatInstruction
00003D0A  584F      7230          addq.w    #4,A7
                    7231   ; Decode6BitEA(OpCode,0,0,0) ;
00003D0C  42A7      7232          clr.l     -(A7)
00003D0E  42A7      7233          clr.l     -(A7)
00003D10  42A7      7234          clr.l     -(A7)
00003D12  2F02      7235          move.l    D2,-(A7)
00003D14  4EB8 2E6C 7236          jsr       _Decode6BitEA
00003D18  DEFC 0010 7237          add.w     #16,A7
                    7238   DisassembleInstruction_112:
                    7239   ; }
                    7240   ; /////////////////////////////////////////////////////////////////////////////////
                    7241   ; // if instruction is BCHG #data,<EA>
                    7242   ; /////////////////////////////////////////////////////////////////////////////////
                    7243   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x0840))   {
00003D1C  2042      7244          move.l    D2,A0
00003D1E  3010      7245          move.w    (A0),D0
00003D20  C07C FFC0 7246          and.w     #65472,D0
00003D24  0C40 0840 7247          cmp.w     #2112,D0
00003D28  6600 0044 7248          bne       DisassembleInstruction_114
                    7249   ; strcpyInstruction("BCHG ") ;
00003D2C  4879 0000 7250          pea       @m68kde~2_215.L
00003D30  70DE      
00003D32  4E93      7251          jsr       (A3)
00003D34  584F      7252          addq.w    #4,A7
                    7253   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
00003D36  2042      7254          move.l    D2,A0
00003D38  3228 0002 7255          move.w    2(A0),D1
00003D3C  48C1      7256          ext.l     D1
00003D3E  2F01      7257          move.l    D1,-(A7)
00003D40  4879 0000 7258          pea       @m68kde~2_217.L
00003D44  70EA      
00003D46  2F0C      7259          move.l    A4,-(A7)
00003D48  4E95      7260          jsr       (A5)
00003D4A  DEFC 000C 7261          add.w     #12,A7
                    7262   ; InstructionSize = 2 ;
00003D4E  24BC 0000 7263          move.l    #2,(A2)
00003D52  0002      
                    7264   ; strcatInstruction(TempString) ;
00003D54  2F0C      7265          move.l    A4,-(A7)
00003D56  4EB8 0CCC 7266          jsr       _strcatInstruction
00003D5A  584F      7267          addq.w    #4,A7
                    7268   ; Decode6BitEA(OpCode,0,1,0) ;
00003D5C  42A7      7269          clr.l     -(A7)
00003D5E  4878 0001 7270          pea       1
00003D62  42A7      7271          clr.l     -(A7)
00003D64  2F02      7272          move.l    D2,-(A7)
00003D66  4EB8 2E6C 7273          jsr       _Decode6BitEA
00003D6A  DEFC 0010 7274          add.w     #16,A7
                    7275   DisassembleInstruction_114:
                    7276   ; }
                    7277   ; /////////////////////////////////////////////////////////////////////////////////
                    7278   ; // if instruction is BCLR  dn,<EA>
                    7279   ; /////////////////////////////////////////////////////////////////////////////////
                    7280   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x0180))   {
00003D6E  2042      7281          move.l    D2,A0
00003D70  3010      7282          move.w    (A0),D0
00003D72  C07C F1C0 7283          and.w     #61888,D0
00003D76  0C40 0180 7284          cmp.w     #384,D0
00003D7A  6600 004C 7285          bne       DisassembleInstruction_116
                    7286   ; InstructionSize = 1;
00003D7E  24BC 0000 7287          move.l    #1,(A2)
00003D82  0001      
                    7288   ; strcpyInstruction("BCLR ") ;
00003D84  4879 0000 7289          pea       @m68kde~2_218.L
00003D88  70F0      
00003D8A  4E93      7290          jsr       (A3)
00003D8C  584F      7291          addq.w    #4,A7
                    7292   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00003D8E  2042      7293          move.l    D2,A0
00003D90  3210      7294          move.w    (A0),D1
00003D92  E041      7295          asr.w     #8,D1
00003D94  E241      7296          asr.w     #1,D1
00003D96  C27C 0007 7297          and.w     #7,D1
00003D9A  C2BC 0000 7298          and.l     #65535,D1
00003D9E  FFFF      
00003DA0  2F01      7299          move.l    D1,-(A7)
00003DA2  4879 0000 7300          pea       @m68kde~2_216.L
00003DA6  70E4      
00003DA8  2F0C      7301          move.l    A4,-(A7)
00003DAA  4E95      7302          jsr       (A5)
00003DAC  DEFC 000C 7303          add.w     #12,A7
                    7304   ; strcatInstruction(TempString) ;
00003DB0  2F0C      7305          move.l    A4,-(A7)
00003DB2  4EB8 0CCC 7306          jsr       _strcatInstruction
00003DB6  584F      7307          addq.w    #4,A7
                    7308   ; Decode6BitEA(OpCode,0,0,0) ;
00003DB8  42A7      7309          clr.l     -(A7)
00003DBA  42A7      7310          clr.l     -(A7)
00003DBC  42A7      7311          clr.l     -(A7)
00003DBE  2F02      7312          move.l    D2,-(A7)
00003DC0  4EB8 2E6C 7313          jsr       _Decode6BitEA
00003DC4  DEFC 0010 7314          add.w     #16,A7
                    7315   DisassembleInstruction_116:
                    7316   ; }
                    7317   ; /////////////////////////////////////////////////////////////////////////////////
                    7318   ; // if instruction is BCLR #data,<EA>
                    7319   ; /////////////////////////////////////////////////////////////////////////////////
                    7320   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x0880))   {
00003DC8  2042      7321          move.l    D2,A0
00003DCA  3010      7322          move.w    (A0),D0
00003DCC  C07C FFC0 7323          and.w     #65472,D0
00003DD0  0C40 0880 7324          cmp.w     #2176,D0
00003DD4  6600 0044 7325          bne       DisassembleInstruction_118
                    7326   ; strcpyInstruction("BCLR ") ;
00003DD8  4879 0000 7327          pea       @m68kde~2_218.L
00003DDC  70F0      
00003DDE  4E93      7328          jsr       (A3)
00003DE0  584F      7329          addq.w    #4,A7
                    7330   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
00003DE2  2042      7331          move.l    D2,A0
00003DE4  3228 0002 7332          move.w    2(A0),D1
00003DE8  48C1      7333          ext.l     D1
00003DEA  2F01      7334          move.l    D1,-(A7)
00003DEC  4879 0000 7335          pea       @m68kde~2_217.L
00003DF0  70EA      
00003DF2  2F0C      7336          move.l    A4,-(A7)
00003DF4  4E95      7337          jsr       (A5)
00003DF6  DEFC 000C 7338          add.w     #12,A7
                    7339   ; InstructionSize = 2 ;
00003DFA  24BC 0000 7340          move.l    #2,(A2)
00003DFE  0002      
                    7341   ; strcatInstruction(TempString) ;
00003E00  2F0C      7342          move.l    A4,-(A7)
00003E02  4EB8 0CCC 7343          jsr       _strcatInstruction
00003E06  584F      7344          addq.w    #4,A7
                    7345   ; Decode6BitEA(OpCode,0,1,0) ;
00003E08  42A7      7346          clr.l     -(A7)
00003E0A  4878 0001 7347          pea       1
00003E0E  42A7      7348          clr.l     -(A7)
00003E10  2F02      7349          move.l    D2,-(A7)
00003E12  4EB8 2E6C 7350          jsr       _Decode6BitEA
00003E16  DEFC 0010 7351          add.w     #16,A7
                    7352   DisassembleInstruction_118:
                    7353   ; }
                    7354   ; /////////////////////////////////////////////////////////////////////////////////
                    7355   ; // if instruction is BSET dn,<EA>
                    7356   ; /////////////////////////////////////////////////////////////////////////////////
                    7357   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x01C0))   {
00003E1A  2042      7358          move.l    D2,A0
00003E1C  3010      7359          move.w    (A0),D0
00003E1E  C07C F1C0 7360          and.w     #61888,D0
00003E22  0C40 01C0 7361          cmp.w     #448,D0
00003E26  6600 004C 7362          bne       DisassembleInstruction_120
                    7363   ; InstructionSize = 1;
00003E2A  24BC 0000 7364          move.l    #1,(A2)
00003E2E  0001      
                    7365   ; strcpyInstruction("BSET ") ;
00003E30  4879 0000 7366          pea       @m68kde~2_219.L
00003E34  70F6      
00003E36  4E93      7367          jsr       (A3)
00003E38  584F      7368          addq.w    #4,A7
                    7369   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00003E3A  2042      7370          move.l    D2,A0
00003E3C  3210      7371          move.w    (A0),D1
00003E3E  E041      7372          asr.w     #8,D1
00003E40  E241      7373          asr.w     #1,D1
00003E42  C27C 0007 7374          and.w     #7,D1
00003E46  C2BC 0000 7375          and.l     #65535,D1
00003E4A  FFFF      
00003E4C  2F01      7376          move.l    D1,-(A7)
00003E4E  4879 0000 7377          pea       @m68kde~2_216.L
00003E52  70E4      
00003E54  2F0C      7378          move.l    A4,-(A7)
00003E56  4E95      7379          jsr       (A5)
00003E58  DEFC 000C 7380          add.w     #12,A7
                    7381   ; strcatInstruction(TempString) ;
00003E5C  2F0C      7382          move.l    A4,-(A7)
00003E5E  4EB8 0CCC 7383          jsr       _strcatInstruction
00003E62  584F      7384          addq.w    #4,A7
                    7385   ; Decode6BitEA(OpCode,0,0,0) ;
00003E64  42A7      7386          clr.l     -(A7)
00003E66  42A7      7387          clr.l     -(A7)
00003E68  42A7      7388          clr.l     -(A7)
00003E6A  2F02      7389          move.l    D2,-(A7)
00003E6C  4EB8 2E6C 7390          jsr       _Decode6BitEA
00003E70  DEFC 0010 7391          add.w     #16,A7
                    7392   DisassembleInstruction_120:
                    7393   ; }
                    7394   ; /////////////////////////////////////////////////////////////////////////////////
                    7395   ; // if instruction is BSET #data,<EA>
                    7396   ; /////////////////////////////////////////////////////////////////////////////////
                    7397   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x08C0))   {
00003E74  2042      7398          move.l    D2,A0
00003E76  3010      7399          move.w    (A0),D0
00003E78  C07C FFC0 7400          and.w     #65472,D0
00003E7C  0C40 08C0 7401          cmp.w     #2240,D0
00003E80  6600 0044 7402          bne       DisassembleInstruction_122
                    7403   ; strcpyInstruction("BSET ") ;
00003E84  4879 0000 7404          pea       @m68kde~2_219.L
00003E88  70F6      
00003E8A  4E93      7405          jsr       (A3)
00003E8C  584F      7406          addq.w    #4,A7
                    7407   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
00003E8E  2042      7408          move.l    D2,A0
00003E90  3228 0002 7409          move.w    2(A0),D1
00003E94  48C1      7410          ext.l     D1
00003E96  2F01      7411          move.l    D1,-(A7)
00003E98  4879 0000 7412          pea       @m68kde~2_217.L
00003E9C  70EA      
00003E9E  2F0C      7413          move.l    A4,-(A7)
00003EA0  4E95      7414          jsr       (A5)
00003EA2  DEFC 000C 7415          add.w     #12,A7
                    7416   ; InstructionSize = 2 ;
00003EA6  24BC 0000 7417          move.l    #2,(A2)
00003EAA  0002      
                    7418   ; strcatInstruction(TempString) ;
00003EAC  2F0C      7419          move.l    A4,-(A7)
00003EAE  4EB8 0CCC 7420          jsr       _strcatInstruction
00003EB2  584F      7421          addq.w    #4,A7
                    7422   ; Decode6BitEA(OpCode,0,1,0) ;
00003EB4  42A7      7423          clr.l     -(A7)
00003EB6  4878 0001 7424          pea       1
00003EBA  42A7      7425          clr.l     -(A7)
00003EBC  2F02      7426          move.l    D2,-(A7)
00003EBE  4EB8 2E6C 7427          jsr       _Decode6BitEA
00003EC2  DEFC 0010 7428          add.w     #16,A7
                    7429   DisassembleInstruction_122:
                    7430   ; }
                    7431   ; /////////////////////////////////////////////////////////////////////////////////
                    7432   ; // if instruction is BTST dn,<EA>
                    7433   ; /////////////////////////////////////////////////////////////////////////////////
                    7434   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x0100))   {
00003EC6  2042      7435          move.l    D2,A0
00003EC8  3010      7436          move.w    (A0),D0
00003ECA  C07C F1C0 7437          and.w     #61888,D0
00003ECE  0C40 0100 7438          cmp.w     #256,D0
00003ED2  6600 004C 7439          bne       DisassembleInstruction_124
                    7440   ; InstructionSize = 1;
00003ED6  24BC 0000 7441          move.l    #1,(A2)
00003EDA  0001      
                    7442   ; strcpyInstruction("BTST ") ;
00003EDC  4879 0000 7443          pea       @m68kde~2_220.L
00003EE0  70FC      
00003EE2  4E93      7444          jsr       (A3)
00003EE4  584F      7445          addq.w    #4,A7
                    7446   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00003EE6  2042      7447          move.l    D2,A0
00003EE8  3210      7448          move.w    (A0),D1
00003EEA  E041      7449          asr.w     #8,D1
00003EEC  E241      7450          asr.w     #1,D1
00003EEE  C27C 0007 7451          and.w     #7,D1
00003EF2  C2BC 0000 7452          and.l     #65535,D1
00003EF6  FFFF      
00003EF8  2F01      7453          move.l    D1,-(A7)
00003EFA  4879 0000 7454          pea       @m68kde~2_216.L
00003EFE  70E4      
00003F00  2F0C      7455          move.l    A4,-(A7)
00003F02  4E95      7456          jsr       (A5)
00003F04  DEFC 000C 7457          add.w     #12,A7
                    7458   ; strcatInstruction(TempString) ;
00003F08  2F0C      7459          move.l    A4,-(A7)
00003F0A  4EB8 0CCC 7460          jsr       _strcatInstruction
00003F0E  584F      7461          addq.w    #4,A7
                    7462   ; Decode6BitEA(OpCode,0,0,0) ;
00003F10  42A7      7463          clr.l     -(A7)
00003F12  42A7      7464          clr.l     -(A7)
00003F14  42A7      7465          clr.l     -(A7)
00003F16  2F02      7466          move.l    D2,-(A7)
00003F18  4EB8 2E6C 7467          jsr       _Decode6BitEA
00003F1C  DEFC 0010 7468          add.w     #16,A7
                    7469   DisassembleInstruction_124:
                    7470   ; }
                    7471   ; /////////////////////////////////////////////////////////////////////////////////
                    7472   ; // if instruction is BTST #data,<EA>
                    7473   ; /////////////////////////////////////////////////////////////////////////////////
                    7474   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x0800))   {
00003F20  2042      7475          move.l    D2,A0
00003F22  3010      7476          move.w    (A0),D0
00003F24  C07C FFC0 7477          and.w     #65472,D0
00003F28  0C40 0800 7478          cmp.w     #2048,D0
00003F2C  6600 0044 7479          bne       DisassembleInstruction_126
                    7480   ; strcpyInstruction("BTST ") ;
00003F30  4879 0000 7481          pea       @m68kde~2_220.L
00003F34  70FC      
00003F36  4E93      7482          jsr       (A3)
00003F38  584F      7483          addq.w    #4,A7
                    7484   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
00003F3A  2042      7485          move.l    D2,A0
00003F3C  3228 0002 7486          move.w    2(A0),D1
00003F40  48C1      7487          ext.l     D1
00003F42  2F01      7488          move.l    D1,-(A7)
00003F44  4879 0000 7489          pea       @m68kde~2_217.L
00003F48  70EA      
00003F4A  2F0C      7490          move.l    A4,-(A7)
00003F4C  4E95      7491          jsr       (A5)
00003F4E  DEFC 000C 7492          add.w     #12,A7
                    7493   ; InstructionSize = 2 ;
00003F52  24BC 0000 7494          move.l    #2,(A2)
00003F56  0002      
                    7495   ; strcatInstruction(TempString) ;
00003F58  2F0C      7496          move.l    A4,-(A7)
00003F5A  4EB8 0CCC 7497          jsr       _strcatInstruction
00003F5E  584F      7498          addq.w    #4,A7
                    7499   ; Decode6BitEA(OpCode,0,1,0) ;
00003F60  42A7      7500          clr.l     -(A7)
00003F62  4878 0001 7501          pea       1
00003F66  42A7      7502          clr.l     -(A7)
00003F68  2F02      7503          move.l    D2,-(A7)
00003F6A  4EB8 2E6C 7504          jsr       _Decode6BitEA
00003F6E  DEFC 0010 7505          add.w     #16,A7
                    7506   DisassembleInstruction_126:
                    7507   ; }
                    7508   ; /////////////////////////////////////////////////////////////////////////////////
                    7509   ; // if instruction is CHK.W <EA>,DN
                    7510   ; /////////////////////////////////////////////////////////////////////////////////
                    7511   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x4180))   {
00003F72  2042      7512          move.l    D2,A0
00003F74  3010      7513          move.w    (A0),D0
00003F76  C07C F1C0 7514          and.w     #61888,D0
00003F7A  0C40 4180 7515          cmp.w     #16768,D0
00003F7E  6600 004C 7516          bne       DisassembleInstruction_128
                    7517   ; InstructionSize = 1;
00003F82  24BC 0000 7518          move.l    #1,(A2)
00003F86  0001      
                    7519   ; strcpyInstruction("CHK ") ;
00003F88  4879 0000 7520          pea       @m68kde~2_221.L
00003F8C  7102      
00003F8E  4E93      7521          jsr       (A3)
00003F90  584F      7522          addq.w    #4,A7
                    7523   ; Decode6BitEA(OpCode,0,0,0) ;
00003F92  42A7      7524          clr.l     -(A7)
00003F94  42A7      7525          clr.l     -(A7)
00003F96  42A7      7526          clr.l     -(A7)
00003F98  2F02      7527          move.l    D2,-(A7)
00003F9A  4EB8 2E6C 7528          jsr       _Decode6BitEA
00003F9E  DEFC 0010 7529          add.w     #16,A7
                    7530   ; sprintf(TempString, ",D%d", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00003FA2  2042      7531          move.l    D2,A0
00003FA4  3210      7532          move.w    (A0),D1
00003FA6  E041      7533          asr.w     #8,D1
00003FA8  E241      7534          asr.w     #1,D1
00003FAA  C27C 0007 7535          and.w     #7,D1
00003FAE  C2BC 0000 7536          and.l     #65535,D1
00003FB2  FFFF      
00003FB4  2F01      7537          move.l    D1,-(A7)
00003FB6  4879 0000 7538          pea       @m68kde~2_222.L
00003FBA  7108      
00003FBC  2F0C      7539          move.l    A4,-(A7)
00003FBE  4E95      7540          jsr       (A5)
00003FC0  DEFC 000C 7541          add.w     #12,A7
                    7542   ; strcatInstruction(TempString) ;
00003FC4  2F0C      7543          move.l    A4,-(A7)
00003FC6  4EB8 0CCC 7544          jsr       _strcatInstruction
00003FCA  584F      7545          addq.w    #4,A7
                    7546   DisassembleInstruction_128:
                    7547   ; }
                    7548   ; /////////////////////////////////////////////////////////////////////////////////
                    7549   ; // if instruction is CLR <EA>
                    7550   ; /////////////////////////////////////////////////////////////////////////////////
                    7551   ; if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x4200))   {
00003FCC  2042      7552          move.l    D2,A0
00003FCE  3010      7553          move.w    (A0),D0
00003FD0  C07C FF00 7554          and.w     #65280,D0
00003FD4  0C40 4200 7555          cmp.w     #16896,D0
00003FD8  6600 0034 7556          bne       DisassembleInstruction_130
                    7557   ; InstructionSize = 1;
00003FDC  24BC 0000 7558          move.l    #1,(A2)
00003FE0  0001      
                    7559   ; strcpyInstruction("CLR") ;
00003FE2  4879 0000 7560          pea       @m68kde~2_223.L
00003FE6  710E      
00003FE8  4E93      7561          jsr       (A3)
00003FEA  584F      7562          addq.w    #4,A7
                    7563   ; Decode2BitOperandSize(*OpCode) ;
00003FEC  2042      7564          move.l    D2,A0
00003FEE  3210      7565          move.w    (A0),D1
00003FF0  C2BC 0000 7566          and.l     #65535,D1
00003FF4  FFFF      
00003FF6  2F01      7567          move.l    D1,-(A7)
00003FF8  4EB8 2BD8 7568          jsr       _Decode2BitOperandSize
00003FFC  584F      7569          addq.w    #4,A7
                    7570   ; Decode6BitEA(OpCode,0,0,0) ;
00003FFE  42A7      7571          clr.l     -(A7)
00004000  42A7      7572          clr.l     -(A7)
00004002  42A7      7573          clr.l     -(A7)
00004004  2F02      7574          move.l    D2,-(A7)
00004006  4EB8 2E6C 7575          jsr       _Decode6BitEA
0000400A  DEFC 0010 7576          add.w     #16,A7
                    7577   DisassembleInstruction_130:
                    7578   ; }
                    7579   ; /////////////////////////////////////////////////////////////////////////////////
                    7580   ; // if instruction is CMP, CMPA
                    7581   ; /////////////////////////////////////////////////////////////////////////////////
                    7582   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xB000))
0000400E  2042      7583          move.l    D2,A0
00004010  3010      7584          move.w    (A0),D0
00004012  C07C F000 7585          and.w     #61440,D0
00004016  0C40 B000 7586          cmp.w     #45056,D0
0000401A  6600 008C 7587          bne       DisassembleInstruction_135
                    7588   ; {
                    7589   ; InstructionSize = 1;
0000401E  24BC 0000 7590          move.l    #1,(A2)
00004022  0001      
                    7591   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007) ;
00004024  2042      7592          move.l    D2,A0
00004026  3010      7593          move.w    (A0),D0
00004028  EC40      7594          asr.w     #6,D0
0000402A  C07C 0007 7595          and.w     #7,D0
0000402E  3600      7596          move.w    D0,D3
                    7597   ; if((OpMode == (unsigned short int)(0x0003)) || (OpMode == (unsigned short int)(0x0007)))    {
00004030  0C43 0003 7598          cmp.w     #3,D3
00004034  6708      7599          beq.s     DisassembleInstruction_136
00004036  0C43 0007 7600          cmp.w     #7,D3
0000403A  6600 005A 7601          bne       DisassembleInstruction_134
                    7602   DisassembleInstruction_136:
                    7603   ; if(OpMode == (unsigned short int)(0x0003))
0000403E  0C43 0003 7604          cmp.w     #3,D3
00004042  660C      7605          bne.s     DisassembleInstruction_137
                    7606   ; strcpyInstruction("CMPA.W ") ;
00004044  4879 0000 7607          pea       @m68kde~2_224.L
00004048  7112      
0000404A  4E93      7608          jsr       (A3)
0000404C  584F      7609          addq.w    #4,A7
0000404E  600A      7610          bra.s     DisassembleInstruction_138
                    7611   DisassembleInstruction_137:
                    7612   ; else
                    7613   ; strcpyInstruction("CMPA.L ") ;
00004050  4879 0000 7614          pea       @m68kde~2_225.L
00004054  711A      
00004056  4E93      7615          jsr       (A3)
00004058  584F      7616          addq.w    #4,A7
                    7617   DisassembleInstruction_138:
                    7618   ; Decode6BitEA(OpCode,0,0,0) ;
0000405A  42A7      7619          clr.l     -(A7)
0000405C  42A7      7620          clr.l     -(A7)
0000405E  42A7      7621          clr.l     -(A7)
00004060  2F02      7622          move.l    D2,-(A7)
00004062  4EB8 2E6C 7623          jsr       _Decode6BitEA
00004066  DEFC 0010 7624          add.w     #16,A7
                    7625   ; sprintf(TempString, ",A%d", ((*OpCode >> 9) & (unsigned short int)(0x0007))) ;
0000406A  2042      7626          move.l    D2,A0
0000406C  3210      7627          move.w    (A0),D1
0000406E  E041      7628          asr.w     #8,D1
00004070  E241      7629          asr.w     #1,D1
00004072  C27C 0007 7630          and.w     #7,D1
00004076  C2BC 0000 7631          and.l     #65535,D1
0000407A  FFFF      
0000407C  2F01      7632          move.l    D1,-(A7)
0000407E  4879 0000 7633          pea       @m68kde~2_226.L
00004082  7122      
00004084  2F0C      7634          move.l    A4,-(A7)
00004086  4E95      7635          jsr       (A5)
00004088  DEFC 000C 7636          add.w     #12,A7
                    7637   ; strcatInstruction(TempString) ;
0000408C  2F0C      7638          move.l    A4,-(A7)
0000408E  4EB8 0CCC 7639          jsr       _strcatInstruction
00004092  584F      7640          addq.w    #4,A7
00004094  6012      7641          bra.s     DisassembleInstruction_135
                    7642   DisassembleInstruction_134:
                    7643   ; }
                    7644   ; else {
                    7645   ; strcpyInstruction("CMP") ;
00004096  4879 0000 7646          pea       @m68kde~2_227.L
0000409A  7128      
0000409C  4E93      7647          jsr       (A3)
0000409E  584F      7648          addq.w    #4,A7
                    7649   ; Decode3BitOperandMode(OpCode) ;
000040A0  2F02      7650          move.l    D2,-(A7)
000040A2  4EB8 3294 7651          jsr       _Decode3BitOperandMode
000040A6  584F      7652          addq.w    #4,A7
                    7653   DisassembleInstruction_135:
                    7654   ; }
                    7655   ; }
                    7656   ; /////////////////////////////////////////////////////////////////////////////////
                    7657   ; // if instruction is CMPM
                    7658   ; /////////////////////////////////////////////////////////////////////////////////
                    7659   ; if((*OpCode & (unsigned short int)(0xF138 )) == (unsigned short int)(0xB108))
000040A8  2042      7660          move.l    D2,A0
000040AA  3010      7661          move.w    (A0),D0
000040AC  C07C F138 7662          and.w     #61752,D0
000040B0  0C40 B108 7663          cmp.w     #45320,D0
000040B4  6600 007A 7664          bne       DisassembleInstruction_141
                    7665   ; {
                    7666   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0003) ;
000040B8  2042      7667          move.l    D2,A0
000040BA  3010      7668          move.w    (A0),D0
000040BC  EC40      7669          asr.w     #6,D0
000040BE  C07C 0003 7670          and.w     #3,D0
000040C2  3600      7671          move.w    D0,D3
                    7672   ; if((OpMode >= (unsigned short int)(0x0000)) && (OpMode <= (unsigned short int)(0x0002)))
000040C4  0C43 0000 7673          cmp.w     #0,D3
000040C8  6500 0066 7674          blo       DisassembleInstruction_141
000040CC  0C43 0002 7675          cmp.w     #2,D3
000040D0  6200 005E 7676          bhi       DisassembleInstruction_141
                    7677   ; {
                    7678   ; InstructionSize = 1;
000040D4  24BC 0000 7679          move.l    #1,(A2)
000040D8  0001      
                    7680   ; strcpyInstruction("CMPM") ;
000040DA  4879 0000 7681          pea       @m68kde~2_228.L
000040DE  712C      
000040E0  4E93      7682          jsr       (A3)
000040E2  584F      7683          addq.w    #4,A7
                    7684   ; Decode2BitOperandSize(*OpCode) ;
000040E4  2042      7685          move.l    D2,A0
000040E6  3210      7686          move.w    (A0),D1
000040E8  C2BC 0000 7687          and.l     #65535,D1
000040EC  FFFF      
000040EE  2F01      7688          move.l    D1,-(A7)
000040F0  4EB8 2BD8 7689          jsr       _Decode2BitOperandSize
000040F4  584F      7690          addq.w    #4,A7
                    7691   ; sprintf(TempString, "(A%d)+,(A%d)+", (*OpCode & (unsigned short int)(0x7)) , ((*OpCode >> 9) & (unsigned short int)(0x7)));
000040F6  2042      7692          move.l    D2,A0
000040F8  3210      7693          move.w    (A0),D1
000040FA  E041      7694          asr.w     #8,D1
000040FC  E241      7695          asr.w     #1,D1
000040FE  C27C 0007 7696          and.w     #7,D1
00004102  C2BC 0000 7697          and.l     #65535,D1
00004106  FFFF      
00004108  2F01      7698          move.l    D1,-(A7)
0000410A  2042      7699          move.l    D2,A0
0000410C  3210      7700          move.w    (A0),D1
0000410E  C27C 0007 7701          and.w     #7,D1
00004112  C2BC 0000 7702          and.l     #65535,D1
00004116  FFFF      
00004118  2F01      7703          move.l    D1,-(A7)
0000411A  4879 0000 7704          pea       @m68kde~2_229.L
0000411E  7132      
00004120  2F0C      7705          move.l    A4,-(A7)
00004122  4E95      7706          jsr       (A5)
00004124  DEFC 0010 7707          add.w     #16,A7
                    7708   ; strcatInstruction(TempString) ;
00004128  2F0C      7709          move.l    A4,-(A7)
0000412A  4EB8 0CCC 7710          jsr       _strcatInstruction
0000412E  584F      7711          addq.w    #4,A7
                    7712   DisassembleInstruction_141:
                    7713   ; }
                    7714   ; }
                    7715   ; /////////////////////////////////////////////////////////////////////////////////
                    7716   ; // if instruction is DBCC
                    7717   ; /////////////////////////////////////////////////////////////////////////////////
                    7718   ; if((*OpCode & (unsigned short int)(0xF0F8 )) == (unsigned short int)(0x50C8))
00004130  2042      7719          move.l    D2,A0
00004132  3010      7720          move.w    (A0),D0
00004134  C07C F0F8 7721          and.w     #61688,D0
00004138  0C40 50C8 7722          cmp.w     #20680,D0
0000413C  6600 0084 7723          bne       DisassembleInstruction_143
                    7724   ; {
                    7725   ; InstructionSize = 2;
00004140  24BC 0000 7726          move.l    #2,(A2)
00004144  0002      
                    7727   ; strcpy(Instruction,"DB") ;
00004146  4879 0000 7728          pea       @m68kde~2_230.L
0000414A  7140      
0000414C  4879 0B00 7729          pea       _Instruction.L
00004150  04E2      
00004152  4EB9 0000 7730          jsr       _strcpy
00004156  5322      
00004158  504F      7731          addq.w    #8,A7
                    7732   ; Condition = ((*OpCode >> 8) & (unsigned short int)(0x000F)) ;
0000415A  2042      7733          move.l    D2,A0
0000415C  3010      7734          move.w    (A0),D0
0000415E  E040      7735          asr.w     #8,D0
00004160  C07C 000F 7736          and.w     #15,D0
00004164  1D40 FFE9 7737          move.b    D0,-23(A6)
                    7738   ; DecodeBranchCondition(Condition) ;
00004168  122E FFE9 7739          move.b    -23(A6),D1
0000416C  C27C 00FF 7740          and.w     #255,D1
00004170  C2BC 0000 7741          and.l     #65535,D1
00004174  FFFF      
00004176  2F01      7742          move.l    D1,-(A7)
00004178  4EB8 332A 7743          jsr       _DecodeBranchCondition
0000417C  584F      7744          addq.w    #4,A7
                    7745   ; sprintf(TempString, "D%d,%+d(PC) to Addr:$%X",(*OpCode & (unsigned short int)(0x7)), (int)(OpCode[1]), (int)(OpCode) + (int)(OpCode[1]) +  2) ;
0000417E  2202      7746          move.l    D2,D1
00004180  2042      7747          move.l    D2,A0
00004182  2F00      7748          move.l    D0,-(A7)
00004184  3028 0002 7749          move.w    2(A0),D0
00004188  48C0      7750          ext.l     D0
0000418A  D280      7751          add.l     D0,D1
0000418C  201F      7752          move.l    (A7)+,D0
0000418E  5481      7753          addq.l    #2,D1
00004190  2F01      7754          move.l    D1,-(A7)
00004192  2042      7755          move.l    D2,A0
00004194  3228 0002 7756          move.w    2(A0),D1
00004198  48C1      7757          ext.l     D1
0000419A  2F01      7758          move.l    D1,-(A7)
0000419C  2042      7759          move.l    D2,A0
0000419E  3210      7760          move.w    (A0),D1
000041A0  C27C 0007 7761          and.w     #7,D1
000041A4  C2BC 0000 7762          and.l     #65535,D1
000041A8  FFFF      
000041AA  2F01      7763          move.l    D1,-(A7)
000041AC  4879 0000 7764          pea       @m68kde~2_231.L
000041B0  7144      
000041B2  2F0C      7765          move.l    A4,-(A7)
000041B4  4E95      7766          jsr       (A5)
000041B6  DEFC 0014 7767          add.w     #20,A7
                    7768   ; strcatInstruction(TempString) ;
000041BA  2F0C      7769          move.l    A4,-(A7)
000041BC  4EB8 0CCC 7770          jsr       _strcatInstruction
000041C0  584F      7771          addq.w    #4,A7
                    7772   DisassembleInstruction_143:
                    7773   ; }
                    7774   ; /////////////////////////////////////////////////////////////////////////////////
                    7775   ; // if instruction is DIVS
                    7776   ; /////////////////////////////////////////////////////////////////////////////////
                    7777   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x81C0))
000041C2  2042      7778          move.l    D2,A0
000041C4  3010      7779          move.w    (A0),D0
000041C6  C07C F1C0 7780          and.w     #61888,D0
000041CA  0C40 81C0 7781          cmp.w     #33216,D0
000041CE  6600 004A 7782          bne       DisassembleInstruction_145
                    7783   ; {
                    7784   ; InstructionSize = 1;
000041D2  24BC 0000 7785          move.l    #1,(A2)
000041D6  0001      
                    7786   ; strcpy(Instruction,"DIVS ") ;
000041D8  4879 0000 7787          pea       @m68kde~2_232.L
000041DC  715C      
000041DE  4879 0B00 7788          pea       _Instruction.L
000041E2  04E2      
000041E4  4EB9 0000 7789          jsr       _strcpy
000041E8  5322      
000041EA  504F      7790          addq.w    #8,A7
                    7791   ; Decode6BitEA(OpCode,0,0,0) ;
000041EC  42A7      7792          clr.l     -(A7)
000041EE  42A7      7793          clr.l     -(A7)
000041F0  42A7      7794          clr.l     -(A7)
000041F2  2F02      7795          move.l    D2,-(A7)
000041F4  4EB8 2E6C 7796          jsr       _Decode6BitEA
000041F8  DEFC 0010 7797          add.w     #16,A7
                    7798   ; strcatInstruction(",") ;
000041FC  4879 0000 7799          pea       @m68kde~2_167.L
00004200  6FBC      
00004202  4EB8 0CCC 7800          jsr       _strcatInstruction
00004206  584F      7801          addq.w    #4,A7
                    7802   ; Decode3BitDataRegister(*OpCode) ;
00004208  2042      7803          move.l    D2,A0
0000420A  3210      7804          move.w    (A0),D1
0000420C  C2BC 0000 7805          and.l     #65535,D1
00004210  FFFF      
00004212  2F01      7806          move.l    D1,-(A7)
00004214  4EB8 2C34 7807          jsr       _Decode3BitDataRegister
00004218  584F      7808          addq.w    #4,A7
                    7809   DisassembleInstruction_145:
                    7810   ; }
                    7811   ; /////////////////////////////////////////////////////////////////////////////////
                    7812   ; // if instruction is DIVU
                    7813   ; /////////////////////////////////////////////////////////////////////////////////
                    7814   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x80C0))
0000421A  2042      7815          move.l    D2,A0
0000421C  3010      7816          move.w    (A0),D0
0000421E  C07C F1C0 7817          and.w     #61888,D0
00004222  0C40 80C0 7818          cmp.w     #32960,D0
00004226  6600 004A 7819          bne       DisassembleInstruction_147
                    7820   ; {
                    7821   ; InstructionSize = 1;
0000422A  24BC 0000 7822          move.l    #1,(A2)
0000422E  0001      
                    7823   ; strcpy(Instruction,"DIVU ") ;
00004230  4879 0000 7824          pea       @m68kde~2_233.L
00004234  7162      
00004236  4879 0B00 7825          pea       _Instruction.L
0000423A  04E2      
0000423C  4EB9 0000 7826          jsr       _strcpy
00004240  5322      
00004242  504F      7827          addq.w    #8,A7
                    7828   ; Decode6BitEA(OpCode,0,0,0) ;
00004244  42A7      7829          clr.l     -(A7)
00004246  42A7      7830          clr.l     -(A7)
00004248  42A7      7831          clr.l     -(A7)
0000424A  2F02      7832          move.l    D2,-(A7)
0000424C  4EB8 2E6C 7833          jsr       _Decode6BitEA
00004250  DEFC 0010 7834          add.w     #16,A7
                    7835   ; strcatInstruction(",") ;
00004254  4879 0000 7836          pea       @m68kde~2_167.L
00004258  6FBC      
0000425A  4EB8 0CCC 7837          jsr       _strcatInstruction
0000425E  584F      7838          addq.w    #4,A7
                    7839   ; Decode3BitDataRegister(*OpCode) ;
00004260  2042      7840          move.l    D2,A0
00004262  3210      7841          move.w    (A0),D1
00004264  C2BC 0000 7842          and.l     #65535,D1
00004268  FFFF      
0000426A  2F01      7843          move.l    D1,-(A7)
0000426C  4EB8 2C34 7844          jsr       _Decode3BitDataRegister
00004270  584F      7845          addq.w    #4,A7
                    7846   DisassembleInstruction_147:
                    7847   ; }
                    7848   ; /////////////////////////////////////////////////////////////////////////////////
                    7849   ; // if instruction is EOR
                    7850   ; /////////////////////////////////////////////////////////////////////////////////
                    7851   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xB000))   {
00004272  2042      7852          move.l    D2,A0
00004274  3010      7853          move.w    (A0),D0
00004276  C07C F000 7854          and.w     #61440,D0
0000427A  0C40 B000 7855          cmp.w     #45056,D0
0000427E  6600 004A 7856          bne       DisassembleInstruction_151
                    7857   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007) ;
00004282  2042      7858          move.l    D2,A0
00004284  3010      7859          move.w    (A0),D0
00004286  EC40      7860          asr.w     #6,D0
00004288  C07C 0007 7861          and.w     #7,D0
0000428C  3600      7862          move.w    D0,D3
                    7863   ; EAMode = (*OpCode >> 3) & (unsigned short int)(0x0007) ;    // mode cannot be 1 for EOR as it it used by CMPM instruction as a differentiator
0000428E  2042      7864          move.l    D2,A0
00004290  3010      7865          move.w    (A0),D0
00004292  E640      7866          asr.w     #3,D0
00004294  C07C 0007 7867          and.w     #7,D0
00004298  3D40 FFEC 7868          move.w    D0,-20(A6)
                    7869   ; if( (OpMode >= (unsigned short int)(0x0004)) &&
0000429C  0C43 0004 7870          cmp.w     #4,D3
000042A0  6528      7871          blo.s     DisassembleInstruction_151
000042A2  0C43 0006 7872          cmp.w     #6,D3
000042A6  6222      7873          bhi.s     DisassembleInstruction_151
000042A8  302E FFEC 7874          move.w    -20(A6),D0
000042AC  0C40 0001 7875          cmp.w     #1,D0
000042B0  6718      7876          beq.s     DisassembleInstruction_151
                    7877   ; (OpMode <= (unsigned short int)(0x0006)) &&
                    7878   ; (EAMode != (unsigned short int)(0x0001)))
                    7879   ; {
                    7880   ; InstructionSize = 1;
000042B2  24BC 0000 7881          move.l    #1,(A2)
000042B6  0001      
                    7882   ; strcpyInstruction("EOR") ;
000042B8  4879 0000 7883          pea       @m68kde~2_234.L
000042BC  7168      
000042BE  4E93      7884          jsr       (A3)
000042C0  584F      7885          addq.w    #4,A7
                    7886   ; Decode3BitOperandMode(OpCode);
000042C2  2F02      7887          move.l    D2,-(A7)
000042C4  4EB8 3294 7888          jsr       _Decode3BitOperandMode
000042C8  584F      7889          addq.w    #4,A7
                    7890   DisassembleInstruction_151:
                    7891   ; }
                    7892   ; }
                    7893   ; /////////////////////////////////////////////////////////////////////////////////
                    7894   ; // if instruction is EOR to CCR
                    7895   ; /////////////////////////////////////////////////////////////////////////////////
                    7896   ; if(*OpCode == (unsigned short int)(0x0A3C))   {
000042CA  2042      7897          move.l    D2,A0
000042CC  3010      7898          move.w    (A0),D0
000042CE  0C40 0A3C 7899          cmp.w     #2620,D0
000042D2  662C      7900          bne.s     DisassembleInstruction_153
                    7901   ; InstructionSize = 1;
000042D4  24BC 0000 7902          move.l    #1,(A2)
000042D8  0001      
                    7903   ; sprintf(Instruction, "EORI #$%2X,CCR", OpCode[1] & (unsigned short int)(0x00FF)) ;
000042DA  2042      7904          move.l    D2,A0
000042DC  3228 0002 7905          move.w    2(A0),D1
000042E0  C27C 00FF 7906          and.w     #255,D1
000042E4  C2BC 0000 7907          and.l     #65535,D1
000042E8  FFFF      
000042EA  2F01      7908          move.l    D1,-(A7)
000042EC  4879 0000 7909          pea       @m68kde~2_235.L
000042F0  716C      
000042F2  4879 0B00 7910          pea       _Instruction.L
000042F6  04E2      
000042F8  4E95      7911          jsr       (A5)
000042FA  DEFC 000C 7912          add.w     #12,A7
                    7913   ; InstructionSize += 1;
000042FE  5292      7914          addq.l    #1,(A2)
                    7915   DisassembleInstruction_153:
                    7916   ; }
                    7917   ; /////////////////////////////////////////////////////////////////////////////////
                    7918   ; // if instruction is EORI #data,SR
                    7919   ; /////////////////////////////////////////////////////////////////////////////////
                    7920   ; if(*OpCode  == (unsigned short int)(0x0A7C))   {
00004300  2042      7921          move.l    D2,A0
00004302  3010      7922          move.w    (A0),D0
00004304  0C40 0A7C 7923          cmp.w     #2684,D0
00004308  6622      7924          bne.s     DisassembleInstruction_155
                    7925   ; InstructionSize = 2;
0000430A  24BC 0000 7926          move.l    #2,(A2)
0000430E  0002      
                    7927   ; sprintf(Instruction, "EORI #$%X,SR", OpCode[1]);
00004310  2042      7928          move.l    D2,A0
00004312  3228 0002 7929          move.w    2(A0),D1
00004316  48C1      7930          ext.l     D1
00004318  2F01      7931          move.l    D1,-(A7)
0000431A  4879 0000 7932          pea       @m68kde~2_236.L
0000431E  717C      
00004320  4879 0B00 7933          pea       _Instruction.L
00004324  04E2      
00004326  4E95      7934          jsr       (A5)
00004328  DEFC 000C 7935          add.w     #12,A7
                    7936   DisassembleInstruction_155:
                    7937   ; }
                    7938   ; /////////////////////////////////////////////////////////////////////////////////
                    7939   ; // if instruction is EXG
                    7940   ; /////////////////////////////////////////////////////////////////////////////////
                    7941   ; if((*OpCode & (unsigned short int)(0xF100 )) == (unsigned short int)(0xC100))   {
0000432C  2042      7942          move.l    D2,A0
0000432E  3010      7943          move.w    (A0),D0
00004330  C07C F100 7944          and.w     #61696,D0
00004334  0C40 C100 7945          cmp.w     #49408,D0
00004338  6600 00E0 7946          bne       DisassembleInstruction_163
                    7947   ; Rx = ((*OpCode >> 9) & (unsigned short int)(0x7)) ;
0000433C  2042      7948          move.l    D2,A0
0000433E  3010      7949          move.w    (A0),D0
00004340  E040      7950          asr.w     #8,D0
00004342  E240      7951          asr.w     #1,D0
00004344  C07C 0007 7952          and.w     #7,D0
00004348  3D40 FFF0 7953          move.w    D0,-16(A6)
                    7954   ; Ry = (*OpCode & (unsigned short int)(0x7)) ;
0000434C  2042      7955          move.l    D2,A0
0000434E  3010      7956          move.w    (A0),D0
00004350  C07C 0007 7957          and.w     #7,D0
00004354  3D40 FFF2 7958          move.w    D0,-14(A6)
                    7959   ; EXGOpMode = ((*OpCode >> 3) & (unsigned short int)(0x1F)) ;
00004358  2042      7960          move.l    D2,A0
0000435A  3010      7961          move.w    (A0),D0
0000435C  E640      7962          asr.w     #3,D0
0000435E  C07C 001F 7963          and.w     #31,D0
00004362  3D40 FFF4 7964          move.w    D0,-12(A6)
                    7965   ; if(EXGOpMode == (unsigned short int)(0x0008))   {
00004366  302E FFF4 7966          move.w    -12(A6),D0
0000436A  0C40 0008 7967          cmp.w     #8,D0
0000436E  6634      7968          bne.s     DisassembleInstruction_159
                    7969   ; InstructionSize = 1;
00004370  24BC 0000 7970          move.l    #1,(A2)
00004374  0001      
                    7971   ; sprintf(Instruction, "EXG D%d,D%d", Rx, Ry) ;
00004376  322E FFF2 7972          move.w    -14(A6),D1
0000437A  C2BC 0000 7973          and.l     #65535,D1
0000437E  FFFF      
00004380  2F01      7974          move.l    D1,-(A7)
00004382  322E FFF0 7975          move.w    -16(A6),D1
00004386  C2BC 0000 7976          and.l     #65535,D1
0000438A  FFFF      
0000438C  2F01      7977          move.l    D1,-(A7)
0000438E  4879 0000 7978          pea       @m68kde~2_237.L
00004392  718A      
00004394  4879 0B00 7979          pea       _Instruction.L
00004398  04E2      
0000439A  4E95      7980          jsr       (A5)
0000439C  DEFC 0010 7981          add.w     #16,A7
000043A0  6000 0078 7982          bra       DisassembleInstruction_163
                    7983   DisassembleInstruction_159:
                    7984   ; }
                    7985   ; else if(EXGOpMode == (unsigned short int)(0x0009))  {
000043A4  302E FFF4 7986          move.w    -12(A6),D0
000043A8  0C40 0009 7987          cmp.w     #9,D0
000043AC  6632      7988          bne.s     DisassembleInstruction_161
                    7989   ; InstructionSize = 1;
000043AE  24BC 0000 7990          move.l    #1,(A2)
000043B2  0001      
                    7991   ; sprintf(Instruction, "EXG A%d,A%d", Rx, Ry) ;
000043B4  322E FFF2 7992          move.w    -14(A6),D1
000043B8  C2BC 0000 7993          and.l     #65535,D1
000043BC  FFFF      
000043BE  2F01      7994          move.l    D1,-(A7)
000043C0  322E FFF0 7995          move.w    -16(A6),D1
000043C4  C2BC 0000 7996          and.l     #65535,D1
000043C8  FFFF      
000043CA  2F01      7997          move.l    D1,-(A7)
000043CC  4879 0000 7998          pea       @m68kde~2_238.L
000043D0  7196      
000043D2  4879 0B00 7999          pea       _Instruction.L
000043D6  04E2      
000043D8  4E95      8000          jsr       (A5)
000043DA  DEFC 0010 8001          add.w     #16,A7
000043DE  603A      8002          bra.s     DisassembleInstruction_163
                    8003   DisassembleInstruction_161:
                    8004   ; }
                    8005   ; else if(EXGOpMode == (unsigned short int)(0x0011))  {
000043E0  302E FFF4 8006          move.w    -12(A6),D0
000043E4  0C40 0011 8007          cmp.w     #17,D0
000043E8  6630      8008          bne.s     DisassembleInstruction_163
                    8009   ; InstructionSize = 1;
000043EA  24BC 0000 8010          move.l    #1,(A2)
000043EE  0001      
                    8011   ; sprintf(Instruction, "EXG D%d,A%d", Rx, Ry) ;
000043F0  322E FFF2 8012          move.w    -14(A6),D1
000043F4  C2BC 0000 8013          and.l     #65535,D1
000043F8  FFFF      
000043FA  2F01      8014          move.l    D1,-(A7)
000043FC  322E FFF0 8015          move.w    -16(A6),D1
00004400  C2BC 0000 8016          and.l     #65535,D1
00004404  FFFF      
00004406  2F01      8017          move.l    D1,-(A7)
00004408  4879 0000 8018          pea       @m68kde~2_239.L
0000440C  71A2      
0000440E  4879 0B00 8019          pea       _Instruction.L
00004412  04E2      
00004414  4E95      8020          jsr       (A5)
00004416  DEFC 0010 8021          add.w     #16,A7
                    8022   DisassembleInstruction_163:
                    8023   ; }
                    8024   ; }
                    8025   ; /////////////////////////////////////////////////////////////////////////////////
                    8026   ; // if instruction is EXT
                    8027   ; /////////////////////////////////////////////////////////////////////////////////
                    8028   ; if((*OpCode & (unsigned short int)(0xFE38)) == (unsigned short int)(0x4800))
0000441A  2042      8029          move.l    D2,A0
0000441C  3010      8030          move.w    (A0),D0
0000441E  C07C FE38 8031          and.w     #65080,D0
00004422  0C40 4800 8032          cmp.w     #18432,D0
00004426  6600 0054 8033          bne       DisassembleInstruction_165
                    8034   ; {
                    8035   ; InstructionSize = 1;
0000442A  24BC 0000 8036          move.l    #1,(A2)
0000442E  0001      
                    8037   ; strcpy(Instruction,"EXT") ;
00004430  4879 0000 8038          pea       @m68kde~2_240.L
00004434  71AE      
00004436  4879 0B00 8039          pea       _Instruction.L
0000443A  04E2      
0000443C  4EB9 0000 8040          jsr       _strcpy
00004440  5322      
00004442  504F      8041          addq.w    #8,A7
                    8042   ; if((*OpCode & (unsigned short int)(0x00C0)) == (unsigned short int)(0x00C0))
00004444  2042      8043          move.l    D2,A0
00004446  3010      8044          move.w    (A0),D0
00004448  C07C 00C0 8045          and.w     #192,D0
0000444C  0C40 00C0 8046          cmp.w     #192,D0
00004450  660E      8047          bne.s     DisassembleInstruction_167
                    8048   ; strcatInstruction(".L ") ;
00004452  4879 0000 8049          pea       @m68kde~2_151.L
00004456  6F72      
00004458  4EB8 0CCC 8050          jsr       _strcatInstruction
0000445C  584F      8051          addq.w    #4,A7
0000445E  600C      8052          bra.s     DisassembleInstruction_168
                    8053   DisassembleInstruction_167:
                    8054   ; else
                    8055   ; strcatInstruction(".W ") ;
00004460  4879 0000 8056          pea       @m68kde~2_150.L
00004464  6F6E      
00004466  4EB8 0CCC 8057          jsr       _strcatInstruction
0000446A  584F      8058          addq.w    #4,A7
                    8059   DisassembleInstruction_168:
                    8060   ; Decode6BitEA(OpCode,0,0,0) ;
0000446C  42A7      8061          clr.l     -(A7)
0000446E  42A7      8062          clr.l     -(A7)
00004470  42A7      8063          clr.l     -(A7)
00004472  2F02      8064          move.l    D2,-(A7)
00004474  4EB8 2E6C 8065          jsr       _Decode6BitEA
00004478  DEFC 0010 8066          add.w     #16,A7
                    8067   DisassembleInstruction_165:
                    8068   ; }
                    8069   ; /////////////////////////////////////////////////////////////////////////////////
                    8070   ; // if instruction is ILLEGAL $4afc
                    8071   ; /////////////////////////////////////////////////////////////////////////////////
                    8072   ; if(*OpCode == (unsigned short int)(0x4AFC)) {
0000447C  2042      8073          move.l    D2,A0
0000447E  3010      8074          move.w    (A0),D0
00004480  0C40 4AFC 8075          cmp.w     #19196,D0
00004484  661A      8076          bne.s     DisassembleInstruction_169
                    8077   ; InstructionSize = 1;
00004486  24BC 0000 8078          move.l    #1,(A2)
0000448A  0001      
                    8079   ; strcpy(Instruction,"ILLEGAL ($4AFC)") ;
0000448C  4879 0000 8080          pea       @m68kde~2_241.L
00004490  71B2      
00004492  4879 0B00 8081          pea       _Instruction.L
00004496  04E2      
00004498  4EB9 0000 8082          jsr       _strcpy
0000449C  5322      
0000449E  504F      8083          addq.w    #8,A7
                    8084   DisassembleInstruction_169:
                    8085   ; }
                    8086   ; /////////////////////////////////////////////////////////////////////////////////
                    8087   ; // if instruction is JMP
                    8088   ; /////////////////////////////////////////////////////////////////////////////////
                    8089   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4EC0))
000044A0  2042      8090          move.l    D2,A0
000044A2  3010      8091          move.w    (A0),D0
000044A4  C07C FFC0 8092          and.w     #65472,D0
000044A8  0C40 4EC0 8093          cmp.w     #20160,D0
000044AC  662A      8094          bne.s     DisassembleInstruction_171
                    8095   ; {
                    8096   ; InstructionSize = 1;
000044AE  24BC 0000 8097          move.l    #1,(A2)
000044B2  0001      
                    8098   ; strcpy(Instruction,"JMP ") ;
000044B4  4879 0000 8099          pea       @m68kde~2_242.L
000044B8  71C2      
000044BA  4879 0B00 8100          pea       _Instruction.L
000044BE  04E2      
000044C0  4EB9 0000 8101          jsr       _strcpy
000044C4  5322      
000044C6  504F      8102          addq.w    #8,A7
                    8103   ; Decode6BitEA(OpCode,0,0,0) ;
000044C8  42A7      8104          clr.l     -(A7)
000044CA  42A7      8105          clr.l     -(A7)
000044CC  42A7      8106          clr.l     -(A7)
000044CE  2F02      8107          move.l    D2,-(A7)
000044D0  4EB8 2E6C 8108          jsr       _Decode6BitEA
000044D4  DEFC 0010 8109          add.w     #16,A7
                    8110   DisassembleInstruction_171:
                    8111   ; }
                    8112   ; /////////////////////////////////////////////////////////////////////////////////
                    8113   ; // if instruction is JSR
                    8114   ; /////////////////////////////////////////////////////////////////////////////////
                    8115   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4E80))
000044D8  2042      8116          move.l    D2,A0
000044DA  3010      8117          move.w    (A0),D0
000044DC  C07C FFC0 8118          and.w     #65472,D0
000044E0  0C40 4E80 8119          cmp.w     #20096,D0
000044E4  662A      8120          bne.s     DisassembleInstruction_173
                    8121   ; {
                    8122   ; InstructionSize = 1;
000044E6  24BC 0000 8123          move.l    #1,(A2)
000044EA  0001      
                    8124   ; strcpy(Instruction,"JSR ") ;
000044EC  4879 0000 8125          pea       @m68kde~2_243.L
000044F0  71C8      
000044F2  4879 0B00 8126          pea       _Instruction.L
000044F6  04E2      
000044F8  4EB9 0000 8127          jsr       _strcpy
000044FC  5322      
000044FE  504F      8128          addq.w    #8,A7
                    8129   ; Decode6BitEA(OpCode,0,0,0) ;
00004500  42A7      8130          clr.l     -(A7)
00004502  42A7      8131          clr.l     -(A7)
00004504  42A7      8132          clr.l     -(A7)
00004506  2F02      8133          move.l    D2,-(A7)
00004508  4EB8 2E6C 8134          jsr       _Decode6BitEA
0000450C  DEFC 0010 8135          add.w     #16,A7
                    8136   DisassembleInstruction_173:
                    8137   ; }
                    8138   ; /////////////////////////////////////////////////////////////////////////////////
                    8139   ; // if instruction is LEA
                    8140   ; /////////////////////////////////////////////////////////////////////////////////
                    8141   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0x41C0))
00004510  2042      8142          move.l    D2,A0
00004512  3010      8143          move.w    (A0),D0
00004514  C07C F1C0 8144          and.w     #61888,D0
00004518  0C40 41C0 8145          cmp.w     #16832,D0
0000451C  6600 0056 8146          bne       DisassembleInstruction_175
                    8147   ; {
                    8148   ; InstructionSize = 1;
00004520  24BC 0000 8149          move.l    #1,(A2)
00004524  0001      
                    8150   ; strcpy(Instruction,"LEA ") ;
00004526  4879 0000 8151          pea       @m68kde~2_244.L
0000452A  71CE      
0000452C  4879 0B00 8152          pea       _Instruction.L
00004530  04E2      
00004532  4EB9 0000 8153          jsr       _strcpy
00004536  5322      
00004538  504F      8154          addq.w    #8,A7
                    8155   ; Decode6BitEA(OpCode,0,0,0) ;
0000453A  42A7      8156          clr.l     -(A7)
0000453C  42A7      8157          clr.l     -(A7)
0000453E  42A7      8158          clr.l     -(A7)
00004540  2F02      8159          move.l    D2,-(A7)
00004542  4EB8 2E6C 8160          jsr       _Decode6BitEA
00004546  DEFC 0010 8161          add.w     #16,A7
                    8162   ; sprintf(TempString, ",A%d", ((*OpCode >> 9) & (unsigned short int)(0x7)));
0000454A  2042      8163          move.l    D2,A0
0000454C  3210      8164          move.w    (A0),D1
0000454E  E041      8165          asr.w     #8,D1
00004550  E241      8166          asr.w     #1,D1
00004552  C27C 0007 8167          and.w     #7,D1
00004556  C2BC 0000 8168          and.l     #65535,D1
0000455A  FFFF      
0000455C  2F01      8169          move.l    D1,-(A7)
0000455E  4879 0000 8170          pea       @m68kde~2_226.L
00004562  7122      
00004564  2F0C      8171          move.l    A4,-(A7)
00004566  4E95      8172          jsr       (A5)
00004568  DEFC 000C 8173          add.w     #12,A7
                    8174   ; strcatInstruction(TempString);
0000456C  2F0C      8175          move.l    A4,-(A7)
0000456E  4EB8 0CCC 8176          jsr       _strcatInstruction
00004572  584F      8177          addq.w    #4,A7
                    8178   DisassembleInstruction_175:
                    8179   ; }
                    8180   ; /////////////////////////////////////////////////////////////////////////////////
                    8181   ; // if instruction is LINK.W
                    8182   ; /////////////////////////////////////////////////////////////////////////////////
                    8183   ; if((*OpCode & (unsigned short int)(0xFFF8)) == (unsigned short int)(0x4E50))
00004574  2042      8184          move.l    D2,A0
00004576  3010      8185          move.w    (A0),D0
00004578  C07C FFF8 8186          and.w     #65528,D0
0000457C  0C40 4E50 8187          cmp.w     #20048,D0
00004580  6600 0052 8188          bne       DisassembleInstruction_177
                    8189   ; {
                    8190   ; InstructionSize = 1;
00004584  24BC 0000 8191          move.l    #1,(A2)
00004588  0001      
                    8192   ; strcpy(Instruction,"LINK ") ;
0000458A  4879 0000 8193          pea       @m68kde~2_245.L
0000458E  71D4      
00004590  4879 0B00 8194          pea       _Instruction.L
00004594  04E2      
00004596  4EB9 0000 8195          jsr       _strcpy
0000459A  5322      
0000459C  504F      8196          addq.w    #8,A7
                    8197   ; sprintf(TempString, "A%d,#%d", ((*OpCode) & (unsigned short int)(0x7)),OpCode[1]);
0000459E  2042      8198          move.l    D2,A0
000045A0  3228 0002 8199          move.w    2(A0),D1
000045A4  48C1      8200          ext.l     D1
000045A6  2F01      8201          move.l    D1,-(A7)
000045A8  2042      8202          move.l    D2,A0
000045AA  3210      8203          move.w    (A0),D1
000045AC  C27C 0007 8204          and.w     #7,D1
000045B0  C2BC 0000 8205          and.l     #65535,D1
000045B4  FFFF      
000045B6  2F01      8206          move.l    D1,-(A7)
000045B8  4879 0000 8207          pea       @m68kde~2_246.L
000045BC  71DA      
000045BE  2F0C      8208          move.l    A4,-(A7)
000045C0  4E95      8209          jsr       (A5)
000045C2  DEFC 0010 8210          add.w     #16,A7
                    8211   ; InstructionSize = 2 ;
000045C6  24BC 0000 8212          move.l    #2,(A2)
000045CA  0002      
                    8213   ; strcatInstruction(TempString);
000045CC  2F0C      8214          move.l    A4,-(A7)
000045CE  4EB8 0CCC 8215          jsr       _strcatInstruction
000045D2  584F      8216          addq.w    #4,A7
                    8217   DisassembleInstruction_177:
                    8218   ; }
                    8219   ; /////////////////////////////////////////////////////////////////////////////////
                    8220   ; // if instruction is MOVE, MOVEA
                    8221   ; /////////////////////////////////////////////////////////////////////////////////
                    8222   ; if((*OpCode & (unsigned short int)(0xC000)) == (unsigned short int)(0x0000))
000045D4  2042      8223          move.l    D2,A0
000045D6  3010      8224          move.w    (A0),D0
000045D8  C07C C000 8225          and.w     #49152,D0
000045DC  6600 00F0 8226          bne       DisassembleInstruction_193
                    8227   ; {
                    8228   ; Size = (*OpCode & (unsigned short int)(0x3000)) >> 12 ;   // get 2 bit size in bits 13/12 into 1,0
000045E0  2042      8229          move.l    D2,A0
000045E2  3010      8230          move.w    (A0),D0
000045E4  C07C 3000 8231          and.w     #12288,D0
000045E8  E048      8232          lsr.w     #8,D0
000045EA  E848      8233          lsr.w     #4,D0
000045EC  3D40 FFE2 8234          move.w    D0,-30(A6)
                    8235   ; OpMode = (*OpCode >> 3) & (unsigned short int)(0x0007);   // get 3 bit source mode operand
000045F0  2042      8236          move.l    D2,A0
000045F2  3010      8237          move.w    (A0),D0
000045F4  E640      8238          asr.w     #3,D0
000045F6  C07C 0007 8239          and.w     #7,D0
000045FA  3600      8240          move.w    D0,D3
                    8241   ; SourceReg = (*OpCode) & (unsigned short int)(0x0007);     // get 3 bit source register number
000045FC  2042      8242          move.l    D2,A0
000045FE  3010      8243          move.w    (A0),D0
00004600  C07C 0007 8244          and.w     #7,D0
00004604  3D40 FFF6 8245          move.w    D0,-10(A6)
                    8246   ; DataSize = 0 ;
00004608  7E00      8247          moveq     #0,D7
                    8248   ; // if source addressing mode is d16(a0) or d8(a0,d0)
                    8249   ; if((OpMode == (unsigned short int)(0x0005)) || (OpMode == (unsigned short int)(0x0006)))
0000460A  0C43 0005 8250          cmp.w     #5,D3
0000460E  6706      8251          beq.s     DisassembleInstruction_183
00004610  0C43 0006 8252          cmp.w     #6,D3
00004614  6602      8253          bne.s     DisassembleInstruction_181
                    8254   DisassembleInstruction_183:
                    8255   ; DataSize = 1;  // source operands has 1 word after EA
00004616  7E01      8256          moveq     #1,D7
                    8257   DisassembleInstruction_181:
                    8258   ; // if source addressing mode is a 16 or 32 bit address
                    8259   ; if((OpMode == (unsigned short int)(0x0007))) {
00004618  0C43 0007 8260          cmp.w     #7,D3
0000461C  660C      8261          bne.s     DisassembleInstruction_187
                    8262   ; if(SourceReg == (unsigned short int)(0x0000))         // short address
0000461E  302E FFF6 8263          move.w    -10(A6),D0
00004622  6604      8264          bne.s     DisassembleInstruction_186
                    8265   ; DataSize = 1 ;
00004624  7E01      8266          moveq     #1,D7
00004626  6002      8267          bra.s     DisassembleInstruction_187
                    8268   DisassembleInstruction_186:
                    8269   ; else
                    8270   ; DataSize = 2 ;
00004628  7E02      8271          moveq     #2,D7
                    8272   DisassembleInstruction_187:
                    8273   ; }
                    8274   ; // if source addressing mode is # then figure out size
                    8275   ; if((OpMode == (unsigned short int)(0x0007)) && (SourceReg == (unsigned short int)(0x0004)))    {
0000462A  0C43 0007 8276          cmp.w     #7,D3
0000462E  6624      8277          bne.s     DisassembleInstruction_191
00004630  302E FFF6 8278          move.w    -10(A6),D0
00004634  0C40 0004 8279          cmp.w     #4,D0
00004638  661A      8280          bne.s     DisassembleInstruction_191
                    8281   ; if((Size == (unsigned short int)(1)) || (Size == (unsigned short int)(3)))
0000463A  302E FFE2 8282          move.w    -30(A6),D0
0000463E  0C40 0001 8283          cmp.w     #1,D0
00004642  670A      8284          beq.s     DisassembleInstruction_192
00004644  302E FFE2 8285          move.w    -30(A6),D0
00004648  0C40 0003 8286          cmp.w     #3,D0
0000464C  6604      8287          bne.s     DisassembleInstruction_190
                    8288   DisassembleInstruction_192:
                    8289   ; DataSize = 1;
0000464E  7E01      8290          moveq     #1,D7
00004650  6002      8291          bra.s     DisassembleInstruction_191
                    8292   DisassembleInstruction_190:
                    8293   ; else
                    8294   ; DataSize = 2 ;
00004652  7E02      8295          moveq     #2,D7
                    8296   DisassembleInstruction_191:
                    8297   ; //printf("DataSize = %d",DataSize) ;
                    8298   ; }
                    8299   ; if(Size != 0)
00004654  302E FFE2 8300          move.w    -30(A6),D0
00004658  6700 0074 8301          beq       DisassembleInstruction_193
                    8302   ; {
                    8303   ; InstructionSize = 1;
0000465C  24BC 0000 8304          move.l    #1,(A2)
00004660  0001      
                    8305   ; if(Size == 1)
00004662  302E FFE2 8306          move.w    -30(A6),D0
00004666  0C40 0001 8307          cmp.w     #1,D0
0000466A  660C      8308          bne.s     DisassembleInstruction_195
                    8309   ; strcpyInstruction("MOVE.B ") ;
0000466C  4879 0000 8310          pea       @m68kde~2_247.L
00004670  71E2      
00004672  4E93      8311          jsr       (A3)
00004674  584F      8312          addq.w    #4,A7
00004676  6020      8313          bra.s     DisassembleInstruction_198
                    8314   DisassembleInstruction_195:
                    8315   ; else if(Size == 2)
00004678  302E FFE2 8316          move.w    -30(A6),D0
0000467C  0C40 0002 8317          cmp.w     #2,D0
00004680  660C      8318          bne.s     DisassembleInstruction_197
                    8319   ; strcpyInstruction("MOVE.L ") ;
00004682  4879 0000 8320          pea       @m68kde~2_248.L
00004686  71EA      
00004688  4E93      8321          jsr       (A3)
0000468A  584F      8322          addq.w    #4,A7
0000468C  600A      8323          bra.s     DisassembleInstruction_198
                    8324   DisassembleInstruction_197:
                    8325   ; else
                    8326   ; strcpyInstruction("MOVE.W ") ;
0000468E  4879 0000 8327          pea       @m68kde~2_249.L
00004692  71F2      
00004694  4E93      8328          jsr       (A3)
00004696  584F      8329          addq.w    #4,A7
                    8330   DisassembleInstruction_198:
                    8331   ; Decode6BitEA(OpCode,0,0,1) ;
00004698  4878 0001 8332          pea       1
0000469C  42A7      8333          clr.l     -(A7)
0000469E  42A7      8334          clr.l     -(A7)
000046A0  2F02      8335          move.l    D2,-(A7)
000046A2  4EB8 2E6C 8336          jsr       _Decode6BitEA
000046A6  DEFC 0010 8337          add.w     #16,A7
                    8338   ; strcatInstruction(",") ;
000046AA  4879 0000 8339          pea       @m68kde~2_167.L
000046AE  6FBC      
000046B0  4EB8 0CCC 8340          jsr       _strcatInstruction
000046B4  584F      8341          addq.w    #4,A7
                    8342   ; // tell next function how many words lie between opcode and destination, could be 1 or 2 e.g. with # addressing move.bwl #$data,<EA>
                    8343   ; // but subtract 1 to make the maths correct in the called function
                    8344   ; Decode6BitEA(OpCode,2,(DataSize),0) ;
000046B6  42A7      8345          clr.l     -(A7)
000046B8  CEBC 0000 8346          and.l     #65535,D7
000046BC  FFFF      
000046BE  2F07      8347          move.l    D7,-(A7)
000046C0  4878 0002 8348          pea       2
000046C4  2F02      8349          move.l    D2,-(A7)
000046C6  4EB8 2E6C 8350          jsr       _Decode6BitEA
000046CA  DEFC 0010 8351          add.w     #16,A7
                    8352   DisassembleInstruction_193:
                    8353   ; }
                    8354   ; }
                    8355   ; /////////////////////////////////////////////////////////////////////////////////
                    8356   ; // if instruction is MOVE <EA>,CCR
                    8357   ; /////////////////////////////////////////////////////////////////////////////////
                    8358   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x44C0))
000046CE  2042      8359          move.l    D2,A0
000046D0  3010      8360          move.w    (A0),D0
000046D2  C07C FFC0 8361          and.w     #65472,D0
000046D6  0C40 44C0 8362          cmp.w     #17600,D0
000046DA  6636      8363          bne.s     DisassembleInstruction_199
                    8364   ; {
                    8365   ; InstructionSize = 1;
000046DC  24BC 0000 8366          move.l    #1,(A2)
000046E0  0001      
                    8367   ; strcpy(Instruction,"MOVE ") ;
000046E2  4879 0000 8368          pea       @m68kde~2_250.L
000046E6  71FA      
000046E8  4879 0B00 8369          pea       _Instruction.L
000046EC  04E2      
000046EE  4EB9 0000 8370          jsr       _strcpy
000046F2  5322      
000046F4  504F      8371          addq.w    #8,A7
                    8372   ; Decode6BitEA(OpCode,0,0,0) ;
000046F6  42A7      8373          clr.l     -(A7)
000046F8  42A7      8374          clr.l     -(A7)
000046FA  42A7      8375          clr.l     -(A7)
000046FC  2F02      8376          move.l    D2,-(A7)
000046FE  4EB8 2E6C 8377          jsr       _Decode6BitEA
00004702  DEFC 0010 8378          add.w     #16,A7
                    8379   ; strcatInstruction(",CCR") ;
00004706  4879 0000 8380          pea       @m68kde~2_251.L
0000470A  7200      
0000470C  4EB8 0CCC 8381          jsr       _strcatInstruction
00004710  584F      8382          addq.w    #4,A7
                    8383   DisassembleInstruction_199:
                    8384   ; }
                    8385   ; /////////////////////////////////////////////////////////////////////////////////
                    8386   ; // if instruction is MOVE SR,<EA>
                    8387   ; /////////////////////////////////////////////////////////////////////////////////
                    8388   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x40C0))
00004712  2042      8389          move.l    D2,A0
00004714  3010      8390          move.w    (A0),D0
00004716  C07C FFC0 8391          and.w     #65472,D0
0000471A  0C40 40C0 8392          cmp.w     #16576,D0
0000471E  662A      8393          bne.s     DisassembleInstruction_201
                    8394   ; {
                    8395   ; InstructionSize = 1;
00004720  24BC 0000 8396          move.l    #1,(A2)
00004724  0001      
                    8397   ; strcpy(Instruction,"MOVE SR,") ;
00004726  4879 0000 8398          pea       @m68kde~2_252.L
0000472A  7206      
0000472C  4879 0B00 8399          pea       _Instruction.L
00004730  04E2      
00004732  4EB9 0000 8400          jsr       _strcpy
00004736  5322      
00004738  504F      8401          addq.w    #8,A7
                    8402   ; Decode6BitEA(OpCode,0,0,0) ;
0000473A  42A7      8403          clr.l     -(A7)
0000473C  42A7      8404          clr.l     -(A7)
0000473E  42A7      8405          clr.l     -(A7)
00004740  2F02      8406          move.l    D2,-(A7)
00004742  4EB8 2E6C 8407          jsr       _Decode6BitEA
00004746  DEFC 0010 8408          add.w     #16,A7
                    8409   DisassembleInstruction_201:
                    8410   ; }
                    8411   ; /////////////////////////////////////////////////////////////////////////////////
                    8412   ; // if instruction is MOVE <EA>,SR
                    8413   ; /////////////////////////////////////////////////////////////////////////////////
                    8414   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x46C0))
0000474A  2042      8415          move.l    D2,A0
0000474C  3010      8416          move.w    (A0),D0
0000474E  C07C FFC0 8417          and.w     #65472,D0
00004752  0C40 46C0 8418          cmp.w     #18112,D0
00004756  6636      8419          bne.s     DisassembleInstruction_203
                    8420   ; {
                    8421   ; InstructionSize = 1;
00004758  24BC 0000 8422          move.l    #1,(A2)
0000475C  0001      
                    8423   ; strcpy(Instruction,"MOVE ") ;
0000475E  4879 0000 8424          pea       @m68kde~2_250.L
00004762  71FA      
00004764  4879 0B00 8425          pea       _Instruction.L
00004768  04E2      
0000476A  4EB9 0000 8426          jsr       _strcpy
0000476E  5322      
00004770  504F      8427          addq.w    #8,A7
                    8428   ; Decode6BitEA(OpCode,0,0,0) ;
00004772  42A7      8429          clr.l     -(A7)
00004774  42A7      8430          clr.l     -(A7)
00004776  42A7      8431          clr.l     -(A7)
00004778  2F02      8432          move.l    D2,-(A7)
0000477A  4EB8 2E6C 8433          jsr       _Decode6BitEA
0000477E  DEFC 0010 8434          add.w     #16,A7
                    8435   ; strcatInstruction(",SR") ;
00004782  4879 0000 8436          pea       @m68kde~2_253.L
00004786  7210      
00004788  4EB8 0CCC 8437          jsr       _strcatInstruction
0000478C  584F      8438          addq.w    #4,A7
                    8439   DisassembleInstruction_203:
                    8440   ; }
                    8441   ; /////////////////////////////////////////////////////////////////////////////////
                    8442   ; // if instruction is MOVE USP,An
                    8443   ; /////////////////////////////////////////////////////////////////////////////////
                    8444   ; if((*OpCode & (unsigned short int)(0xFFF0)) == (unsigned short int)(0x4E60))
0000478E  2042      8445          move.l    D2,A0
00004790  3010      8446          move.w    (A0),D0
00004792  C07C FFF0 8447          and.w     #65520,D0
00004796  0C40 4E60 8448          cmp.w     #20064,D0
0000479A  6600 0060 8449          bne       DisassembleInstruction_208
                    8450   ; {
                    8451   ; InstructionSize = 1;
0000479E  24BC 0000 8452          move.l    #1,(A2)
000047A2  0001      
                    8453   ; Register = (*OpCode & (unsigned short int)(0x0007)) ;
000047A4  2042      8454          move.l    D2,A0
000047A6  3010      8455          move.w    (A0),D0
000047A8  C07C 0007 8456          and.w     #7,D0
000047AC  3D40 FFEA 8457          move.w    D0,-22(A6)
                    8458   ; if((*OpCode & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008))        // transfer sp to address regier
000047B0  2042      8459          move.l    D2,A0
000047B2  3010      8460          move.w    (A0),D0
000047B4  C07C 0008 8461          and.w     #8,D0
000047B8  0C40 0008 8462          cmp.w     #8,D0
000047BC  6620      8463          bne.s     DisassembleInstruction_207
                    8464   ; sprintf(Instruction, "MOVE USP,A%d", Register);
000047BE  322E FFEA 8465          move.w    -22(A6),D1
000047C2  C2BC 0000 8466          and.l     #65535,D1
000047C6  FFFF      
000047C8  2F01      8467          move.l    D1,-(A7)
000047CA  4879 0000 8468          pea       @m68kde~2_254.L
000047CE  7214      
000047D0  4879 0B00 8469          pea       _Instruction.L
000047D4  04E2      
000047D6  4E95      8470          jsr       (A5)
000047D8  DEFC 000C 8471          add.w     #12,A7
000047DC  601E      8472          bra.s     DisassembleInstruction_208
                    8473   DisassembleInstruction_207:
                    8474   ; else
                    8475   ; sprintf(Instruction, "MOVE A%d,USP", Register);
000047DE  322E FFEA 8476          move.w    -22(A6),D1
000047E2  C2BC 0000 8477          and.l     #65535,D1
000047E6  FFFF      
000047E8  2F01      8478          move.l    D1,-(A7)
000047EA  4879 0000 8479          pea       @m68kde~2_255.L
000047EE  7222      
000047F0  4879 0B00 8480          pea       _Instruction.L
000047F4  04E2      
000047F6  4E95      8481          jsr       (A5)
000047F8  DEFC 000C 8482          add.w     #12,A7
                    8483   DisassembleInstruction_208:
                    8484   ; }
                    8485   ; /////////////////////////////////////////////////////////////////////////////////
                    8486   ; // if instruction is MOVEM
                    8487   ; /////////////////////////////////////////////////////////////////////////////////
                    8488   ; if((*OpCode & (unsigned short int)(0xFB80)) == (unsigned short int)(0x4880))
000047FC  2042      8489          move.l    D2,A0
000047FE  3010      8490          move.w    (A0),D0
00004800  C07C FB80 8491          and.w     #64384,D0
00004804  0C40 4880 8492          cmp.w     #18560,D0
00004808  6600 01FC 8493          bne       DisassembleInstruction_230
                    8494   ; {
                    8495   ; OpMode = (*OpCode >> 3) & (unsigned short int)(0x0007) ;
0000480C  2042      8496          move.l    D2,A0
0000480E  3010      8497          move.w    (A0),D0
00004810  E640      8498          asr.w     #3,D0
00004812  C07C 0007 8499          and.w     #7,D0
00004816  3600      8500          move.w    D0,D3
                    8501   ; if( (OpMode != (unsigned short int)(0x0)) &&
00004818  4A43      8502          tst.w     D3
0000481A  6700 01EA 8503          beq       DisassembleInstruction_230
0000481E  0C43 0001 8504          cmp.w     #1,D3
00004822  6700 01E2 8505          beq       DisassembleInstruction_230
00004826  4A43      8506          tst.w     D3
00004828  6700 01DC 8507          beq       DisassembleInstruction_230
                    8508   ; (OpMode != (unsigned short int)(0x1)) &&
                    8509   ; (OpMode != (unsigned short int)(0x0)))
                    8510   ; {
                    8511   ; InstructionSize = 1;
0000482C  24BC 0000 8512          move.l    #1,(A2)
00004830  0001      
                    8513   ; strcpy(Instruction,"MOVEM") ;
00004832  4879 0000 8514          pea       @m68kde~2_256.L
00004836  7230      
00004838  4879 0B00 8515          pea       _Instruction.L
0000483C  04E2      
0000483E  4EB9 0000 8516          jsr       _strcpy
00004842  5322      
00004844  504F      8517          addq.w    #8,A7
                    8518   ; InstructionSize ++ ;
00004846  5292      8519          addq.l    #1,(A2)
                    8520   ; if((*OpCode & (unsigned short int)(0x0040)) == (unsigned short int)(0x0))
00004848  2042      8521          move.l    D2,A0
0000484A  3010      8522          move.w    (A0),D0
0000484C  C07C 0040 8523          and.w     #64,D0
00004850  660E      8524          bne.s     DisassembleInstruction_213
                    8525   ; strcatInstruction(".W ") ;
00004852  4879 0000 8526          pea       @m68kde~2_150.L
00004856  6F6E      
00004858  4EB8 0CCC 8527          jsr       _strcatInstruction
0000485C  584F      8528          addq.w    #4,A7
0000485E  600C      8529          bra.s     DisassembleInstruction_214
                    8530   DisassembleInstruction_213:
                    8531   ; else
                    8532   ; strcatInstruction(".L ") ;
00004860  4879 0000 8533          pea       @m68kde~2_151.L
00004864  6F72      
00004866  4EB8 0CCC 8534          jsr       _strcatInstruction
0000486A  584F      8535          addq.w    #4,A7
                    8536   DisassembleInstruction_214:
                    8537   ; // movem  reg,-(An) if bit 10 = 0
                    8538   ; if((*OpCode & (unsigned short int)(0x0400))  == (unsigned short int)(0x0000))
0000486C  2042      8539          move.l    D2,A0
0000486E  3010      8540          move.w    (A0),D0
00004870  C07C 0400 8541          and.w     #1024,D0
00004874  6600 00D2 8542          bne       DisassembleInstruction_215
                    8543   ; {
                    8544   ; Mask = 0x8000 ;                     // bit 15 = 1
00004878  3D7C 8000 8545          move.w    #32768,-2(A6)
0000487C  FFFE      
                    8546   ; DoneSlash = 0 ;
0000487E  4246      8547          clr.w     D6
                    8548   ; for(i = 0; i < 16; i ++)    {
00004880  4284      8549          clr.l     D4
                    8550   DisassembleInstruction_217:
00004882  0C84 0000 8551          cmp.l     #16,D4
00004886  0010      
00004888  6C00 009E 8552          bge       DisassembleInstruction_219
                    8553   ; printf("") ;    // fixes bug otherwise the address registers doen't get printed (don't know why), something to do with sprintf I guess
0000488C  4879 0000 8554          pea       @m68kde~2_32.L
00004890  618C      
00004892  4EB9 0000 8555          jsr       _printf
00004896  551E      
00004898  584F      8556          addq.w    #4,A7
                    8557   ; if((OpCode[1] & Mask) == Mask)    {
0000489A  2042      8558          move.l    D2,A0
0000489C  3028 0002 8559          move.w    2(A0),D0
000048A0  C06E FFFE 8560          and.w     -2(A6),D0
000048A4  B06E FFFE 8561          cmp.w     -2(A6),D0
000048A8  6600 006E 8562          bne       DisassembleInstruction_220
                    8563   ; if(i < 8 )  {
000048AC  0C84 0000 8564          cmp.l     #8,D4
000048B0  0008      
000048B2  6C2C      8565          bge.s     DisassembleInstruction_222
                    8566   ; if(DoneSlash == 0)  {
000048B4  4A46      8567          tst.w     D6
000048B6  6614      8568          bne.s     DisassembleInstruction_224
                    8569   ; sprintf(TempString, "D%d", i) ;
000048B8  2F04      8570          move.l    D4,-(A7)
000048BA  4879 0000 8571          pea       @m68kde~2_257.L
000048BE  7236      
000048C0  2F0C      8572          move.l    A4,-(A7)
000048C2  4E95      8573          jsr       (A5)
000048C4  DEFC 000C 8574          add.w     #12,A7
                    8575   ; DoneSlash = 1;
000048C8  7C01      8576          moveq     #1,D6
000048CA  6010      8577          bra.s     DisassembleInstruction_225
                    8578   DisassembleInstruction_224:
                    8579   ; }
                    8580   ; else
                    8581   ; sprintf(TempString, "/D%d", i) ;
000048CC  2F04      8582          move.l    D4,-(A7)
000048CE  4879 0000 8583          pea       @m68kde~2_258.L
000048D2  723A      
000048D4  2F0C      8584          move.l    A4,-(A7)
000048D6  4E95      8585          jsr       (A5)
000048D8  DEFC 000C 8586          add.w     #12,A7
                    8587   DisassembleInstruction_225:
000048DC  6000 0032 8588          bra       DisassembleInstruction_227
                    8589   DisassembleInstruction_222:
                    8590   ; }
                    8591   ; else   {
                    8592   ; if(DoneSlash == 0)  {
000048E0  4A46      8593          tst.w     D6
000048E2  6618      8594          bne.s     DisassembleInstruction_226
                    8595   ; sprintf(TempString, "A%d", i-8) ;
000048E4  2204      8596          move.l    D4,D1
000048E6  5181      8597          subq.l    #8,D1
000048E8  2F01      8598          move.l    D1,-(A7)
000048EA  4879 0000 8599          pea       @m68kde~2_259.L
000048EE  7240      
000048F0  2F0C      8600          move.l    A4,-(A7)
000048F2  4E95      8601          jsr       (A5)
000048F4  DEFC 000C 8602          add.w     #12,A7
                    8603   ; DoneSlash = 1;
000048F8  7C01      8604          moveq     #1,D6
000048FA  6014      8605          bra.s     DisassembleInstruction_227
                    8606   DisassembleInstruction_226:
                    8607   ; }
                    8608   ; else
                    8609   ; sprintf(TempString, "/A%d", i-8) ;
000048FC  2204      8610          move.l    D4,D1
000048FE  5181      8611          subq.l    #8,D1
00004900  2F01      8612          move.l    D1,-(A7)
00004902  4879 0000 8613          pea       @m68kde~2_260.L
00004906  7244      
00004908  2F0C      8614          move.l    A4,-(A7)
0000490A  4E95      8615          jsr       (A5)
0000490C  DEFC 000C 8616          add.w     #12,A7
                    8617   DisassembleInstruction_227:
                    8618   ; }
                    8619   ; strcatInstruction(TempString) ;
00004910  2F0C      8620          move.l    A4,-(A7)
00004912  4EB8 0CCC 8621          jsr       _strcatInstruction
00004916  584F      8622          addq.w    #4,A7
                    8623   DisassembleInstruction_220:
                    8624   ; }
                    8625   ; Mask = Mask >> 1 ;
00004918  302E FFFE 8626          move.w    -2(A6),D0
0000491C  E240      8627          asr.w     #1,D0
0000491E  3D40 FFFE 8628          move.w    D0,-2(A6)
00004922  5284      8629          addq.l    #1,D4
00004924  6000 FF5C 8630          bra       DisassembleInstruction_217
                    8631   DisassembleInstruction_219:
                    8632   ; }
                    8633   ; strcatInstruction(",") ;
00004928  4879 0000 8634          pea       @m68kde~2_167.L
0000492C  6FBC      
0000492E  4EB8 0CCC 8635          jsr       _strcatInstruction
00004932  584F      8636          addq.w    #4,A7
                    8637   ; Decode6BitEA(OpCode,0,0,0) ;
00004934  42A7      8638          clr.l     -(A7)
00004936  42A7      8639          clr.l     -(A7)
00004938  42A7      8640          clr.l     -(A7)
0000493A  2F02      8641          move.l    D2,-(A7)
0000493C  4EB8 2E6C 8642          jsr       _Decode6BitEA
00004940  DEFC 0010 8643          add.w     #16,A7
00004944  6000 00C0 8644          bra       DisassembleInstruction_230
                    8645   DisassembleInstruction_215:
                    8646   ; }
                    8647   ; //movem  (An)+,reg
                    8648   ; else    {
                    8649   ; Decode6BitEA(OpCode,0,0,0) ;
00004948  42A7      8650          clr.l     -(A7)
0000494A  42A7      8651          clr.l     -(A7)
0000494C  42A7      8652          clr.l     -(A7)
0000494E  2F02      8653          move.l    D2,-(A7)
00004950  4EB8 2E6C 8654          jsr       _Decode6BitEA
00004954  DEFC 0010 8655          add.w     #16,A7
                    8656   ; strcatInstruction(",") ;
00004958  4879 0000 8657          pea       @m68kde~2_167.L
0000495C  6FBC      
0000495E  4EB8 0CCC 8658          jsr       _strcatInstruction
00004962  584F      8659          addq.w    #4,A7
                    8660   ; Mask = 0x0001 ;                     // bit 0 = 1
00004964  3D7C 0001 8661          move.w    #1,-2(A6)
00004968  FFFE      
                    8662   ; DoneSlash = 0 ;
0000496A  4246      8663          clr.w     D6
                    8664   ; for(i = 0; i < 16 ; i ++)    {
0000496C  4284      8665          clr.l     D4
                    8666   DisassembleInstruction_228:
0000496E  0C84 0000 8667          cmp.l     #16,D4
00004972  0010      
00004974  6C00 0090 8668          bge       DisassembleInstruction_230
                    8669   ; if((OpCode[1] & Mask) == Mask)    {
00004978  2042      8670          move.l    D2,A0
0000497A  3028 0002 8671          move.w    2(A0),D0
0000497E  C06E FFFE 8672          and.w     -2(A6),D0
00004982  B06E FFFE 8673          cmp.w     -2(A6),D0
00004986  6600 006E 8674          bne       DisassembleInstruction_231
                    8675   ; if(i < 8)   {       // data registers in bits 7-0
0000498A  0C84 0000 8676          cmp.l     #8,D4
0000498E  0008      
00004990  6C2C      8677          bge.s     DisassembleInstruction_233
                    8678   ; if(DoneSlash == 0)  {
00004992  4A46      8679          tst.w     D6
00004994  6614      8680          bne.s     DisassembleInstruction_235
                    8681   ; sprintf(TempString, "D%d", i) ;
00004996  2F04      8682          move.l    D4,-(A7)
00004998  4879 0000 8683          pea       @m68kde~2_257.L
0000499C  7236      
0000499E  2F0C      8684          move.l    A4,-(A7)
000049A0  4E95      8685          jsr       (A5)
000049A2  DEFC 000C 8686          add.w     #12,A7
                    8687   ; DoneSlash = 1;
000049A6  7C01      8688          moveq     #1,D6
000049A8  6010      8689          bra.s     DisassembleInstruction_236
                    8690   DisassembleInstruction_235:
                    8691   ; }
                    8692   ; else
                    8693   ; sprintf(TempString, "/D%d", i) ;
000049AA  2F04      8694          move.l    D4,-(A7)
000049AC  4879 0000 8695          pea       @m68kde~2_258.L
000049B0  723A      
000049B2  2F0C      8696          move.l    A4,-(A7)
000049B4  4E95      8697          jsr       (A5)
000049B6  DEFC 000C 8698          add.w     #12,A7
                    8699   DisassembleInstruction_236:
000049BA  6000 0032 8700          bra       DisassembleInstruction_238
                    8701   DisassembleInstruction_233:
                    8702   ; }
                    8703   ; else    {
                    8704   ; if(DoneSlash == 0)  {
000049BE  4A46      8705          tst.w     D6
000049C0  6618      8706          bne.s     DisassembleInstruction_237
                    8707   ; sprintf(TempString, "A%d", i-8) ;
000049C2  2204      8708          move.l    D4,D1
000049C4  5181      8709          subq.l    #8,D1
000049C6  2F01      8710          move.l    D1,-(A7)
000049C8  4879 0000 8711          pea       @m68kde~2_259.L
000049CC  7240      
000049CE  2F0C      8712          move.l    A4,-(A7)
000049D0  4E95      8713          jsr       (A5)
000049D2  DEFC 000C 8714          add.w     #12,A7
                    8715   ; DoneSlash = 1;
000049D6  7C01      8716          moveq     #1,D6
000049D8  6014      8717          bra.s     DisassembleInstruction_238
                    8718   DisassembleInstruction_237:
                    8719   ; }
                    8720   ; else
                    8721   ; sprintf(TempString, "/A%d", i-8) ;
000049DA  2204      8722          move.l    D4,D1
000049DC  5181      8723          subq.l    #8,D1
000049DE  2F01      8724          move.l    D1,-(A7)
000049E0  4879 0000 8725          pea       @m68kde~2_260.L
000049E4  7244      
000049E6  2F0C      8726          move.l    A4,-(A7)
000049E8  4E95      8727          jsr       (A5)
000049EA  DEFC 000C 8728          add.w     #12,A7
                    8729   DisassembleInstruction_238:
                    8730   ; }
                    8731   ; strcatInstruction(TempString) ;
000049EE  2F0C      8732          move.l    A4,-(A7)
000049F0  4EB8 0CCC 8733          jsr       _strcatInstruction
000049F4  584F      8734          addq.w    #4,A7
                    8735   DisassembleInstruction_231:
                    8736   ; }
                    8737   ; Mask = Mask << 1 ;
000049F6  302E FFFE 8738          move.w    -2(A6),D0
000049FA  E340      8739          asl.w     #1,D0
000049FC  3D40 FFFE 8740          move.w    D0,-2(A6)
00004A00  5284      8741          addq.l    #1,D4
00004A02  6000 FF6A 8742          bra       DisassembleInstruction_228
                    8743   DisassembleInstruction_230:
                    8744   ; }
                    8745   ; }
                    8746   ; }
                    8747   ; }
                    8748   ; /////////////////////////////////////////////////////////////////////////////////
                    8749   ; // if instruction is MOVEP
                    8750   ; /////////////////////////////////////////////////////////////////////////////////
                    8751   ; if((*OpCode & (unsigned short int)(0xF038)) == (unsigned short int)(0x0008))
00004A06  2042      8752          move.l    D2,A0
00004A08  3010      8753          move.w    (A0),D0
00004A0A  C07C F038 8754          and.w     #61496,D0
00004A0E  0C40 0008 8755          cmp.w     #8,D0
00004A12  6600 0112 8756          bne       DisassembleInstruction_247
                    8757   ; {
                    8758   ; InstructionSize = 1;
00004A16  24BC 0000 8759          move.l    #1,(A2)
00004A1A  0001      
                    8760   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007);
00004A1C  2042      8761          move.l    D2,A0
00004A1E  3010      8762          move.w    (A0),D0
00004A20  E040      8763          asr.w     #8,D0
00004A22  E240      8764          asr.w     #1,D0
00004A24  C07C 0007 8765          and.w     #7,D0
00004A28  3A00      8766          move.w    D0,D5
                    8767   ; AddressRegister = (*OpCode & (unsigned short int)(0x0007)) ;
00004A2A  2042      8768          move.l    D2,A0
00004A2C  3010      8769          move.w    (A0),D0
00004A2E  C07C 0007 8770          and.w     #7,D0
00004A32  3D40 FFF8 8771          move.w    D0,-8(A6)
                    8772   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007)  ;
00004A36  2042      8773          move.l    D2,A0
00004A38  3010      8774          move.w    (A0),D0
00004A3A  EC40      8775          asr.w     #6,D0
00004A3C  C07C 0007 8776          and.w     #7,D0
00004A40  3600      8777          move.w    D0,D3
                    8778   ; InstructionSize++ ;
00004A42  5292      8779          addq.l    #1,(A2)
                    8780   ; if(OpMode == (unsigned short int)(0x4)) // transfer word from memory to register
00004A44  0C43 0004 8781          cmp.w     #4,D3
00004A48  6634      8782          bne.s     DisassembleInstruction_241
                    8783   ; sprintf(Instruction, "MOVEP.W $%X(A%d),D%d", OpCode[1], AddressRegister, DataRegister) ;
00004A4A  CABC 0000 8784          and.l     #65535,D5
00004A4E  FFFF      
00004A50  2F05      8785          move.l    D5,-(A7)
00004A52  322E FFF8 8786          move.w    -8(A6),D1
00004A56  C2BC 0000 8787          and.l     #65535,D1
00004A5A  FFFF      
00004A5C  2F01      8788          move.l    D1,-(A7)
00004A5E  2042      8789          move.l    D2,A0
00004A60  3228 0002 8790          move.w    2(A0),D1
00004A64  48C1      8791          ext.l     D1
00004A66  2F01      8792          move.l    D1,-(A7)
00004A68  4879 0000 8793          pea       @m68kde~2_261.L
00004A6C  724A      
00004A6E  4879 0B00 8794          pea       _Instruction.L
00004A72  04E2      
00004A74  4E95      8795          jsr       (A5)
00004A76  DEFC 0014 8796          add.w     #20,A7
00004A7A  6000 00AA 8797          bra       DisassembleInstruction_247
                    8798   DisassembleInstruction_241:
                    8799   ; else if(OpMode == (unsigned short int)(0x5)) // transfer long from memory to register
00004A7E  0C43 0005 8800          cmp.w     #5,D3
00004A82  6634      8801          bne.s     DisassembleInstruction_243
                    8802   ; sprintf(Instruction, "MOVEP.L $%X(A%d),D%d", OpCode[1], AddressRegister, DataRegister) ;
00004A84  CABC 0000 8803          and.l     #65535,D5
00004A88  FFFF      
00004A8A  2F05      8804          move.l    D5,-(A7)
00004A8C  322E FFF8 8805          move.w    -8(A6),D1
00004A90  C2BC 0000 8806          and.l     #65535,D1
00004A94  FFFF      
00004A96  2F01      8807          move.l    D1,-(A7)
00004A98  2042      8808          move.l    D2,A0
00004A9A  3228 0002 8809          move.w    2(A0),D1
00004A9E  48C1      8810          ext.l     D1
00004AA0  2F01      8811          move.l    D1,-(A7)
00004AA2  4879 0000 8812          pea       @m68kde~2_262.L
00004AA6  7260      
00004AA8  4879 0B00 8813          pea       _Instruction.L
00004AAC  04E2      
00004AAE  4E95      8814          jsr       (A5)
00004AB0  DEFC 0014 8815          add.w     #20,A7
00004AB4  6000 0070 8816          bra       DisassembleInstruction_247
                    8817   DisassembleInstruction_243:
                    8818   ; else if(OpMode == (unsigned short int)(0x6)) // transfer long from register to memory
00004AB8  0C43 0006 8819          cmp.w     #6,D3
00004ABC  6632      8820          bne.s     DisassembleInstruction_245
                    8821   ; sprintf(Instruction, "MOVEP.W D%d,$%X(A%d)", DataRegister, OpCode[1], AddressRegister ) ;
00004ABE  322E FFF8 8822          move.w    -8(A6),D1
00004AC2  C2BC 0000 8823          and.l     #65535,D1
00004AC6  FFFF      
00004AC8  2F01      8824          move.l    D1,-(A7)
00004ACA  2042      8825          move.l    D2,A0
00004ACC  3228 0002 8826          move.w    2(A0),D1
00004AD0  48C1      8827          ext.l     D1
00004AD2  2F01      8828          move.l    D1,-(A7)
00004AD4  CABC 0000 8829          and.l     #65535,D5
00004AD8  FFFF      
00004ADA  2F05      8830          move.l    D5,-(A7)
00004ADC  4879 0000 8831          pea       @m68kde~2_263.L
00004AE0  7276      
00004AE2  4879 0B00 8832          pea       _Instruction.L
00004AE6  04E2      
00004AE8  4E95      8833          jsr       (A5)
00004AEA  DEFC 0014 8834          add.w     #20,A7
00004AEE  6036      8835          bra.s     DisassembleInstruction_247
                    8836   DisassembleInstruction_245:
                    8837   ; else if(OpMode == (unsigned short int)(0x7)) // transfer long from register to memory
00004AF0  0C43 0007 8838          cmp.w     #7,D3
00004AF4  6630      8839          bne.s     DisassembleInstruction_247
                    8840   ; sprintf(Instruction, "MOVEP.L D%d,$%X(A%d)", DataRegister, OpCode[1], AddressRegister ) ;
00004AF6  322E FFF8 8841          move.w    -8(A6),D1
00004AFA  C2BC 0000 8842          and.l     #65535,D1
00004AFE  FFFF      
00004B00  2F01      8843          move.l    D1,-(A7)
00004B02  2042      8844          move.l    D2,A0
00004B04  3228 0002 8845          move.w    2(A0),D1
00004B08  48C1      8846          ext.l     D1
00004B0A  2F01      8847          move.l    D1,-(A7)
00004B0C  CABC 0000 8848          and.l     #65535,D5
00004B10  FFFF      
00004B12  2F05      8849          move.l    D5,-(A7)
00004B14  4879 0000 8850          pea       @m68kde~2_264.L
00004B18  728C      
00004B1A  4879 0B00 8851          pea       _Instruction.L
00004B1E  04E2      
00004B20  4E95      8852          jsr       (A5)
00004B22  DEFC 0014 8853          add.w     #20,A7
                    8854   DisassembleInstruction_247:
                    8855   ; }
                    8856   ; /////////////////////////////////////////////////////////////////////////////////
                    8857   ; // if instruction is MOVEQ
                    8858   ; /////////////////////////////////////////////////////////////////////////////////
                    8859   ; if((*OpCode & (unsigned short int)(0xF100)) == (unsigned short int)(0x7000))
00004B26  2042      8860          move.l    D2,A0
00004B28  3010      8861          move.w    (A0),D0
00004B2A  C07C F100 8862          and.w     #61696,D0
00004B2E  0C40 7000 8863          cmp.w     #28672,D0
00004B32  6600 0040 8864          bne       DisassembleInstruction_249
                    8865   ; {
                    8866   ; InstructionSize = 1;
00004B36  24BC 0000 8867          move.l    #1,(A2)
00004B3A  0001      
                    8868   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007) ;
00004B3C  2042      8869          move.l    D2,A0
00004B3E  3010      8870          move.w    (A0),D0
00004B40  E040      8871          asr.w     #8,D0
00004B42  E240      8872          asr.w     #1,D0
00004B44  C07C 0007 8873          and.w     #7,D0
00004B48  3A00      8874          move.w    D0,D5
                    8875   ; sprintf(Instruction, "MOVEQ #$%X,D%d", (*OpCode & (unsigned short int)(0x00FF)), DataRegister) ;
00004B4A  CABC 0000 8876          and.l     #65535,D5
00004B4E  FFFF      
00004B50  2F05      8877          move.l    D5,-(A7)
00004B52  2042      8878          move.l    D2,A0
00004B54  3210      8879          move.w    (A0),D1
00004B56  C27C 00FF 8880          and.w     #255,D1
00004B5A  C2BC 0000 8881          and.l     #65535,D1
00004B5E  FFFF      
00004B60  2F01      8882          move.l    D1,-(A7)
00004B62  4879 0000 8883          pea       @m68kde~2_265.L
00004B66  72A2      
00004B68  4879 0B00 8884          pea       _Instruction.L
00004B6C  04E2      
00004B6E  4E95      8885          jsr       (A5)
00004B70  DEFC 0010 8886          add.w     #16,A7
                    8887   DisassembleInstruction_249:
                    8888   ; }
                    8889   ; /////////////////////////////////////////////////////////////////////////////////
                    8890   ; // if instruction is MULS.W
                    8891   ; /////////////////////////////////////////////////////////////////////////////////
                    8892   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0xC1C0))
00004B74  2042      8893          move.l    D2,A0
00004B76  3010      8894          move.w    (A0),D0
00004B78  C07C F1C0 8895          and.w     #61888,D0
00004B7C  0C40 C1C0 8896          cmp.w     #49600,D0
00004B80  6600 004E 8897          bne       DisassembleInstruction_251
                    8898   ; {
                    8899   ; InstructionSize = 1;
00004B84  24BC 0000 8900          move.l    #1,(A2)
00004B88  0001      
                    8901   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007);
00004B8A  2042      8902          move.l    D2,A0
00004B8C  3010      8903          move.w    (A0),D0
00004B8E  E040      8904          asr.w     #8,D0
00004B90  E240      8905          asr.w     #1,D0
00004B92  C07C 0007 8906          and.w     #7,D0
00004B96  3A00      8907          move.w    D0,D5
                    8908   ; strcpyInstruction("MULS ");
00004B98  4879 0000 8909          pea       @m68kde~2_266.L
00004B9C  72B2      
00004B9E  4E93      8910          jsr       (A3)
00004BA0  584F      8911          addq.w    #4,A7
                    8912   ; Decode6BitEA(OpCode,0,0,0) ;
00004BA2  42A7      8913          clr.l     -(A7)
00004BA4  42A7      8914          clr.l     -(A7)
00004BA6  42A7      8915          clr.l     -(A7)
00004BA8  2F02      8916          move.l    D2,-(A7)
00004BAA  4EB8 2E6C 8917          jsr       _Decode6BitEA
00004BAE  DEFC 0010 8918          add.w     #16,A7
                    8919   ; sprintf(TempString, ",D%d", DataRegister) ;
00004BB2  CABC 0000 8920          and.l     #65535,D5
00004BB6  FFFF      
00004BB8  2F05      8921          move.l    D5,-(A7)
00004BBA  4879 0000 8922          pea       @m68kde~2_222.L
00004BBE  7108      
00004BC0  2F0C      8923          move.l    A4,-(A7)
00004BC2  4E95      8924          jsr       (A5)
00004BC4  DEFC 000C 8925          add.w     #12,A7
                    8926   ; strcatInstruction(TempString);
00004BC8  2F0C      8927          move.l    A4,-(A7)
00004BCA  4EB8 0CCC 8928          jsr       _strcatInstruction
00004BCE  584F      8929          addq.w    #4,A7
                    8930   DisassembleInstruction_251:
                    8931   ; }
                    8932   ; /////////////////////////////////////////////////////////////////////////////////
                    8933   ; // if instruction is MULU.W
                    8934   ; /////////////////////////////////////////////////////////////////////////////////
                    8935   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0xC0C0))
00004BD0  2042      8936          move.l    D2,A0
00004BD2  3010      8937          move.w    (A0),D0
00004BD4  C07C F1C0 8938          and.w     #61888,D0
00004BD8  0C40 C0C0 8939          cmp.w     #49344,D0
00004BDC  6600 004E 8940          bne       DisassembleInstruction_253
                    8941   ; {
                    8942   ; InstructionSize = 1;
00004BE0  24BC 0000 8943          move.l    #1,(A2)
00004BE4  0001      
                    8944   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007);
00004BE6  2042      8945          move.l    D2,A0
00004BE8  3010      8946          move.w    (A0),D0
00004BEA  E040      8947          asr.w     #8,D0
00004BEC  E240      8948          asr.w     #1,D0
00004BEE  C07C 0007 8949          and.w     #7,D0
00004BF2  3A00      8950          move.w    D0,D5
                    8951   ; strcpyInstruction("MULU ");
00004BF4  4879 0000 8952          pea       @m68kde~2_267.L
00004BF8  72B8      
00004BFA  4E93      8953          jsr       (A3)
00004BFC  584F      8954          addq.w    #4,A7
                    8955   ; Decode6BitEA(OpCode,0,0,0) ;
00004BFE  42A7      8956          clr.l     -(A7)
00004C00  42A7      8957          clr.l     -(A7)
00004C02  42A7      8958          clr.l     -(A7)
00004C04  2F02      8959          move.l    D2,-(A7)
00004C06  4EB8 2E6C 8960          jsr       _Decode6BitEA
00004C0A  DEFC 0010 8961          add.w     #16,A7
                    8962   ; sprintf(TempString, ",D%d", DataRegister) ;
00004C0E  CABC 0000 8963          and.l     #65535,D5
00004C12  FFFF      
00004C14  2F05      8964          move.l    D5,-(A7)
00004C16  4879 0000 8965          pea       @m68kde~2_222.L
00004C1A  7108      
00004C1C  2F0C      8966          move.l    A4,-(A7)
00004C1E  4E95      8967          jsr       (A5)
00004C20  DEFC 000C 8968          add.w     #12,A7
                    8969   ; strcatInstruction(TempString);
00004C24  2F0C      8970          move.l    A4,-(A7)
00004C26  4EB8 0CCC 8971          jsr       _strcatInstruction
00004C2A  584F      8972          addq.w    #4,A7
                    8973   DisassembleInstruction_253:
                    8974   ; }
                    8975   ; /////////////////////////////////////////////////////////////////////////////////
                    8976   ; // if instruction is NBCD <EA>
                    8977   ; /////////////////////////////////////////////////////////////////////////////////
                    8978   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4800))
00004C2C  2042      8979          move.l    D2,A0
00004C2E  3010      8980          move.w    (A0),D0
00004C30  C07C FFC0 8981          and.w     #65472,D0
00004C34  0C40 4800 8982          cmp.w     #18432,D0
00004C38  6620      8983          bne.s     DisassembleInstruction_255
                    8984   ; {
                    8985   ; InstructionSize = 1;
00004C3A  24BC 0000 8986          move.l    #1,(A2)
00004C3E  0001      
                    8987   ; strcpyInstruction("NBCD ");
00004C40  4879 0000 8988          pea       @m68kde~2_268.L
00004C44  72BE      
00004C46  4E93      8989          jsr       (A3)
00004C48  584F      8990          addq.w    #4,A7
                    8991   ; Decode6BitEA(OpCode,0,0,0);
00004C4A  42A7      8992          clr.l     -(A7)
00004C4C  42A7      8993          clr.l     -(A7)
00004C4E  42A7      8994          clr.l     -(A7)
00004C50  2F02      8995          move.l    D2,-(A7)
00004C52  4EB8 2E6C 8996          jsr       _Decode6BitEA
00004C56  DEFC 0010 8997          add.w     #16,A7
                    8998   DisassembleInstruction_255:
                    8999   ; }
                    9000   ; /////////////////////////////////////////////////////////////////////////////////
                    9001   ; // if instruction is NEG <EA>
                    9002   ; /////////////////////////////////////////////////////////////////////////////////
                    9003   ; if((*OpCode & (unsigned short int)(0xFF00)) == (unsigned short int)(0x4400))
00004C5A  2042      9004          move.l    D2,A0
00004C5C  3010      9005          move.w    (A0),D0
00004C5E  C07C FF00 9006          and.w     #65280,D0
00004C62  0C40 4400 9007          cmp.w     #17408,D0
00004C66  6600 0046 9008          bne       DisassembleInstruction_259
                    9009   ; {
                    9010   ; if(((*OpCode >> 6) & (unsigned short int)(0x0003)) != (unsigned short int)(0x0003))
00004C6A  2042      9011          move.l    D2,A0
00004C6C  3010      9012          move.w    (A0),D0
00004C6E  EC40      9013          asr.w     #6,D0
00004C70  C07C 0003 9014          and.w     #3,D0
00004C74  0C40 0003 9015          cmp.w     #3,D0
00004C78  6700 0034 9016          beq       DisassembleInstruction_259
                    9017   ; {
                    9018   ; InstructionSize = 1;
00004C7C  24BC 0000 9019          move.l    #1,(A2)
00004C80  0001      
                    9020   ; strcpyInstruction("NEG");
00004C82  4879 0000 9021          pea       @m68kde~2_269.L
00004C86  72C4      
00004C88  4E93      9022          jsr       (A3)
00004C8A  584F      9023          addq.w    #4,A7
                    9024   ; Decode2BitOperandSize(*OpCode) ;
00004C8C  2042      9025          move.l    D2,A0
00004C8E  3210      9026          move.w    (A0),D1
00004C90  C2BC 0000 9027          and.l     #65535,D1
00004C94  FFFF      
00004C96  2F01      9028          move.l    D1,-(A7)
00004C98  4EB8 2BD8 9029          jsr       _Decode2BitOperandSize
00004C9C  584F      9030          addq.w    #4,A7
                    9031   ; Decode6BitEA(OpCode,0,0,0);
00004C9E  42A7      9032          clr.l     -(A7)
00004CA0  42A7      9033          clr.l     -(A7)
00004CA2  42A7      9034          clr.l     -(A7)
00004CA4  2F02      9035          move.l    D2,-(A7)
00004CA6  4EB8 2E6C 9036          jsr       _Decode6BitEA
00004CAA  DEFC 0010 9037          add.w     #16,A7
                    9038   DisassembleInstruction_259:
                    9039   ; }
                    9040   ; }
                    9041   ; /////////////////////////////////////////////////////////////////////////////////
                    9042   ; // if instruction is NEGX <EA>
                    9043   ; /////////////////////////////////////////////////////////////////////////////////
                    9044   ; if((*OpCode & (unsigned short int)(0xFF00)) == (unsigned short int)(0x4000))
00004CAE  2042      9045          move.l    D2,A0
00004CB0  3010      9046          move.w    (A0),D0
00004CB2  C07C FF00 9047          and.w     #65280,D0
00004CB6  0C40 4000 9048          cmp.w     #16384,D0
00004CBA  6600 0046 9049          bne       DisassembleInstruction_263
                    9050   ; {
                    9051   ; if(((*OpCode >> 6) & (unsigned short int)(0x0003)) != (unsigned short int)(0x0003))
00004CBE  2042      9052          move.l    D2,A0
00004CC0  3010      9053          move.w    (A0),D0
00004CC2  EC40      9054          asr.w     #6,D0
00004CC4  C07C 0003 9055          and.w     #3,D0
00004CC8  0C40 0003 9056          cmp.w     #3,D0
00004CCC  6700 0034 9057          beq       DisassembleInstruction_263
                    9058   ; {
                    9059   ; InstructionSize = 1;
00004CD0  24BC 0000 9060          move.l    #1,(A2)
00004CD4  0001      
                    9061   ; strcpyInstruction("NEGX");
00004CD6  4879 0000 9062          pea       @m68kde~2_270.L
00004CDA  72C8      
00004CDC  4E93      9063          jsr       (A3)
00004CDE  584F      9064          addq.w    #4,A7
                    9065   ; Decode2BitOperandSize(*OpCode) ;
00004CE0  2042      9066          move.l    D2,A0
00004CE2  3210      9067          move.w    (A0),D1
00004CE4  C2BC 0000 9068          and.l     #65535,D1
00004CE8  FFFF      
00004CEA  2F01      9069          move.l    D1,-(A7)
00004CEC  4EB8 2BD8 9070          jsr       _Decode2BitOperandSize
00004CF0  584F      9071          addq.w    #4,A7
                    9072   ; Decode6BitEA(OpCode,0,0,0);
00004CF2  42A7      9073          clr.l     -(A7)
00004CF4  42A7      9074          clr.l     -(A7)
00004CF6  42A7      9075          clr.l     -(A7)
00004CF8  2F02      9076          move.l    D2,-(A7)
00004CFA  4EB8 2E6C 9077          jsr       _Decode6BitEA
00004CFE  DEFC 0010 9078          add.w     #16,A7
                    9079   DisassembleInstruction_263:
                    9080   ; }
                    9081   ; }
                    9082   ; /////////////////////////////////////////////////////////////////////////////////
                    9083   ; // if instruction is NOP
                    9084   ; /////////////////////////////////////////////////////////////////////////////////
                    9085   ; if(*OpCode == (unsigned short int)(0x4E71))
00004D02  2042      9086          move.l    D2,A0
00004D04  3010      9087          move.w    (A0),D0
00004D06  0C40 4E71 9088          cmp.w     #20081,D0
00004D0A  6610      9089          bne.s     DisassembleInstruction_265
                    9090   ; {
                    9091   ; InstructionSize = 1;
00004D0C  24BC 0000 9092          move.l    #1,(A2)
00004D10  0001      
                    9093   ; strcpyInstruction("NOP");
00004D12  4879 0000 9094          pea       @m68kde~2_271.L
00004D16  72CE      
00004D18  4E93      9095          jsr       (A3)
00004D1A  584F      9096          addq.w    #4,A7
                    9097   DisassembleInstruction_265:
                    9098   ; }
                    9099   ; /////////////////////////////////////////////////////////////////////////////////
                    9100   ; // if instruction is NOT <EA>
                    9101   ; /////////////////////////////////////////////////////////////////////////////////
                    9102   ; if((*OpCode & (unsigned short int)(0xFF00)) == (unsigned short int)(0x4600))
00004D1C  2042      9103          move.l    D2,A0
00004D1E  3010      9104          move.w    (A0),D0
00004D20  C07C FF00 9105          and.w     #65280,D0
00004D24  0C40 4600 9106          cmp.w     #17920,D0
00004D28  6600 0046 9107          bne       DisassembleInstruction_269
                    9108   ; {
                    9109   ; if(((*OpCode >> 6) & (unsigned short int)(0x0003)) != (unsigned short int)(0x0003))
00004D2C  2042      9110          move.l    D2,A0
00004D2E  3010      9111          move.w    (A0),D0
00004D30  EC40      9112          asr.w     #6,D0
00004D32  C07C 0003 9113          and.w     #3,D0
00004D36  0C40 0003 9114          cmp.w     #3,D0
00004D3A  6700 0034 9115          beq       DisassembleInstruction_269
                    9116   ; {
                    9117   ; InstructionSize = 1;
00004D3E  24BC 0000 9118          move.l    #1,(A2)
00004D42  0001      
                    9119   ; strcpyInstruction("NOT");
00004D44  4879 0000 9120          pea       @m68kde~2_272.L
00004D48  72D2      
00004D4A  4E93      9121          jsr       (A3)
00004D4C  584F      9122          addq.w    #4,A7
                    9123   ; Decode2BitOperandSize(*OpCode) ;
00004D4E  2042      9124          move.l    D2,A0
00004D50  3210      9125          move.w    (A0),D1
00004D52  C2BC 0000 9126          and.l     #65535,D1
00004D56  FFFF      
00004D58  2F01      9127          move.l    D1,-(A7)
00004D5A  4EB8 2BD8 9128          jsr       _Decode2BitOperandSize
00004D5E  584F      9129          addq.w    #4,A7
                    9130   ; Decode6BitEA(OpCode,0,0,0);
00004D60  42A7      9131          clr.l     -(A7)
00004D62  42A7      9132          clr.l     -(A7)
00004D64  42A7      9133          clr.l     -(A7)
00004D66  2F02      9134          move.l    D2,-(A7)
00004D68  4EB8 2E6C 9135          jsr       _Decode6BitEA
00004D6C  DEFC 0010 9136          add.w     #16,A7
                    9137   DisassembleInstruction_269:
                    9138   ; }
                    9139   ; }
                    9140   ; /////////////////////////////////////////////////////////////////////////////////
                    9141   ; // if instruction is OR <EA>,Dn or OR Dn,<EA>
                    9142   ; /////////////////////////////////////////////////////////////////////////////////
                    9143   ; if((*OpCode & (unsigned short int)(0xF000)) == (unsigned short int)(0x8000))
00004D70  2042      9144          move.l    D2,A0
00004D72  3010      9145          move.w    (A0),D0
00004D74  C07C F000 9146          and.w     #61440,D0
00004D78  0C40 8000 9147          cmp.w     #32768,D0
00004D7C  6600 0038 9148          bne       DisassembleInstruction_273
                    9149   ; {
                    9150   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007) ;
00004D80  2042      9151          move.l    D2,A0
00004D82  3010      9152          move.w    (A0),D0
00004D84  EC40      9153          asr.w     #6,D0
00004D86  C07C 0007 9154          and.w     #7,D0
00004D8A  3600      9155          move.w    D0,D3
                    9156   ; if( (OpMode <= (unsigned short int)(0x0002)) ||
00004D8C  0C43 0002 9157          cmp.w     #2,D3
00004D90  630C      9158          bls.s     DisassembleInstruction_275
00004D92  0C43 0004 9159          cmp.w     #4,D3
00004D96  651E      9160          blo.s     DisassembleInstruction_273
00004D98  0C43 0006 9161          cmp.w     #6,D3
00004D9C  6218      9162          bhi.s     DisassembleInstruction_273
                    9163   DisassembleInstruction_275:
                    9164   ; ((OpMode >= (unsigned short int)(0x0004)) && (OpMode <= (unsigned short int)(0x0006))))
                    9165   ; {
                    9166   ; InstructionSize = 1;
00004D9E  24BC 0000 9167          move.l    #1,(A2)
00004DA2  0001      
                    9168   ; strcpyInstruction("OR") ;
00004DA4  4879 0000 9169          pea       @m68kde~2_273.L
00004DA8  72D6      
00004DAA  4E93      9170          jsr       (A3)
00004DAC  584F      9171          addq.w    #4,A7
                    9172   ; Decode3BitOperandMode(OpCode) ;
00004DAE  2F02      9173          move.l    D2,-(A7)
00004DB0  4EB8 3294 9174          jsr       _Decode3BitOperandMode
00004DB4  584F      9175          addq.w    #4,A7
                    9176   DisassembleInstruction_273:
                    9177   ; }
                    9178   ; }
                    9179   ; /////////////////////////////////////////////////////////////////////////////////
                    9180   ; // if instruction is ORI to CCR
                    9181   ; /////////////////////////////////////////////////////////////////////////////////
                    9182   ; if(*OpCode == (unsigned short int)(0x003C))   {
00004DB6  2042      9183          move.l    D2,A0
00004DB8  3010      9184          move.w    (A0),D0
00004DBA  0C40 003C 9185          cmp.w     #60,D0
00004DBE  662A      9186          bne.s     DisassembleInstruction_276
                    9187   ; sprintf(Instruction, "ORI #$%2X,CCR", OpCode[1] & (unsigned short int)(0x00FF)) ;
00004DC0  2042      9188          move.l    D2,A0
00004DC2  3228 0002 9189          move.w    2(A0),D1
00004DC6  C27C 00FF 9190          and.w     #255,D1
00004DCA  C2BC 0000 9191          and.l     #65535,D1
00004DCE  FFFF      
00004DD0  2F01      9192          move.l    D1,-(A7)
00004DD2  4879 0000 9193          pea       @m68kde~2_274.L
00004DD6  72DA      
00004DD8  4879 0B00 9194          pea       _Instruction.L
00004DDC  04E2      
00004DDE  4E95      9195          jsr       (A5)
00004DE0  DEFC 000C 9196          add.w     #12,A7
                    9197   ; InstructionSize = 2;
00004DE4  24BC 0000 9198          move.l    #2,(A2)
00004DE8  0002      
                    9199   DisassembleInstruction_276:
                    9200   ; }
                    9201   ; /////////////////////////////////////////////////////////////////////////////////
                    9202   ; // if instruction is ORI #data,SR
                    9203   ; /////////////////////////////////////////////////////////////////////////////////
                    9204   ; if(*OpCode  == (unsigned short int)(0x007c))
00004DEA  2042      9205          move.l    D2,A0
00004DEC  3010      9206          move.w    (A0),D0
00004DEE  0C40 007C 9207          cmp.w     #124,D0
00004DF2  6622      9208          bne.s     DisassembleInstruction_278
                    9209   ; {
                    9210   ; InstructionSize = 2;
00004DF4  24BC 0000 9211          move.l    #2,(A2)
00004DF8  0002      
                    9212   ; sprintf(Instruction, "ORI  #$%X,SR", OpCode[1]);
00004DFA  2042      9213          move.l    D2,A0
00004DFC  3228 0002 9214          move.w    2(A0),D1
00004E00  48C1      9215          ext.l     D1
00004E02  2F01      9216          move.l    D1,-(A7)
00004E04  4879 0000 9217          pea       @m68kde~2_275.L
00004E08  72E8      
00004E0A  4879 0B00 9218          pea       _Instruction.L
00004E0E  04E2      
00004E10  4E95      9219          jsr       (A5)
00004E12  DEFC 000C 9220          add.w     #12,A7
                    9221   DisassembleInstruction_278:
                    9222   ; }
                    9223   ; /////////////////////////////////////////////////////////////////////////////////
                    9224   ; // if instruction is PEA
                    9225   ; /////////////////////////////////////////////////////////////////////////////////
                    9226   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4840))
00004E16  2042      9227          move.l    D2,A0
00004E18  3010      9228          move.w    (A0),D0
00004E1A  C07C FFC0 9229          and.w     #65472,D0
00004E1E  0C40 4840 9230          cmp.w     #18496,D0
00004E22  6620      9231          bne.s     DisassembleInstruction_280
                    9232   ; {
                    9233   ; InstructionSize = 1;
00004E24  24BC 0000 9234          move.l    #1,(A2)
00004E28  0001      
                    9235   ; strcpyInstruction("PEA ");
00004E2A  4879 0000 9236          pea       @m68kde~2_276.L
00004E2E  72F6      
00004E30  4E93      9237          jsr       (A3)
00004E32  584F      9238          addq.w    #4,A7
                    9239   ; Decode6BitEA(OpCode,0,0,0);
00004E34  42A7      9240          clr.l     -(A7)
00004E36  42A7      9241          clr.l     -(A7)
00004E38  42A7      9242          clr.l     -(A7)
00004E3A  2F02      9243          move.l    D2,-(A7)
00004E3C  4EB8 2E6C 9244          jsr       _Decode6BitEA
00004E40  DEFC 0010 9245          add.w     #16,A7
                    9246   DisassembleInstruction_280:
                    9247   ; }
                    9248   ; /////////////////////////////////////////////////////////////////////////////////
                    9249   ; // if instruction is reset
                    9250   ; /////////////////////////////////////////////////////////////////////////////////
                    9251   ; if(*OpCode  == (unsigned short int)(0x4E70))
00004E44  2042      9252          move.l    D2,A0
00004E46  3010      9253          move.w    (A0),D0
00004E48  0C40 4E70 9254          cmp.w     #20080,D0
00004E4C  6616      9255          bne.s     DisassembleInstruction_282
                    9256   ; {
                    9257   ; InstructionSize = 1;
00004E4E  24BC 0000 9258          move.l    #1,(A2)
00004E52  0001      
                    9259   ; sprintf(Instruction, "RESET");
00004E54  4879 0000 9260          pea       @m68kde~2_277.L
00004E58  72FC      
00004E5A  4879 0B00 9261          pea       _Instruction.L
00004E5E  04E2      
00004E60  4E95      9262          jsr       (A5)
00004E62  504F      9263          addq.w    #8,A7
                    9264   DisassembleInstruction_282:
                    9265   ; }
                    9266   ; /////////////////////////////////////////////////////////////////////////////////
                    9267   ; // if instruction is RTE
                    9268   ; /////////////////////////////////////////////////////////////////////////////////
                    9269   ; if(*OpCode  == (unsigned short int)(0x4E73))
00004E64  2042      9270          move.l    D2,A0
00004E66  3010      9271          move.w    (A0),D0
00004E68  0C40 4E73 9272          cmp.w     #20083,D0
00004E6C  6616      9273          bne.s     DisassembleInstruction_284
                    9274   ; {
                    9275   ; InstructionSize = 1;
00004E6E  24BC 0000 9276          move.l    #1,(A2)
00004E72  0001      
                    9277   ; sprintf(Instruction, "RTE");
00004E74  4879 0000 9278          pea       @m68kde~2_278.L
00004E78  7302      
00004E7A  4879 0B00 9279          pea       _Instruction.L
00004E7E  04E2      
00004E80  4E95      9280          jsr       (A5)
00004E82  504F      9281          addq.w    #8,A7
                    9282   DisassembleInstruction_284:
                    9283   ; }
                    9284   ; /////////////////////////////////////////////////////////////////////////////////
                    9285   ; // if instruction is RTR
                    9286   ; /////////////////////////////////////////////////////////////////////////////////
                    9287   ; if(*OpCode == (unsigned short int)(0x4E77))
00004E84  2042      9288          move.l    D2,A0
00004E86  3010      9289          move.w    (A0),D0
00004E88  0C40 4E77 9290          cmp.w     #20087,D0
00004E8C  6610      9291          bne.s     DisassembleInstruction_286
                    9292   ; {
                    9293   ; InstructionSize = 1;
00004E8E  24BC 0000 9294          move.l    #1,(A2)
00004E92  0001      
                    9295   ; strcpyInstruction("RTR");
00004E94  4879 0000 9296          pea       @m68kde~2_279.L
00004E98  7306      
00004E9A  4E93      9297          jsr       (A3)
00004E9C  584F      9298          addq.w    #4,A7
                    9299   DisassembleInstruction_286:
                    9300   ; }
                    9301   ; /////////////////////////////////////////////////////////////////////////////////
                    9302   ; // if instruction is RTS
                    9303   ; /////////////////////////////////////////////////////////////////////////////////
                    9304   ; if(*OpCode == (unsigned short int)(0x4E75))
00004E9E  2042      9305          move.l    D2,A0
00004EA0  3010      9306          move.w    (A0),D0
00004EA2  0C40 4E75 9307          cmp.w     #20085,D0
00004EA6  6610      9308          bne.s     DisassembleInstruction_288
                    9309   ; {
                    9310   ; InstructionSize = 1;
00004EA8  24BC 0000 9311          move.l    #1,(A2)
00004EAC  0001      
                    9312   ; strcpyInstruction("RTS");
00004EAE  4879 0000 9313          pea       @m68kde~2_280.L
00004EB2  730A      
00004EB4  4E93      9314          jsr       (A3)
00004EB6  584F      9315          addq.w    #4,A7
                    9316   DisassembleInstruction_288:
                    9317   ; }
                    9318   ; /////////////////////////////////////////////////////////////////////////////////
                    9319   ; // if instruction is STOP
                    9320   ; /////////////////////////////////////////////////////////////////////////////////
                    9321   ; if(*OpCode  == (unsigned short int)(0x4E72))
00004EB8  2042      9322          move.l    D2,A0
00004EBA  3010      9323          move.w    (A0),D0
00004EBC  0C40 4E72 9324          cmp.w     #20082,D0
00004EC0  6622      9325          bne.s     DisassembleInstruction_290
                    9326   ; {
                    9327   ; InstructionSize = 2;
00004EC2  24BC 0000 9328          move.l    #2,(A2)
00004EC6  0002      
                    9329   ; sprintf(Instruction, "STOP #$%X", OpCode[1]);
00004EC8  2042      9330          move.l    D2,A0
00004ECA  3228 0002 9331          move.w    2(A0),D1
00004ECE  48C1      9332          ext.l     D1
00004ED0  2F01      9333          move.l    D1,-(A7)
00004ED2  4879 0000 9334          pea       @m68kde~2_281.L
00004ED6  730E      
00004ED8  4879 0B00 9335          pea       _Instruction.L
00004EDC  04E2      
00004EDE  4E95      9336          jsr       (A5)
00004EE0  DEFC 000C 9337          add.w     #12,A7
                    9338   DisassembleInstruction_290:
                    9339   ; }
                    9340   ; /////////////////////////////////////////////////////////////////////////////////
                    9341   ; // if instruction is SBCD
                    9342   ; /////////////////////////////////////////////////////////////////////////////////
                    9343   ; if((*OpCode & (unsigned short int)(0xF1F0 )) == (unsigned short int)(0x8100))
00004EE4  2042      9344          move.l    D2,A0
00004EE6  3010      9345          move.w    (A0),D0
00004EE8  C07C F1F0 9346          and.w     #61936,D0
00004EEC  0C40 8100 9347          cmp.w     #33024,D0
00004EF0  6600 0092 9348          bne       DisassembleInstruction_295
                    9349   ; {
                    9350   ; InstructionSize = 1;
00004EF4  24BC 0000 9351          move.l    #1,(A2)
00004EF8  0001      
                    9352   ; DestBits = (*OpCode >> 9) & (unsigned short int )(0x0007) ;
00004EFA  2042      9353          move.l    D2,A0
00004EFC  3010      9354          move.w    (A0),D0
00004EFE  E040      9355          asr.w     #8,D0
00004F00  E240      9356          asr.w     #1,D0
00004F02  C07C 0007 9357          and.w     #7,D0
00004F06  3D40 FFE0 9358          move.w    D0,-32(A6)
                    9359   ; SourceBits = (*OpCode & (unsigned short int )(0x0007));
00004F0A  2042      9360          move.l    D2,A0
00004F0C  3010      9361          move.w    (A0),D0
00004F0E  C07C 0007 9362          and.w     #7,D0
00004F12  3D40 FFDE 9363          move.w    D0,-34(A6)
                    9364   ; Mode = (*OpCode >> 3) & (unsigned short int )(0x0001) ;
00004F16  2042      9365          move.l    D2,A0
00004F18  3010      9366          move.w    (A0),D0
00004F1A  E640      9367          asr.w     #3,D0
00004F1C  48C0      9368          ext.l     D0
00004F1E  C0BC 0000 9369          and.l     #1,D0
00004F22  0001      
00004F24  2D40 FFE4 9370          move.l    D0,-28(A6)
                    9371   ; if(Mode == 0)
00004F28  202E FFE4 9372          move.l    -28(A6),D0
00004F2C  662C      9373          bne.s     DisassembleInstruction_294
                    9374   ; sprintf(Instruction, "SBCD D%d,D%d", SourceBits, DestBits) ;
00004F2E  322E FFE0 9375          move.w    -32(A6),D1
00004F32  C2BC 0000 9376          and.l     #65535,D1
00004F36  FFFF      
00004F38  2F01      9377          move.l    D1,-(A7)
00004F3A  322E FFDE 9378          move.w    -34(A6),D1
00004F3E  C2BC 0000 9379          and.l     #65535,D1
00004F42  FFFF      
00004F44  2F01      9380          move.l    D1,-(A7)
00004F46  4879 0000 9381          pea       @m68kde~2_282.L
00004F4A  7318      
00004F4C  4879 0B00 9382          pea       _Instruction.L
00004F50  04E2      
00004F52  4E95      9383          jsr       (A5)
00004F54  DEFC 0010 9384          add.w     #16,A7
00004F58  602A      9385          bra.s     DisassembleInstruction_295
                    9386   DisassembleInstruction_294:
                    9387   ; else
                    9388   ; sprintf(Instruction, "SBCD -(A%d),-(A%d)", SourceBits, DestBits) ;
00004F5A  322E FFE0 9389          move.w    -32(A6),D1
00004F5E  C2BC 0000 9390          and.l     #65535,D1
00004F62  FFFF      
00004F64  2F01      9391          move.l    D1,-(A7)
00004F66  322E FFDE 9392          move.w    -34(A6),D1
00004F6A  C2BC 0000 9393          and.l     #65535,D1
00004F6E  FFFF      
00004F70  2F01      9394          move.l    D1,-(A7)
00004F72  4879 0000 9395          pea       @m68kde~2_283.L
00004F76  7326      
00004F78  4879 0B00 9396          pea       _Instruction.L
00004F7C  04E2      
00004F7E  4E95      9397          jsr       (A5)
00004F80  DEFC 0010 9398          add.w     #16,A7
                    9399   DisassembleInstruction_295:
                    9400   ; }
                    9401   ; /////////////////////////////////////////////////////////////////////////////////
                    9402   ; // if instruction is Scc
                    9403   ; /////////////////////////////////////////////////////////////////////////////////
                    9404   ; if((*OpCode & (unsigned short int)(0xF0C0 )) == (unsigned short int)(0x50C0))
00004F84  2042      9405          move.l    D2,A0
00004F86  3010      9406          move.w    (A0),D0
00004F88  C07C F0C0 9407          and.w     #61632,D0
00004F8C  0C40 50C0 9408          cmp.w     #20672,D0
00004F90  6600 0060 9409          bne       DisassembleInstruction_298
                    9410   ; {
                    9411   ; EAMode = (*OpCode >> 3) & (unsigned short int)(0x0007) ;    // mode cannot be 1 for Scc as it it used by DBcc instruction as a differentiator
00004F94  2042      9412          move.l    D2,A0
00004F96  3010      9413          move.w    (A0),D0
00004F98  E640      9414          asr.w     #3,D0
00004F9A  C07C 0007 9415          and.w     #7,D0
00004F9E  3D40 FFEC 9416          move.w    D0,-20(A6)
                    9417   ; if(EAMode != (unsigned short int)(0x0001))
00004FA2  302E FFEC 9418          move.w    -20(A6),D0
00004FA6  0C40 0001 9419          cmp.w     #1,D0
00004FAA  6700 0046 9420          beq       DisassembleInstruction_298
                    9421   ; {
                    9422   ; InstructionSize = 1;
00004FAE  24BC 0000 9423          move.l    #1,(A2)
00004FB2  0001      
                    9424   ; Condition = ((*OpCode >> 8) & (unsigned short int)(0xF)) ;
00004FB4  2042      9425          move.l    D2,A0
00004FB6  3010      9426          move.w    (A0),D0
00004FB8  E040      9427          asr.w     #8,D0
00004FBA  C07C 000F 9428          and.w     #15,D0
00004FBE  1D40 FFE9 9429          move.b    D0,-23(A6)
                    9430   ; strcpyInstruction("S") ;
00004FC2  4879 0000 9431          pea       @m68kde~2_284.L
00004FC6  733A      
00004FC8  4E93      9432          jsr       (A3)
00004FCA  584F      9433          addq.w    #4,A7
                    9434   ; DecodeBranchCondition(Condition) ;
00004FCC  122E FFE9 9435          move.b    -23(A6),D1
00004FD0  C27C 00FF 9436          and.w     #255,D1
00004FD4  C2BC 0000 9437          and.l     #65535,D1
00004FD8  FFFF      
00004FDA  2F01      9438          move.l    D1,-(A7)
00004FDC  4EB8 332A 9439          jsr       _DecodeBranchCondition
00004FE0  584F      9440          addq.w    #4,A7
                    9441   ; Decode6BitEA(OpCode,0,0,0);
00004FE2  42A7      9442          clr.l     -(A7)
00004FE4  42A7      9443          clr.l     -(A7)
00004FE6  42A7      9444          clr.l     -(A7)
00004FE8  2F02      9445          move.l    D2,-(A7)
00004FEA  4EB8 2E6C 9446          jsr       _Decode6BitEA
00004FEE  DEFC 0010 9447          add.w     #16,A7
                    9448   DisassembleInstruction_298:
                    9449   ; }
                    9450   ; }
                    9451   ; /////////////////////////////////////////////////////////////////////////////////
                    9452   ; // if instruction is SUB or SUBA
                    9453   ; /////////////////////////////////////////////////////////////////////////////////
                    9454   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0x9000))   {
00004FF2  2042      9455          move.l    D2,A0
00004FF4  3010      9456          move.w    (A0),D0
00004FF6  C07C F000 9457          and.w     #61440,D0
00004FFA  0C40 9000 9458          cmp.w     #36864,D0
00004FFE  6600 008C 9459          bne       DisassembleInstruction_303
                    9460   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0007)) ;
00005002  2042      9461          move.l    D2,A0
00005004  3010      9462          move.w    (A0),D0
00005006  EC40      9463          asr.w     #6,D0
00005008  C07C 0007 9464          and.w     #7,D0
0000500C  3600      9465          move.w    D0,D3
                    9466   ; InstructionSize = 1;
0000500E  24BC 0000 9467          move.l    #1,(A2)
00005012  0001      
                    9468   ; if((OpMode == (unsigned short int)(0x0003)) || (OpMode == (unsigned short int)(0x0007)))      // if destination is an address register then use ADDA otherwise use ADD
00005014  0C43 0003 9469          cmp.w     #3,D3
00005018  6708      9470          beq.s     DisassembleInstruction_304
0000501A  0C43 0007 9471          cmp.w     #7,D3
0000501E  6600 005A 9472          bne       DisassembleInstruction_302
                    9473   DisassembleInstruction_304:
                    9474   ; {
                    9475   ; if(OpMode == (unsigned short int)(0x0003))
00005022  0C43 0003 9476          cmp.w     #3,D3
00005026  660C      9477          bne.s     DisassembleInstruction_305
                    9478   ; strcpyInstruction("SUBA.W ") ;
00005028  4879 0000 9479          pea       @m68kde~2_285.L
0000502C  733C      
0000502E  4E93      9480          jsr       (A3)
00005030  584F      9481          addq.w    #4,A7
00005032  600A      9482          bra.s     DisassembleInstruction_306
                    9483   DisassembleInstruction_305:
                    9484   ; else
                    9485   ; strcpyInstruction("SUBA.L ") ;
00005034  4879 0000 9486          pea       @m68kde~2_286.L
00005038  7344      
0000503A  4E93      9487          jsr       (A3)
0000503C  584F      9488          addq.w    #4,A7
                    9489   DisassembleInstruction_306:
                    9490   ; Decode6BitEA(OpCode,0,0,0)  ;
0000503E  42A7      9491          clr.l     -(A7)
00005040  42A7      9492          clr.l     -(A7)
00005042  42A7      9493          clr.l     -(A7)
00005044  2F02      9494          move.l    D2,-(A7)
00005046  4EB8 2E6C 9495          jsr       _Decode6BitEA
0000504A  DEFC 0010 9496          add.w     #16,A7
                    9497   ; sprintf(TempString, ",A%X", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
0000504E  2042      9498          move.l    D2,A0
00005050  3210      9499          move.w    (A0),D1
00005052  E041      9500          asr.w     #8,D1
00005054  E241      9501          asr.w     #1,D1
00005056  C27C 0007 9502          and.w     #7,D1
0000505A  C2BC 0000 9503          and.l     #65535,D1
0000505E  FFFF      
00005060  2F01      9504          move.l    D1,-(A7)
00005062  4879 0000 9505          pea       @m68kde~2_189.L
00005066  7038      
00005068  2F0C      9506          move.l    A4,-(A7)
0000506A  4E95      9507          jsr       (A5)
0000506C  DEFC 000C 9508          add.w     #12,A7
                    9509   ; strcatInstruction(TempString) ;
00005070  2F0C      9510          move.l    A4,-(A7)
00005072  4EB8 0CCC 9511          jsr       _strcatInstruction
00005076  584F      9512          addq.w    #4,A7
00005078  6012      9513          bra.s     DisassembleInstruction_303
                    9514   DisassembleInstruction_302:
                    9515   ; }
                    9516   ; else {
                    9517   ; strcpyInstruction("SUB") ;
0000507A  4879 0000 9518          pea       @m68kde~2_287.L
0000507E  734C      
00005080  4E93      9519          jsr       (A3)
00005082  584F      9520          addq.w    #4,A7
                    9521   ; Decode3BitOperandMode(OpCode) ;
00005084  2F02      9522          move.l    D2,-(A7)
00005086  4EB8 3294 9523          jsr       _Decode3BitOperandMode
0000508A  584F      9524          addq.w    #4,A7
                    9525   DisassembleInstruction_303:
                    9526   ; }
                    9527   ; }
                    9528   ; /////////////////////////////////////////////////////////////////////////////////
                    9529   ; // if instruction is SUBQ
                    9530   ; /////////////////////////////////////////////////////////////////////////////////
                    9531   ; if((*OpCode & (unsigned short int)(0xF100 )) == (unsigned short int)(0x5100))
0000508C  2042      9532          move.l    D2,A0
0000508E  3010      9533          move.w    (A0),D0
00005090  C07C F100 9534          and.w     #61696,D0
00005094  0C40 5100 9535          cmp.w     #20736,D0
00005098  6600 0072 9536          bne       DisassembleInstruction_309
                    9537   ; {
                    9538   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0003) ;
0000509C  2042      9539          move.l    D2,A0
0000509E  3010      9540          move.w    (A0),D0
000050A0  EC40      9541          asr.w     #6,D0
000050A2  C07C 0003 9542          and.w     #3,D0
000050A6  3600      9543          move.w    D0,D3
                    9544   ; if(OpMode <= (unsigned short int)(0x0002))
000050A8  0C43 0002 9545          cmp.w     #2,D3
000050AC  6200 005E 9546          bhi       DisassembleInstruction_309
                    9547   ; {
                    9548   ; InstructionSize = 1;
000050B0  24BC 0000 9549          move.l    #1,(A2)
000050B4  0001      
                    9550   ; strcpyInstruction("SUBQ") ;
000050B6  4879 0000 9551          pea       @m68kde~2_288.L
000050BA  7350      
000050BC  4E93      9552          jsr       (A3)
000050BE  584F      9553          addq.w    #4,A7
                    9554   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
000050C0  2042      9555          move.l    D2,A0
000050C2  3210      9556          move.w    (A0),D1
000050C4  C2BC 0000 9557          and.l     #65535,D1
000050C8  FFFF      
000050CA  2F01      9558          move.l    D1,-(A7)
000050CC  4EB8 2BD8 9559          jsr       _Decode2BitOperandSize
000050D0  584F      9560          addq.w    #4,A7
                    9561   ; sprintf(TempString, "#%1X,", ((*OpCode >> 9) & (unsigned short int)(0x0007)));    // print 3 bit #data in positions 11,10,9 in opcode
000050D2  2042      9562          move.l    D2,A0
000050D4  3210      9563          move.w    (A0),D1
000050D6  E041      9564          asr.w     #8,D1
000050D8  E241      9565          asr.w     #1,D1
000050DA  C27C 0007 9566          and.w     #7,D1
000050DE  C2BC 0000 9567          and.l     #65535,D1
000050E2  FFFF      
000050E4  2F01      9568          move.l    D1,-(A7)
000050E6  4879 0000 9569          pea       @m68kde~2_199.L
000050EA  7078      
000050EC  2F0C      9570          move.l    A4,-(A7)
000050EE  4E95      9571          jsr       (A5)
000050F0  DEFC 000C 9572          add.w     #12,A7
                    9573   ; strcatInstruction(TempString) ;
000050F4  2F0C      9574          move.l    A4,-(A7)
000050F6  4EB8 0CCC 9575          jsr       _strcatInstruction
000050FA  584F      9576          addq.w    #4,A7
                    9577   ; Decode6BitEA(OpCode,0,0,0) ;                                           // decode EA
000050FC  42A7      9578          clr.l     -(A7)
000050FE  42A7      9579          clr.l     -(A7)
00005100  42A7      9580          clr.l     -(A7)
00005102  2F02      9581          move.l    D2,-(A7)
00005104  4EB8 2E6C 9582          jsr       _Decode6BitEA
00005108  DEFC 0010 9583          add.w     #16,A7
                    9584   DisassembleInstruction_309:
                    9585   ; }
                    9586   ; }
                    9587   ; /////////////////////////////////////////////////////////////////////////////////
                    9588   ; // if instruction is SUBX
                    9589   ; /////////////////////////////////////////////////////////////////////////////////
                    9590   ; if((*OpCode & (unsigned short int)(0xF130 )) == (unsigned short int)(0x9100))
0000510C  2042      9591          move.l    D2,A0
0000510E  3010      9592          move.w    (A0),D0
00005110  C07C F130 9593          and.w     #61744,D0
00005114  0C40 9100 9594          cmp.w     #37120,D0
00005118  6600 00A4 9595          bne       DisassembleInstruction_313
                    9596   ; {
                    9597   ; InstructionSize = 1;
0000511C  24BC 0000 9598          move.l    #1,(A2)
00005120  0001      
                    9599   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0003)) ;
00005122  2042      9600          move.l    D2,A0
00005124  3010      9601          move.w    (A0),D0
00005126  EC40      9602          asr.w     #6,D0
00005128  C07C 0003 9603          and.w     #3,D0
0000512C  3600      9604          move.w    D0,D3
                    9605   ; if(OpMode != (unsigned short int)(0x0003)) // if size = 11 then it's SUBA not SUBX
0000512E  0C43 0003 9606          cmp.w     #3,D3
00005132  6700 008A 9607          beq       DisassembleInstruction_313
                    9608   ; {
                    9609   ; strcpyInstruction("SUBX") ;
00005136  4879 0000 9610          pea       @m68kde~2_289.L
0000513A  7356      
0000513C  4E93      9611          jsr       (A3)
0000513E  584F      9612          addq.w    #4,A7
                    9613   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
00005140  2042      9614          move.l    D2,A0
00005142  3210      9615          move.w    (A0),D1
00005144  C2BC 0000 9616          and.l     #65535,D1
00005148  FFFF      
0000514A  2F01      9617          move.l    D1,-(A7)
0000514C  4EB8 2BD8 9618          jsr       _Decode2BitOperandSize
00005150  584F      9619          addq.w    #4,A7
                    9620   ; if((*OpCode & (unsigned short int)(0x0008)) == (unsigned short int)(0))    // if bit 3 of opcode is 0 indicates data registers are used as source and destination
00005152  2042      9621          move.l    D2,A0
00005154  3010      9622          move.w    (A0),D0
00005156  C07C 0008 9623          and.w     #8,D0
0000515A  6600 0030 9624          bne       DisassembleInstruction_315
                    9625   ; sprintf(TempString, "D%1X,D%1X", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
0000515E  2042      9626          move.l    D2,A0
00005160  3210      9627          move.w    (A0),D1
00005162  E041      9628          asr.w     #8,D1
00005164  E241      9629          asr.w     #1,D1
00005166  C27C 0007 9630          and.w     #7,D1
0000516A  48C1      9631          ext.l     D1
0000516C  2F01      9632          move.l    D1,-(A7)
0000516E  2042      9633          move.l    D2,A0
00005170  3210      9634          move.w    (A0),D1
00005172  C27C 0007 9635          and.w     #7,D1
00005176  48C1      9636          ext.l     D1
00005178  2F01      9637          move.l    D1,-(A7)
0000517A  4879 0000 9638          pea       @m68kde~2_290.L
0000517E  735C      
00005180  2F0C      9639          move.l    A4,-(A7)
00005182  4E95      9640          jsr       (A5)
00005184  DEFC 0010 9641          add.w     #16,A7
00005188  6000 002C 9642          bra       DisassembleInstruction_316
                    9643   DisassembleInstruction_315:
                    9644   ; else        // -(ax),-(ay) mode used
                    9645   ; sprintf(TempString, "-(A%1X),-(A%1X)", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
0000518C  2042      9646          move.l    D2,A0
0000518E  3210      9647          move.w    (A0),D1
00005190  E041      9648          asr.w     #8,D1
00005192  E241      9649          asr.w     #1,D1
00005194  C27C 0007 9650          and.w     #7,D1
00005198  48C1      9651          ext.l     D1
0000519A  2F01      9652          move.l    D1,-(A7)
0000519C  2042      9653          move.l    D2,A0
0000519E  3210      9654          move.w    (A0),D1
000051A0  C27C 0007 9655          and.w     #7,D1
000051A4  48C1      9656          ext.l     D1
000051A6  2F01      9657          move.l    D1,-(A7)
000051A8  4879 0000 9658          pea       @m68kde~2_291.L
000051AC  7366      
000051AE  2F0C      9659          move.l    A4,-(A7)
000051B0  4E95      9660          jsr       (A5)
000051B2  DEFC 0010 9661          add.w     #16,A7
                    9662   DisassembleInstruction_316:
                    9663   ; strcatInstruction(TempString) ;
000051B6  2F0C      9664          move.l    A4,-(A7)
000051B8  4EB8 0CCC 9665          jsr       _strcatInstruction
000051BC  584F      9666          addq.w    #4,A7
                    9667   DisassembleInstruction_313:
                    9668   ; }
                    9669   ; }
                    9670   ; /////////////////////////////////////////////////////////////////////////////////
                    9671   ; // if instruction is SWAP
                    9672   ; /////////////////////////////////////////////////////////////////////////////////
                    9673   ; if((*OpCode & (unsigned short int)(0xFFF8 )) == (unsigned short int)(0x4840))
000051BE  2042      9674          move.l    D2,A0
000051C0  3010      9675          move.w    (A0),D0
000051C2  C07C FFF8 9676          and.w     #65528,D0
000051C6  0C40 4840 9677          cmp.w     #18496,D0
000051CA  662A      9678          bne.s     DisassembleInstruction_317
                    9679   ; {
                    9680   ; InstructionSize = 1;
000051CC  24BC 0000 9681          move.l    #1,(A2)
000051D0  0001      
                    9682   ; DataRegister = *OpCode & (unsigned short int)(0x0007) ;
000051D2  2042      9683          move.l    D2,A0
000051D4  3010      9684          move.w    (A0),D0
000051D6  C07C 0007 9685          and.w     #7,D0
000051DA  3A00      9686          move.w    D0,D5
                    9687   ; sprintf(Instruction, "SWAP D%d", DataRegister) ;
000051DC  CABC 0000 9688          and.l     #65535,D5
000051E0  FFFF      
000051E2  2F05      9689          move.l    D5,-(A7)
000051E4  4879 0000 9690          pea       @m68kde~2_292.L
000051E8  7376      
000051EA  4879 0B00 9691          pea       _Instruction.L
000051EE  04E2      
000051F0  4E95      9692          jsr       (A5)
000051F2  DEFC 000C 9693          add.w     #12,A7
                    9694   DisassembleInstruction_317:
                    9695   ; }
                    9696   ; /////////////////////////////////////////////////////////////////////////////////
                    9697   ; // if instruction is TAS
                    9698   ; /////////////////////////////////////////////////////////////////////////////////
                    9699   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x4AC0))
000051F6  2042      9700          move.l    D2,A0
000051F8  3010      9701          move.w    (A0),D0
000051FA  C07C FFC0 9702          and.w     #65472,D0
000051FE  0C40 4AC0 9703          cmp.w     #19136,D0
00005202  662A      9704          bne.s     DisassembleInstruction_321
                    9705   ; {
                    9706   ; if(*OpCode != (unsigned short int)(0x4AFC))
00005204  2042      9707          move.l    D2,A0
00005206  3010      9708          move.w    (A0),D0
00005208  0C40 4AFC 9709          cmp.w     #19196,D0
0000520C  6720      9710          beq.s     DisassembleInstruction_321
                    9711   ; {
                    9712   ; InstructionSize = 1;
0000520E  24BC 0000 9713          move.l    #1,(A2)
00005212  0001      
                    9714   ; strcpyInstruction("TAS ") ;
00005214  4879 0000 9715          pea       @m68kde~2_293.L
00005218  7380      
0000521A  4E93      9716          jsr       (A3)
0000521C  584F      9717          addq.w    #4,A7
                    9718   ; Decode6BitEA(OpCode,0,0,0) ;
0000521E  42A7      9719          clr.l     -(A7)
00005220  42A7      9720          clr.l     -(A7)
00005222  42A7      9721          clr.l     -(A7)
00005224  2F02      9722          move.l    D2,-(A7)
00005226  4EB8 2E6C 9723          jsr       _Decode6BitEA
0000522A  DEFC 0010 9724          add.w     #16,A7
                    9725   DisassembleInstruction_321:
                    9726   ; }
                    9727   ; }
                    9728   ; /////////////////////////////////////////////////////////////////////////////////
                    9729   ; // if instruction is TRAP
                    9730   ; /////////////////////////////////////////////////////////////////////////////////
                    9731   ; if((*OpCode & (unsigned short int)(0xFFF0 )) == (unsigned short int)(0x4E40))   {
0000522E  2042      9732          move.l    D2,A0
00005230  3010      9733          move.w    (A0),D0
00005232  C07C FFF0 9734          and.w     #65520,D0
00005236  0C40 4E40 9735          cmp.w     #20032,D0
0000523A  6622      9736          bne.s     DisassembleInstruction_323
                    9737   ; sprintf(Instruction, "TRAP #%d", *OpCode & (unsigned short int)(0x000F)) ;
0000523C  2042      9738          move.l    D2,A0
0000523E  3210      9739          move.w    (A0),D1
00005240  C27C 000F 9740          and.w     #15,D1
00005244  C2BC 0000 9741          and.l     #65535,D1
00005248  FFFF      
0000524A  2F01      9742          move.l    D1,-(A7)
0000524C  4879 0000 9743          pea       @m68kde~2_294.L
00005250  7386      
00005252  4879 0B00 9744          pea       _Instruction.L
00005256  04E2      
00005258  4E95      9745          jsr       (A5)
0000525A  DEFC 000C 9746          add.w     #12,A7
                    9747   DisassembleInstruction_323:
                    9748   ; }
                    9749   ; /////////////////////////////////////////////////////////////////////////////////
                    9750   ; // if instruction is TRAPV
                    9751   ; /////////////////////////////////////////////////////////////////////////////////
                    9752   ; if(*OpCode == (unsigned short int)(0x4E76))
0000525E  2042      9753          move.l    D2,A0
00005260  3010      9754          move.w    (A0),D0
00005262  0C40 4E76 9755          cmp.w     #20086,D0
00005266  6610      9756          bne.s     DisassembleInstruction_325
                    9757   ; {
                    9758   ; InstructionSize = 1;
00005268  24BC 0000 9759          move.l    #1,(A2)
0000526C  0001      
                    9760   ; strcpyInstruction("TRAPV") ;
0000526E  4879 0000 9761          pea       @m68kde~2_295.L
00005272  7390      
00005274  4E93      9762          jsr       (A3)
00005276  584F      9763          addq.w    #4,A7
                    9764   DisassembleInstruction_325:
                    9765   ; }
                    9766   ; /////////////////////////////////////////////////////////////////////////////////
                    9767   ; // if instruction is TST
                    9768   ; /////////////////////////////////////////////////////////////////////////////////
                    9769   ; if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x4A00))
00005278  2042      9770          move.l    D2,A0
0000527A  3010      9771          move.w    (A0),D0
0000527C  C07C FF00 9772          and.w     #65280,D0
00005280  0C40 4A00 9773          cmp.w     #18944,D0
00005284  6600 005A 9774          bne       DisassembleInstruction_329
                    9775   ; {
                    9776   ; Size = (*OpCode >> 6) & (unsigned short int)(0x0003) ;
00005288  2042      9777          move.l    D2,A0
0000528A  3010      9778          move.w    (A0),D0
0000528C  EC40      9779          asr.w     #6,D0
0000528E  C07C 0003 9780          and.w     #3,D0
00005292  3D40 FFE2 9781          move.w    D0,-30(A6)
                    9782   ; if((*OpCode != (unsigned short int)(0x4AFC)) && (Size != (unsigned short int)(0x0003)))       { // test for size to eliminate TAS instruction which shares similar opcode
00005296  2042      9783          move.l    D2,A0
00005298  3010      9784          move.w    (A0),D0
0000529A  0C40 4AFC 9785          cmp.w     #19196,D0
0000529E  6700 0040 9786          beq       DisassembleInstruction_329
000052A2  302E FFE2 9787          move.w    -30(A6),D0
000052A6  0C40 0003 9788          cmp.w     #3,D0
000052AA  6700 0034 9789          beq       DisassembleInstruction_329
                    9790   ; InstructionSize = 1;
000052AE  24BC 0000 9791          move.l    #1,(A2)
000052B2  0001      
                    9792   ; strcpyInstruction("TST") ;
000052B4  4879 0000 9793          pea       @m68kde~2_296.L
000052B8  7396      
000052BA  4E93      9794          jsr       (A3)
000052BC  584F      9795          addq.w    #4,A7
                    9796   ; Decode2BitOperandSize(*OpCode) ;
000052BE  2042      9797          move.l    D2,A0
000052C0  3210      9798          move.w    (A0),D1
000052C2  C2BC 0000 9799          and.l     #65535,D1
000052C6  FFFF      
000052C8  2F01      9800          move.l    D1,-(A7)
000052CA  4EB8 2BD8 9801          jsr       _Decode2BitOperandSize
000052CE  584F      9802          addq.w    #4,A7
                    9803   ; Decode6BitEA(OpCode,0,0,0) ;
000052D0  42A7      9804          clr.l     -(A7)
000052D2  42A7      9805          clr.l     -(A7)
000052D4  42A7      9806          clr.l     -(A7)
000052D6  2F02      9807          move.l    D2,-(A7)
000052D8  4EB8 2E6C 9808          jsr       _Decode6BitEA
000052DC  DEFC 0010 9809          add.w     #16,A7
                    9810   DisassembleInstruction_329:
                    9811   ; }
                    9812   ; }
                    9813   ; /////////////////////////////////////////////////////////////////////////////////
                    9814   ; // if instruction is UNLK
                    9815   ; //////////////////////////////////////////////////////////
                    9816   ; if((*OpCode & (unsigned short int)(0xFFF8 )) == (unsigned short int)(0x4E58))
000052E0  2042      9817          move.l    D2,A0
000052E2  3010      9818          move.w    (A0),D0
000052E4  C07C FFF8 9819          and.w     #65528,D0
000052E8  0C40 4E58 9820          cmp.w     #20056,D0
000052EC  6628      9821          bne.s     DisassembleInstruction_331
                    9822   ; {
                    9823   ; InstructionSize = 1;
000052EE  24BC 0000 9824          move.l    #1,(A2)
000052F2  0001      
                    9825   ; sprintf(Instruction, "UNLK A%d", *OpCode & (unsigned short int)(0x0007)) ;
000052F4  2042      9826          move.l    D2,A0
000052F6  3210      9827          move.w    (A0),D1
000052F8  C27C 0007 9828          and.w     #7,D1
000052FC  C2BC 0000 9829          and.l     #65535,D1
00005300  FFFF      
00005302  2F01      9830          move.l    D1,-(A7)
00005304  4879 0000 9831          pea       @m68kde~2_297.L
00005308  739A      
0000530A  4879 0B00 9832          pea       _Instruction.L
0000530E  04E2      
00005310  4E95      9833          jsr       (A5)
00005312  DEFC 000C 9834          add.w     #12,A7
                    9835   DisassembleInstruction_331:
                    9836   ; }
                    9837   ; FormatInstruction() ;
00005316  4EB8 2B46 9838          jsr       _FormatInstruction
0000531A  4CDF 3CFC 9839          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0000531E  4E5E      9840          unlk      A6
00005320  4E75      9841          rts
                    9842   ; }
                    9843   _strcpy:
00005322  206F 0004 9844          move.l    (4,A7),A0
00005326  226F 0008 9845          move.l    (8,A7),A1
0000532A  2008      9846          move.l    A0,D0
                    9847   strcpy_1:
0000532C  10D9      9848          move.b    (A1)+,(A0)+
0000532E  66FC      9849          bne       strcpy_1
00005330  4E75      9850          rts
                    9851   ULDIV:
00005332  4E56 0000 9852          link    A6,#0
00005336  48E7 C000 9853          movem.l D0/D1,-(A7)
0000533A  222E 0008 9854          move.l  8(A6),D1
0000533E  202E 000C 9855          move.l  12(A6),D0
00005342  6036      9856          bra.s   ldiv_3
                    9857   LDIV:
00005344  4E56 0000 9858          link    A6,#0
00005348  48E7 C000 9859          movem.l D0/D1,-(A7)
0000534C  222E 0008 9860          move.l  8(A6),D1
00005350  202E 000C 9861          move.l  12(A6),D0
00005354  4A80      9862          tst.l   D0
00005356  6A0E      9863          bpl.s   ldiv_1
00005358  4480      9864          neg.l   D0
0000535A  4A81      9865          tst.l   D1
0000535C  6A14      9866          bpl.s   ldiv_2
0000535E  4481      9867          neg.l   D1
00005360  612A      9868          bsr.s   dodiv
00005362  4481      9869          neg.l   D1
00005364  6016      9870          bra.s   ldiv_4
                    9871   ldiv_1:
00005366  4A81      9872          tst.l   D1
00005368  6A10      9873          bpl.s   ldiv_3
0000536A  4481      9874          neg.l   D1
0000536C  611E      9875          bsr.s   dodiv
0000536E  4480      9876          neg.l   D0
00005370  600A      9877          bra.s   ldiv_4
                    9878   ldiv_2:
00005372  6118      9879          bsr.s   dodiv
00005374  4480      9880          neg.l   D0
00005376  4481      9881          neg.l   D1
00005378  6002      9882          bra.s   ldiv_4
                    9883   ldiv_3:
0000537A  6110      9884          bsr.s   dodiv
                    9885   ldiv_4:
0000537C  2D40 0008 9886          move.l  D0,8(A6)
00005380  2D41 000C 9887          move.l  D1,12(A6)
00005384  4CDF 0003 9888          movem.l (A7)+,D0/D1
00005388  4E5E      9889          unlk    A6
0000538A  4E75      9890          rts
                    9891   dodiv:
0000538C  0C81 0000 9892          cmpi.l  #$FFFF,D1
00005390  FFFF      
00005392  6236      9893          bhi.s   dodiv_2
00005394  0C80 0000 9894          cmpi.l  #$FFFF,D0
00005398  FFFF      
0000539A  6210      9895          bhi.s   dodiv_1
0000539C  80C1      9896          divu    D1,D0
0000539E  2200      9897          move.l  D0,D1
000053A0  4241      9898          clr.w   D1
000053A2  4841      9899          swap    D1
000053A4  0280 0000 9900          andi.l  #$FFFF,D0
000053A8  FFFF      
000053AA  4E75      9901          rts
                    9902   dodiv_1:
000053AC  48A7 A000 9903          movem.w D0/D2,-(A7)
000053B0  4240      9904          clr.w   D0
000053B2  4840      9905          swap    D0
000053B4  80C1      9906          divu    D1,D0
000053B6  3400      9907          move.w  D0,D2
000053B8  301F      9908          move.w  (A7)+,D0
000053BA  80C1      9909          divu    D1,D0
000053BC  4840      9910          swap    D0
000053BE  4281      9911          clr.l   D1
000053C0  3200      9912          move.w  D0,D1
000053C2  3002      9913          move.w  D2,D0
000053C4  4840      9914          swap    D0
000053C6  341F      9915          move.w  (A7)+,D2
000053C8  4E75      9916          rts
                    9917   dodiv_2:
000053CA  48E7 3800 9918          movem.l D2/D3/D4,-(A7)
000053CE  2401      9919          move.l  D1,D2
000053D0  4242      9920          clr.w   D2
000053D2  4842      9921          swap    D2
000053D4  5282      9922          addq.l  #1,D2
000053D6  2600      9923          move.l  D0,D3
000053D8  2801      9924          move.l  D1,D4
000053DA  2202      9925          move.l  D2,D1
000053DC  61CE      9926          bsr.s   dodiv_1
000053DE  2204      9927          move.l  D4,D1
000053E0  82C2      9928          divu    D2,D1
000053E2  80C1      9929          divu    D1,D0
000053E4  0280 0000 9930          andi.l  #$FFFF,D0
000053E8  FFFF      
                    9931   dodiv_3:
000053EA  2204      9932          move.l  D4,D1
000053EC  2404      9933          move.l  D4,D2
000053EE  4842      9934          swap    D2
000053F0  C2C0      9935          mulu    D0,D1
000053F2  C4C0      9936          mulu    D0,D2
000053F4  4842      9937          swap    D2
000053F6  D282      9938          add.l   D2,D1
000053F8  9283      9939          sub.l   D3,D1
000053FA  620A      9940          bhi.s   dodiv_4
000053FC  4481      9941          neg.l   D1
000053FE  B881      9942          cmp.l   D1,D4
00005400  6208      9943          bhi.s   dodiv_5
00005402  5280      9944          addq.l  #1,D0
00005404  60E4      9945          bra.s   dodiv_3
                    9946   dodiv_4:
00005406  5380      9947          subq.l  #1,D0
00005408  60E0      9948          bra.s   dodiv_3
                    9949   dodiv_5:
0000540A  4CDF 001C 9950          movem.l (A7)+,D2/D3/D4
0000540E  4E75      9951          rts
                    9952   _putch:
00005410  4E56 0000 9953          link      A6,#0
00005414  48E7 2000 9954          movem.l   D2,-(A7)
00005418  242E 0008 9955          move.l    8(A6),D2
0000541C  0C82 0000 9956          cmp.l     #10,D2
00005420  000A      
00005422  660A      9957          bne.s     putch_1
00005424  4878 000D 9958          pea       13
00005428  6100 B712 9959          bsr       __putch
0000542C  584F      9960          addq.w    #4,A7
                    9961   putch_1:
0000542E  2F02      9962          move.l    D2,-(A7)
00005430  6100 B70A 9963          bsr       __putch
00005434  584F      9964          addq.w    #4,A7
00005436  2002      9965          move.l    D2,D0
00005438  4CDF 0004 9966          movem.l   (A7)+,D2
0000543C  4E5E      9967          unlk      A6
0000543E  4E75      9968          rts
                    9969   _getch:
00005440  48E7 2000 9970          movem.l   D2,-(A7)
00005444  2439 0B00 9971          move.l    __ungetbuf,D2
00005448  00C0      
0000544A  2039 0B00 9972          move.l    __ungetbuf,D0
0000544E  00C0      
00005450  0C80 FFFF 9973          cmp.l     #-1,D0
00005454  FFFF      
00005456  670C      9974          beq.s     getch_1
00005458  23FC FFFF 9975          move.l    #-1,__ungetbuf
0000545C  FFFF 0B00 
00005460  00C0      
00005462  6010      9976          bra.s     getch_3
                    9977   getch_1:
00005464  6100 B702 9978          bsr       __getch
00005468  2400      9979          move.l    D0,D2
0000546A  0C80 0000 9980          cmp.l     #13,D0
0000546E  000D      
00005470  6602      9981          bne.s     getch_3
00005472  740A      9982          moveq     #10,D2
                    9983   getch_3:
00005474  2002      9984          move.l    D2,D0
00005476  4CDF 0004 9985          movem.l   (A7)+,D2
0000547A  4E75      9986          rts
                    9987   _tolower:
0000547C  4E56 0000 9988          link      A6,#0
00005480  48E7 2000 9989          movem.l   D2,-(A7)
00005484  242E 0008 9990          move.l    8(A6),D2
00005488  0C82 0000 9991          cmp.l     #65,D2
0000548C  0041      
0000548E  6D0E      9992          blt.s     tolower_1
00005490  0C82 0000 9993          cmp.l     #90,D2
00005494  005A      
00005496  6E06      9994          bgt.s     tolower_1
00005498  84BC 0000 9995          or.l      #32,D2
0000549C  0020      
                    9996   tolower_1:
0000549E  2002      9997          move.l    D2,D0
000054A0  4CDF 0004 9998          movem.l   (A7)+,D2
000054A4  4E5E      9999          unlk      A6
000054A6  4E75      10000          rts
                    10001   _sprintf:
000054A8  4E56 FFFC 10002          link      A6,#-4
000054AC  48E7 2000 10003          movem.l   D2,-(A7)
000054B0  41EE 000C 10004          lea       12(A6),A0
000054B4  5848      10005          addq.w    #4,A0
000054B6  2408      10006          move.l    A0,D2
000054B8  2F02      10007          move.l    D2,-(A7)
000054BA  2F2E 000C 10008          move.l    12(A6),-(A7)
000054BE  2F2E 0008 10009          move.l    8(A6),-(A7)
000054C2  6100 013E 10010          bsr       _vsprintf
000054C6  DEFC 000C 10011          add.w     #12,A7
000054CA  2D40 FFFC 10012          move.l    D0,-4(A6)
000054CE  4282      10013          clr.l     D2
000054D0  202E FFFC 10014          move.l    -4(A6),D0
000054D4  4CDF 0004 10015          movem.l   (A7)+,D2
000054D8  4E5E      10016          unlk      A6
000054DA  4E75      10017          rts
                    10018   _strcat:
000054DC  206F 0004 10019          move.l    (4,A7),A0	
000054E0  226F 0008 10020          move.l    (8,A7),A1	
000054E4  2008      10021          move.l    A0,D0		
                    10022   strcat_0:
000054E6  4A18      10023          tst.b     (A0)+
000054E8  66FC      10024          bne       strcat_0
000054EA  5348      10025          subq      #1,A0
                    10026   strcat_1:
000054EC  10D9      10027          move.b    (A1)+,(A0)+
000054EE  66FC      10028          bne       strcat_1
000054F0  4E75      10029          rts
                    10030   _toupper:
000054F2  4E56 0000 10031          link      A6,#0
000054F6  48E7 2000 10032          movem.l   D2,-(A7)
000054FA  242E 0008 10033          move.l    8(A6),D2
000054FE  0C82 0000 10034          cmp.l     #97,D2
00005502  0061      
00005504  6D0E      10035          blt.s     toupper_1
00005506  0C82 0000 10036          cmp.l     #122,D2
0000550A  007A      
0000550C  6E06      10037          bgt.s     toupper_1
0000550E  C4BC 0000 10038          and.l     #95,D2
00005512  005F      
                    10039   toupper_1:
00005514  2002      10040          move.l    D2,D0
00005516  4CDF 0004 10041          movem.l   (A7)+,D2
0000551A  4E5E      10042          unlk      A6
0000551C  4E75      10043          rts
                    10044   _printf:
0000551E  4E56 FFFC 10045          link      A6,#-4
00005522  48E7 2000 10046          movem.l   D2,-(A7)
00005526  41EE 0008 10047          lea       8(A6),A0
0000552A  5848      10048          addq.w    #4,A0
0000552C  2408      10049          move.l    A0,D2
0000552E  2F02      10050          move.l    D2,-(A7)
00005530  2F2E 0008 10051          move.l    8(A6),-(A7)
00005534  42A7      10052          clr.l     -(A7)
00005536  6100 00CA 10053          bsr       _vsprintf
0000553A  DEFC 000C 10054          add.w     #12,A7
0000553E  2D40 FFFC 10055          move.l    D0,-4(A6)
00005542  4282      10056          clr.l     D2
00005544  202E FFFC 10057          move.l    -4(A6),D0
00005548  4CDF 0004 10058          movem.l   (A7)+,D2
0000554C  4E5E      10059          unlk      A6
0000554E  4E75      10060          rts
                    10061   @vsprintf_copy:
00005550  4E56 0000 10062          link      A6,#0
00005554  206E 0008 10063          move.l    8(A6),A0
00005558  4A90      10064          tst.l     (A0)
0000555A  6710      10065          beq.s     @vsprintf_copy_1
0000555C  202E 000C 10066          move.l    12(A6),D0
00005560  206E 0008 10067          move.l    8(A6),A0
00005564  2250      10068          move.l    (A0),A1
00005566  5290      10069          addq.l    #1,(A0)
00005568  1280      10070          move.b    D0,(A1)
0000556A  600A      10071          bra.s     @vsprintf_copy_2
                    10072   @vsprintf_copy_1:
0000556C  2F2E 000C 10073          move.l    12(A6),-(A7)
00005570  6100 FE9E 10074          bsr       _putch
00005574  584F      10075          addq.w    #4,A7
                    10076   @vsprintf_copy_2:
00005576  4E5E      10077          unlk      A6
00005578  4E75      10078          rts
                    10079   @vsprintf_getval:
0000557A  4E56 0000 10080          link      A6,#0
0000557E  48E7 3000 10081          movem.l   D2/D3,-(A7)
00005582  242E 0008 10082          move.l    8(A6),D2
00005586  4283      10083          clr.l     D3
00005588  2042      10084          move.l    D2,A0
0000558A  2050      10085          move.l    (A0),A0
0000558C  1010      10086          move.b    (A0),D0
0000558E  4880      10087          ext.w     D0
00005590  48C0      10088          ext.l     D0
00005592  0C80 0000 10089          cmp.l     #42,D0
00005596  002A      
00005598  6612      10090          bne.s     @vsprintf_getval_1
0000559A  206E 000C 10091          move.l    12(A6),A0
0000559E  2250      10092          move.l    (A0),A1
000055A0  5890      10093          addq.l    #4,(A0)
000055A2  2611      10094          move.l    (A1),D3
000055A4  2042      10095          move.l    D2,A0
000055A6  5290      10096          addq.l    #1,(A0)
000055A8  6000 004E 10097          bra       @vsprintf_getval_5
                    10098   @vsprintf_getval_1:
000055AC  2042      10099          move.l    D2,A0
000055AE  2050      10100          move.l    (A0),A0
000055B0  1010      10101          move.b    (A0),D0
000055B2  4880      10102          ext.w     D0
000055B4  48C0      10103          ext.l     D0
000055B6  0C80 0000 10104          cmp.l     #48,D0
000055BA  0030      
000055BC  6D00 003A 10105          blt       @vsprintf_getval_5
000055C0  2042      10106          move.l    D2,A0
000055C2  2050      10107          move.l    (A0),A0
000055C4  1010      10108          move.b    (A0),D0
000055C6  4880      10109          ext.w     D0
000055C8  48C0      10110          ext.l     D0
000055CA  0C80 0000 10111          cmp.l     #57,D0
000055CE  0039      
000055D0  6E26      10112          bgt.s     @vsprintf_getval_5
000055D2  2F03      10113          move.l    D3,-(A7)
000055D4  4878 000A 10114          pea       10
000055D8  6100 07F4 10115          bsr       LMUL
000055DC  2017      10116          move.l    (A7),D0
000055DE  504F      10117          addq.w    #8,A7
000055E0  2042      10118          move.l    D2,A0
000055E2  2250      10119          move.l    (A0),A1
000055E4  5290      10120          addq.l    #1,(A0)
000055E6  1211      10121          move.b    (A1),D1
000055E8  4881      10122          ext.w     D1
000055EA  48C1      10123          ext.l     D1
000055EC  D081      10124          add.l     D1,D0
000055EE  0480 0000 10125          sub.l     #48,D0
000055F2  0030      
000055F4  2600      10126          move.l    D0,D3
000055F6  60B4      10127          bra       @vsprintf_getval_1
                    10128   @vsprintf_getval_5:
000055F8  2003      10129          move.l    D3,D0
000055FA  4CDF 000C 10130          movem.l   (A7)+,D2/D3
000055FE  4E5E      10131          unlk      A6
00005600  4E75      10132          rts
                    10133   _vsprintf:
00005602  4E56 FFCC 10134          link      A6,#-52
00005606  48E7 3F3C 10135          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0000560A  45EE 0008 10136          lea       8(A6),A2
0000560E  47F8 5550 10137          lea       @vsprintf_copy,A3
00005612  49F9 0000 10138          lea       _ultoa,A4
00005616  5D5A      
00005618  4286      10139          clr.l     D6
                    10140   vsprintf_1:
0000561A  206E 000C 10141          move.l    12(A6),A0
0000561E  4A10      10142          tst.b     (A0)
00005620  6700 0624 10143          beq       vsprintf_3
00005624  206E 000C 10144          move.l    12(A6),A0
00005628  1010      10145          move.b    (A0),D0
0000562A  4880      10146          ext.w     D0
0000562C  48C0      10147          ext.l     D0
0000562E  0C80 0000 10148          cmp.l     #37,D0
00005632  0025      
00005634  671C      10149          beq.s     vsprintf_4
00005636  206E 000C 10150          move.l    12(A6),A0
0000563A  52AE 000C 10151          addq.l    #1,12(A6)
0000563E  1210      10152          move.b    (A0),D1
00005640  4881      10153          ext.w     D1
00005642  48C1      10154          ext.l     D1
00005644  2F01      10155          move.l    D1,-(A7)
00005646  2F0A      10156          move.l    A2,-(A7)
00005648  4E93      10157          jsr       (A3)
0000564A  504F      10158          addq.w    #8,A7
0000564C  5286      10159          addq.l    #1,D6
0000564E  6000 05F2 10160          bra       vsprintf_2
                    10161   vsprintf_4:
00005652  52AE 000C 10162          addq.l    #1,12(A6)
00005656  422E FFD3 10163          clr.b     -45(A6)
0000565A  422E FFD2 10164          clr.b     -46(A6)
0000565E  422E FFD0 10165          clr.b     -48(A6)
00005662  422E FFCF 10166          clr.b     -49(A6)
00005666  422E FFCE 10167          clr.b     -50(A6)
0000566A  422E FFCD 10168          clr.b     -51(A6)
0000566E  42AE FFFC 10169          clr.l     -4(A6)
00005672  7AFF      10170          moveq     #-1,D5
00005674  41EE FFDC 10171          lea       -36(A6),A0
00005678  2608      10172          move.l    A0,D3
0000567A  2408      10173          move.l    A0,D2
                    10174   vsprintf_6:
0000567C  206E 000C 10175          move.l    12(A6),A0
00005680  1010      10176          move.b    (A0),D0
00005682  4880      10177          ext.w     D0
00005684  48C0      10178          ext.l     D0
00005686  0C80 0000 10179          cmp.l     #43,D0
0000568A  002B      
0000568C  6730      10180          beq.s     vsprintf_12
0000568E  6E18      10181          bgt.s     vsprintf_15
00005690  0C80 0000 10182          cmp.l     #35,D0
00005694  0023      
00005696  6700 003E 10183          beq       vsprintf_14
0000569A  6E00 0046 10184          bgt       vsprintf_9
0000569E  0C80 0000 10185          cmp.l     #32,D0
000056A2  0020      
000056A4  6724      10186          beq.s     vsprintf_13
000056A6  603A      10187          bra.s     vsprintf_9
                    10188   vsprintf_15:
000056A8  0C80 0000 10189          cmp.l     #45,D0
000056AC  002D      
000056AE  6702      10190          beq.s     vsprintf_11
000056B0  6030      10191          bra.s     vsprintf_9
                    10192   vsprintf_11:
000056B2  1D7C 0001 10193          move.b    #1,-51(A6)
000056B6  FFCD      
000056B8  52AE 000C 10194          addq.l    #1,12(A6)
000056BC  6026      10195          bra.s     vsprintf_7
                    10196   vsprintf_12:
000056BE  1D7C 0001 10197          move.b    #1,-50(A6)
000056C2  FFCE      
000056C4  52AE 000C 10198          addq.l    #1,12(A6)
000056C8  601A      10199          bra.s     vsprintf_7
                    10200   vsprintf_13:
000056CA  1D7C 0001 10201          move.b    #1,-49(A6)
000056CE  FFCF      
000056D0  52AE 000C 10202          addq.l    #1,12(A6)
000056D4  600E      10203          bra.s     vsprintf_7
                    10204   vsprintf_14:
000056D6  1D7C 0001 10205          move.b    #1,-48(A6)
000056DA  FFD0      
000056DC  52AE 000C 10206          addq.l    #1,12(A6)
000056E0  6002      10207          bra.s     vsprintf_7
                    10208   vsprintf_9:
000056E2  6002      10209          bra.s     vsprintf_8
                    10210   vsprintf_7:
000056E4  6096      10211          bra       vsprintf_6
                    10212   vsprintf_8:
000056E6  206E 000C 10213          move.l    12(A6),A0
000056EA  1010      10214          move.b    (A0),D0
000056EC  4880      10215          ext.w     D0
000056EE  48C0      10216          ext.l     D0
000056F0  0C80 0000 10217          cmp.l     #48,D0
000056F4  0030      
000056F6  660A      10218          bne.s     vsprintf_16
000056F8  52AE 000C 10219          addq.l    #1,12(A6)
000056FC  1D7C 0001 10220          move.b    #1,-46(A6)
00005700  FFD2      
                    10221   vsprintf_16:
00005702  486E 0010 10222          pea       16(A6)
00005706  486E 000C 10223          pea       12(A6)
0000570A  6100 FE6E 10224          bsr       @vsprintf_getval
0000570E  504F      10225          addq.w    #8,A7
00005710  2A40      10226          move.l    D0,A5
00005712  206E 000C 10227          move.l    12(A6),A0
00005716  1010      10228          move.b    (A0),D0
00005718  4880      10229          ext.w     D0
0000571A  48C0      10230          ext.l     D0
0000571C  0C80 0000 10231          cmp.l     #46,D0
00005720  002E      
00005722  6614      10232          bne.s     vsprintf_18
00005724  52AE 000C 10233          addq.l    #1,12(A6)
00005728  486E 0010 10234          pea       16(A6)
0000572C  486E 000C 10235          pea       12(A6)
00005730  6100 FE48 10236          bsr       @vsprintf_getval
00005734  504F      10237          addq.w    #8,A7
00005736  2A00      10238          move.l    D0,D5
                    10239   vsprintf_18:
00005738  206E 000C 10240          move.l    12(A6),A0
0000573C  1010      10241          move.b    (A0),D0
0000573E  4880      10242          ext.w     D0
00005740  48C0      10243          ext.l     D0
00005742  0C80 0000 10244          cmp.l     #108,D0
00005746  006C      
00005748  660A      10245          bne.s     vsprintf_20
0000574A  52AE 000C 10246          addq.l    #1,12(A6)
0000574E  1D7C 0001 10247          move.b    #1,-45(A6)
00005752  FFD3      
                    10248   vsprintf_20:
00005754  206E 000C 10249          move.l    12(A6),A0
00005758  1010      10250          move.b    (A0),D0
0000575A  4880      10251          ext.w     D0
0000575C  48C0      10252          ext.l     D0
0000575E  0C80 0000 10253          cmp.l     #111,D0
00005762  006F      
00005764  6700 00D4 10254          beq       vsprintf_27
00005768  6E34      10255          bgt.s     vsprintf_33
0000576A  0C80 0000 10256          cmp.l     #100,D0
0000576E  0064      
00005770  6700 0054 10257          beq       vsprintf_24
00005774  6E1C      10258          bgt.s     vsprintf_34
00005776  0C80 0000 10259          cmp.l     #99,D0
0000577A  0063      
0000577C  6700 012C 10260          beq       vsprintf_30
00005780  6E00 016A 10261          bgt       vsprintf_22
00005784  0C80 0000 10262          cmp.l     #88,D0
00005788  0058      
0000578A  6700 00E6 10263          beq       vsprintf_28
0000578E  6000 015C 10264          bra       vsprintf_22
                    10265   vsprintf_34:
00005792  0C80 0000 10266          cmp.l     #105,D0
00005796  0069      
00005798  672C      10267          beq.s     vsprintf_24
0000579A  6000 0150 10268          bra       vsprintf_22
                    10269   vsprintf_33:
0000579E  0C80 0000 10270          cmp.l     #117,D0
000057A2  0075      
000057A4  6700 005C 10271          beq       vsprintf_26
000057A8  6E0E      10272          bgt.s     vsprintf_35
000057AA  0C80 0000 10273          cmp.l     #115,D0
000057AE  0073      
000057B0  6700 011C 10274          beq       vsprintf_31
000057B4  6000 0136 10275          bra       vsprintf_22
                    10276   vsprintf_35:
000057B8  0C80 0000 10277          cmp.l     #120,D0
000057BC  0078      
000057BE  6700 00B2 10278          beq       vsprintf_28
000057C2  6000 0128 10279          bra       vsprintf_22
                    10280   vsprintf_24:
000057C6  4A2E FFD3 10281          tst.b     -45(A6)
000057CA  671A      10282          beq.s     vsprintf_36
000057CC  4878 000A 10283          pea       10
000057D0  2F03      10284          move.l    D3,-(A7)
000057D2  206E 0010 10285          move.l    16(A6),A0
000057D6  58AE 0010 10286          addq.l    #4,16(A6)
000057DA  2F10      10287          move.l    (A0),-(A7)
000057DC  6100 04F8 10288          bsr       _ltoa
000057E0  DEFC 000C 10289          add.w     #12,A7
000057E4  6018      10290          bra.s     vsprintf_37
                    10291   vsprintf_36:
000057E6  4878 000A 10292          pea       10
000057EA  2F03      10293          move.l    D3,-(A7)
000057EC  206E 0010 10294          move.l    16(A6),A0
000057F0  58AE 0010 10295          addq.l    #4,16(A6)
000057F4  2F10      10296          move.l    (A0),-(A7)
000057F6  6100 04DE 10297          bsr       _ltoa
000057FA  DEFC 000C 10298          add.w     #12,A7
                    10299   vsprintf_37:
000057FE  6000 00FA 10300          bra       vsprintf_23
                    10301   vsprintf_26:
00005802  4A2E FFD3 10302          tst.b     -45(A6)
00005806  6718      10303          beq.s     vsprintf_38
00005808  4878 000A 10304          pea       10
0000580C  2F03      10305          move.l    D3,-(A7)
0000580E  206E 0010 10306          move.l    16(A6),A0
00005812  58AE 0010 10307          addq.l    #4,16(A6)
00005816  2F10      10308          move.l    (A0),-(A7)
00005818  4E94      10309          jsr       (A4)
0000581A  DEFC 000C 10310          add.w     #12,A7
0000581E  6016      10311          bra.s     vsprintf_39
                    10312   vsprintf_38:
00005820  4878 000A 10313          pea       10
00005824  2F03      10314          move.l    D3,-(A7)
00005826  206E 0010 10315          move.l    16(A6),A0
0000582A  58AE 0010 10316          addq.l    #4,16(A6)
0000582E  2F10      10317          move.l    (A0),-(A7)
00005830  4E94      10318          jsr       (A4)
00005832  DEFC 000C 10319          add.w     #12,A7
                    10320   vsprintf_39:
00005836  6000 00C2 10321          bra       vsprintf_23
                    10322   vsprintf_27:
0000583A  4A2E FFD3 10323          tst.b     -45(A6)
0000583E  6718      10324          beq.s     vsprintf_40
00005840  4878 0008 10325          pea       8
00005844  2F03      10326          move.l    D3,-(A7)
00005846  206E 0010 10327          move.l    16(A6),A0
0000584A  58AE 0010 10328          addq.l    #4,16(A6)
0000584E  2F10      10329          move.l    (A0),-(A7)
00005850  4E94      10330          jsr       (A4)
00005852  DEFC 000C 10331          add.w     #12,A7
00005856  6016      10332          bra.s     vsprintf_41
                    10333   vsprintf_40:
00005858  4878 0008 10334          pea       8
0000585C  2F03      10335          move.l    D3,-(A7)
0000585E  206E 0010 10336          move.l    16(A6),A0
00005862  58AE 0010 10337          addq.l    #4,16(A6)
00005866  2F10      10338          move.l    (A0),-(A7)
00005868  4E94      10339          jsr       (A4)
0000586A  DEFC 000C 10340          add.w     #12,A7
                    10341   vsprintf_41:
0000586E  6000 008A 10342          bra       vsprintf_23
                    10343   vsprintf_28:
00005872  4A2E FFD3 10344          tst.b     -45(A6)
00005876  6718      10345          beq.s     vsprintf_42
00005878  4878 0010 10346          pea       16
0000587C  2F03      10347          move.l    D3,-(A7)
0000587E  206E 0010 10348          move.l    16(A6),A0
00005882  58AE 0010 10349          addq.l    #4,16(A6)
00005886  2F10      10350          move.l    (A0),-(A7)
00005888  4E94      10351          jsr       (A4)
0000588A  DEFC 000C 10352          add.w     #12,A7
0000588E  6016      10353          bra.s     vsprintf_43
                    10354   vsprintf_42:
00005890  4878 0010 10355          pea       16
00005894  2F03      10356          move.l    D3,-(A7)
00005896  206E 0010 10357          move.l    16(A6),A0
0000589A  58AE 0010 10358          addq.l    #4,16(A6)
0000589E  2F10      10359          move.l    (A0),-(A7)
000058A0  4E94      10360          jsr       (A4)
000058A2  DEFC 000C 10361          add.w     #12,A7
                    10362   vsprintf_43:
000058A6  6000 0052 10363          bra       vsprintf_23
                    10364   vsprintf_30:
000058AA  206E 0010 10365          move.l    16(A6),A0
000058AE  58AE 0010 10366          addq.l    #4,16(A6)
000058B2  2010      10367          move.l    (A0),D0
000058B4  2042      10368          move.l    D2,A0
000058B6  5282      10369          addq.l    #1,D2
000058B8  1080      10370          move.b    D0,(A0)
000058BA  2042      10371          move.l    D2,A0
000058BC  4210      10372          clr.b     (A0)
000058BE  200D      10373          move.l    A5,D0
000058C0  6704      10374          beq.s     vsprintf_44
000058C2  200D      10375          move.l    A5,D0
000058C4  6002      10376          bra.s     vsprintf_45
                    10377   vsprintf_44:
000058C6  7001      10378          moveq     #1,D0
                    10379   vsprintf_45:
000058C8  2A00      10380          move.l    D0,D5
000058CA  6000 002E 10381          bra       vsprintf_23
                    10382   vsprintf_31:
000058CE  206E 0010 10383          move.l    16(A6),A0
000058D2  58AE 0010 10384          addq.l    #4,16(A6)
000058D6  2610      10385          move.l    (A0),D3
000058D8  0C85 FFFF 10386          cmp.l     #-1,D5
000058DC  FFFF      
000058DE  660A      10387          bne.s     vsprintf_46
000058E0  2F03      10388          move.l    D3,-(A7)
000058E2  6100 0578 10389          bsr       _strlen
000058E6  584F      10390          addq.w    #4,A7
000058E8  2A00      10391          move.l    D0,D5
                    10392   vsprintf_46:
000058EA  600E      10393          bra.s     vsprintf_23
                    10394   vsprintf_22:
000058EC  206E 000C 10395          move.l    12(A6),A0
000058F0  2242      10396          move.l    D2,A1
000058F2  5282      10397          addq.l    #1,D2
000058F4  1290      10398          move.b    (A0),(A1)
000058F6  2042      10399          move.l    D2,A0
000058F8  4210      10400          clr.b     (A0)
                    10401   vsprintf_23:
000058FA  2F03      10402          move.l    D3,-(A7)
000058FC  6100 055E 10403          bsr       _strlen
00005900  584F      10404          addq.w    #4,A7
00005902  1800      10405          move.b    D0,D4
00005904  206E 000C 10406          move.l    12(A6),A0
00005908  1010      10407          move.b    (A0),D0
0000590A  4880      10408          ext.w     D0
0000590C  48C0      10409          ext.l     D0
0000590E  0C80 0000 10410          cmp.l     #115,D0
00005912  0073      
00005914  6618      10411          bne.s     vsprintf_48
00005916  0C85 0000 10412          cmp.l     #0,D5
0000591A  0000      
0000591C  6D10      10413          blt.s     vsprintf_48
0000591E  4884      10414          ext.w     D4
00005920  48C4      10415          ext.l     D4
00005922  B885      10416          cmp.l     D5,D4
00005924  6F04      10417          ble.s     vsprintf_50
00005926  1005      10418          move.b    D5,D0
00005928  6002      10419          bra.s     vsprintf_51
                    10420   vsprintf_50:
0000592A  1004      10421          move.b    D4,D0
                    10422   vsprintf_51:
0000592C  1800      10423          move.b    D0,D4
                    10424   vsprintf_48:
0000592E  206E 000C 10425          move.l    12(A6),A0
00005932  1010      10426          move.b    (A0),D0
00005934  4880      10427          ext.w     D0
00005936  48C0      10428          ext.l     D0
00005938  0C80 0000 10429          cmp.l     #88,D0
0000593C  0058      
0000593E  6600 0026 10430          bne       vsprintf_56
00005942  41EE FFDC 10431          lea       -36(A6),A0
00005946  2408      10432          move.l    A0,D2
                    10433   vsprintf_54:
00005948  2042      10434          move.l    D2,A0
0000594A  4A10      10435          tst.b     (A0)
0000594C  6718      10436          beq.s     vsprintf_56
0000594E  2042      10437          move.l    D2,A0
00005950  1210      10438          move.b    (A0),D1
00005952  4881      10439          ext.w     D1
00005954  48C1      10440          ext.l     D1
00005956  2F01      10441          move.l    D1,-(A7)
00005958  6100 FB98 10442          bsr       _toupper
0000595C  584F      10443          addq.w    #4,A7
0000595E  2042      10444          move.l    D2,A0
00005960  1080      10445          move.b    D0,(A0)
00005962  5282      10446          addq.l    #1,D2
00005964  60E2      10447          bra       vsprintf_54
                    10448   vsprintf_56:
00005966  7E00      10449          moveq     #0,D7
00005968  41EE FFD4 10450          lea       -44(A6),A0
0000596C  2408      10451          move.l    A0,D2
0000596E  206E 000C 10452          move.l    12(A6),A0
00005972  1010      10453          move.b    (A0),D0
00005974  4880      10454          ext.w     D0
00005976  48C0      10455          ext.l     D0
00005978  0C80 0000 10456          cmp.l     #100,D0
0000597C  0064      
0000597E  6714      10457          beq.s     vsprintf_59
00005980  206E 000C 10458          move.l    12(A6),A0
00005984  1010      10459          move.b    (A0),D0
00005986  4880      10460          ext.w     D0
00005988  48C0      10461          ext.l     D0
0000598A  0C80 0000 10462          cmp.l     #105,D0
0000598E  0069      
00005990  6600 0076 10463          bne       vsprintf_65
                    10464   vsprintf_59:
00005994  4A2E FFCE 10465          tst.b     -50(A6)
00005998  6612      10466          bne.s     vsprintf_62
0000599A  2043      10467          move.l    D3,A0
0000599C  1010      10468          move.b    (A0),D0
0000599E  4880      10469          ext.w     D0
000059A0  48C0      10470          ext.l     D0
000059A2  0C80 0000 10471          cmp.l     #45,D0
000059A6  002D      
000059A8  6600 002E 10472          bne       vsprintf_60
                    10473   vsprintf_62:
000059AC  2043      10474          move.l    D3,A0
000059AE  1010      10475          move.b    (A0),D0
000059B0  4880      10476          ext.w     D0
000059B2  48C0      10477          ext.l     D0
000059B4  0C80 0000 10478          cmp.l     #45,D0
000059B8  002D      
000059BA  660E      10479          bne.s     vsprintf_63
000059BC  2043      10480          move.l    D3,A0
000059BE  5283      10481          addq.l    #1,D3
000059C0  2242      10482          move.l    D2,A1
000059C2  5282      10483          addq.l    #1,D2
000059C4  1290      10484          move.b    (A0),(A1)
000059C6  5304      10485          subq.b    #1,D4
000059C8  6008      10486          bra.s     vsprintf_64
                    10487   vsprintf_63:
000059CA  2042      10488          move.l    D2,A0
000059CC  5282      10489          addq.l    #1,D2
000059CE  10BC 002B 10490          move.b    #43,(A0)
                    10491   vsprintf_64:
000059D2  5287      10492          addq.l    #1,D7
000059D4  6000 0032 10493          bra       vsprintf_65
                    10494   vsprintf_60:
000059D8  4A2E FFCF 10495          tst.b     -49(A6)
000059DC  6700 002A 10496          beq       vsprintf_65
000059E0  2043      10497          move.l    D3,A0
000059E2  1010      10498          move.b    (A0),D0
000059E4  4880      10499          ext.w     D0
000059E6  48C0      10500          ext.l     D0
000059E8  0C80 0000 10501          cmp.l     #45,D0
000059EC  002D      
000059EE  660E      10502          bne.s     vsprintf_67
000059F0  2043      10503          move.l    D3,A0
000059F2  5283      10504          addq.l    #1,D3
000059F4  2242      10505          move.l    D2,A1
000059F6  5282      10506          addq.l    #1,D2
000059F8  1290      10507          move.b    (A0),(A1)
000059FA  5304      10508          subq.b    #1,D4
000059FC  6008      10509          bra.s     vsprintf_68
                    10510   vsprintf_67:
000059FE  2042      10511          move.l    D2,A0
00005A00  5282      10512          addq.l    #1,D2
00005A02  10BC 0020 10513          move.b    #32,(A0)
                    10514   vsprintf_68:
00005A06  5287      10515          addq.l    #1,D7
                    10516   vsprintf_65:
00005A08  4A2E FFD0 10517          tst.b     -48(A6)
00005A0C  6700 0066 10518          beq       vsprintf_77
00005A10  206E 000C 10519          move.l    12(A6),A0
00005A14  1010      10520          move.b    (A0),D0
00005A16  4880      10521          ext.w     D0
00005A18  48C0      10522          ext.l     D0
00005A1A  0C80 0000 10523          cmp.l     #111,D0
00005A1E  006F      
00005A20  671A      10524          beq.s     vsprintf_73
00005A22  6E0C      10525          bgt.s     vsprintf_76
00005A24  0C80 0000 10526          cmp.l     #88,D0
00005A28  0058      
00005A2A  6710      10527          beq.s     vsprintf_73
00005A2C  6000 0046 10528          bra       vsprintf_77
                    10529   vsprintf_76:
00005A30  0C80 0000 10530          cmp.l     #120,D0
00005A34  0078      
00005A36  6704      10531          beq.s     vsprintf_73
00005A38  6000 003A 10532          bra       vsprintf_77
                    10533   vsprintf_73:
00005A3C  2042      10534          move.l    D2,A0
00005A3E  5282      10535          addq.l    #1,D2
00005A40  10BC 0030 10536          move.b    #48,(A0)
00005A44  5287      10537          addq.l    #1,D7
00005A46  206E 000C 10538          move.l    12(A6),A0
00005A4A  1010      10539          move.b    (A0),D0
00005A4C  4880      10540          ext.w     D0
00005A4E  48C0      10541          ext.l     D0
00005A50  0C80 0000 10542          cmp.l     #120,D0
00005A54  0078      
00005A56  6712      10543          beq.s     vsprintf_79
00005A58  206E 000C 10544          move.l    12(A6),A0
00005A5C  1010      10545          move.b    (A0),D0
00005A5E  4880      10546          ext.w     D0
00005A60  48C0      10547          ext.l     D0
00005A62  0C80 0000 10548          cmp.l     #88,D0
00005A66  0058      
00005A68  660A      10549          bne.s     vsprintf_77
                    10550   vsprintf_79:
00005A6A  2042      10551          move.l    D2,A0
00005A6C  5282      10552          addq.l    #1,D2
00005A6E  10BC 0078 10553          move.b    #120,(A0)
00005A72  5287      10554          addq.l    #1,D7
                    10555   vsprintf_77:
00005A74  2042      10556          move.l    D2,A0
00005A76  4210      10557          clr.b     (A0)
00005A78  206E 000C 10558          move.l    12(A6),A0
00005A7C  1010      10559          move.b    (A0),D0
00005A7E  4880      10560          ext.w     D0
00005A80  48C0      10561          ext.l     D0
00005A82  0C80 0000 10562          cmp.l     #105,D0
00005A86  0069      
00005A88  6700 0076 10563          beq       vsprintf_82
00005A8C  6E42      10564          bgt.s     vsprintf_93
00005A8E  0C80 0000 10565          cmp.l     #99,D0
00005A92  0063      
00005A94  6700 0084 10566          beq       vsprintf_96
00005A98  6E1C      10567          bgt.s     vsprintf_94
00005A9A  0C80 0000 10568          cmp.l     #88,D0
00005A9E  0058      
00005AA0  6700 005E 10569          beq       vsprintf_82
00005AA4  6E00 0184 10570          bgt       vsprintf_80
00005AA8  0C80 0000 10571          cmp.l     #69,D0
00005AAC  0045      
00005AAE  6700 0050 10572          beq       vsprintf_82
00005AB2  6000 0176 10573          bra       vsprintf_80
                    10574   vsprintf_94:
00005AB6  0C80 0000 10575          cmp.l     #101,D0
00005ABA  0065      
00005ABC  6700 0042 10576          beq       vsprintf_82
00005AC0  6E00 0168 10577          bgt       vsprintf_80
00005AC4  0C80 0000 10578          cmp.l     #100,D0
00005AC8  0064      
00005ACA  6734      10579          beq.s     vsprintf_82
00005ACC  6000 015C 10580          bra       vsprintf_80
                    10581   vsprintf_93:
00005AD0  0C80 0000 10582          cmp.l     #117,D0
00005AD4  0075      
00005AD6  6728      10583          beq.s     vsprintf_82
00005AD8  6E1A      10584          bgt.s     vsprintf_95
00005ADA  0C80 0000 10585          cmp.l     #115,D0
00005ADE  0073      
00005AE0  6700 0038 10586          beq       vsprintf_96
00005AE4  6E00 0144 10587          bgt       vsprintf_80
00005AE8  0C80 0000 10588          cmp.l     #111,D0
00005AEC  006F      
00005AEE  6710      10589          beq.s     vsprintf_82
00005AF0  6000 0138 10590          bra       vsprintf_80
                    10591   vsprintf_95:
00005AF4  0C80 0000 10592          cmp.l     #120,D0
00005AF8  0078      
00005AFA  6704      10593          beq.s     vsprintf_82
00005AFC  6000 012C 10594          bra       vsprintf_80
                    10595   vsprintf_82:
00005B00  4A2E FFD2 10596          tst.b     -46(A6)
00005B04  6714      10597          beq.s     vsprintf_96
00005B06  4A2E FFCD 10598          tst.b     -51(A6)
00005B0A  660E      10599          bne.s     vsprintf_96
00005B0C  200D      10600          move.l    A5,D0
00005B0E  9087      10601          sub.l     D7,D0
00005B10  4884      10602          ext.w     D4
00005B12  48C4      10603          ext.l     D4
00005B14  9084      10604          sub.l     D4,D0
00005B16  2D40 FFFC 10605          move.l    D0,-4(A6)
                    10606   vsprintf_96:
00005B1A  202E FFFC 10607          move.l    -4(A6),D0
00005B1E  0C80 0000 10608          cmp.l     #0,D0
00005B22  0000      
00005B24  6C04      10609          bge.s     vsprintf_98
00005B26  42AE FFFC 10610          clr.l     -4(A6)
                    10611   vsprintf_98:
00005B2A  4A2E FFCD 10612          tst.b     -51(A6)
00005B2E  6600 0030 10613          bne       vsprintf_104
00005B32  4884      10614          ext.w     D4
00005B34  48C4      10615          ext.l     D4
00005B36  2004      10616          move.l    D4,D0
00005B38  D0AE FFFC 10617          add.l     -4(A6),D0
00005B3C  D087      10618          add.l     D7,D0
00005B3E  1D40 FFD1 10619          move.b    D0,-47(A6)
                    10620   vsprintf_102:
00005B42  102E FFD1 10621          move.b    -47(A6),D0
00005B46  4880      10622          ext.w     D0
00005B48  48C0      10623          ext.l     D0
00005B4A  220D      10624          move.l    A5,D1
00005B4C  534D      10625          subq.w    #1,A5
00005B4E  B081      10626          cmp.l     D1,D0
00005B50  6C0E      10627          bge.s     vsprintf_104
00005B52  4878 0020 10628          pea       32
00005B56  2F0A      10629          move.l    A2,-(A7)
00005B58  4E93      10630          jsr       (A3)
00005B5A  504F      10631          addq.w    #8,A7
00005B5C  5286      10632          addq.l    #1,D6
00005B5E  60E2      10633          bra       vsprintf_102
                    10634   vsprintf_104:
00005B60  41EE FFD4 10635          lea       -44(A6),A0
00005B64  2408      10636          move.l    A0,D2
                    10637   vsprintf_105:
00005B66  2042      10638          move.l    D2,A0
00005B68  4A10      10639          tst.b     (A0)
00005B6A  6716      10640          beq.s     vsprintf_107
00005B6C  2042      10641          move.l    D2,A0
00005B6E  5282      10642          addq.l    #1,D2
00005B70  1210      10643          move.b    (A0),D1
00005B72  4881      10644          ext.w     D1
00005B74  48C1      10645          ext.l     D1
00005B76  2F01      10646          move.l    D1,-(A7)
00005B78  2F0A      10647          move.l    A2,-(A7)
00005B7A  4E93      10648          jsr       (A3)
00005B7C  504F      10649          addq.w    #8,A7
00005B7E  5286      10650          addq.l    #1,D6
00005B80  60E4      10651          bra       vsprintf_105
                    10652   vsprintf_107:
00005B82  202E FFFC 10653          move.l    -4(A6),D0
00005B86  1D40 FFD1 10654          move.b    D0,-47(A6)
                    10655   vsprintf_108:
00005B8A  102E FFD1 10656          move.b    -47(A6),D0
00005B8E  532E FFD1 10657          subq.b    #1,-47(A6)
00005B92  4A00      10658          tst.b     D0
00005B94  670E      10659          beq.s     vsprintf_110
00005B96  4878 0030 10660          pea       48
00005B9A  2F0A      10661          move.l    A2,-(A7)
00005B9C  4E93      10662          jsr       (A3)
00005B9E  504F      10663          addq.w    #8,A7
00005BA0  5286      10664          addq.l    #1,D6
00005BA2  60E6      10665          bra       vsprintf_108
                    10666   vsprintf_110:
00005BA4  2043      10667          move.l    D3,A0
00005BA6  4A10      10668          tst.b     (A0)
00005BA8  6700 0048 10669          beq       vsprintf_113
00005BAC  206E 000C 10670          move.l    12(A6),A0
00005BB0  1010      10671          move.b    (A0),D0
00005BB2  4880      10672          ext.w     D0
00005BB4  48C0      10673          ext.l     D0
00005BB6  0C80 0000 10674          cmp.l     #115,D0
00005BBA  0073      
00005BBC  670C      10675          beq.s     vsprintf_116
00005BBE  6E18      10676          bgt.s     vsprintf_119
00005BC0  0C80 0000 10677          cmp.l     #99,D0
00005BC4  0063      
00005BC6  6702      10678          beq.s     vsprintf_116
00005BC8  600E      10679          bra.s     vsprintf_119
                    10680   vsprintf_116:
00005BCA  2005      10681          move.l    D5,D0
00005BCC  5385      10682          subq.l    #1,D5
00005BCE  0C80 0000 10683          cmp.l     #0,D0
00005BD2  0000      
00005BD4  6E02      10684          bgt.s     vsprintf_119
00005BD6  6016      10685          bra.s     vsprintf_115
                    10686   vsprintf_119:
00005BD8  2043      10687          move.l    D3,A0
00005BDA  5283      10688          addq.l    #1,D3
00005BDC  1210      10689          move.b    (A0),D1
00005BDE  4881      10690          ext.w     D1
00005BE0  48C1      10691          ext.l     D1
00005BE2  2F01      10692          move.l    D1,-(A7)
00005BE4  2F0A      10693          move.l    A2,-(A7)
00005BE6  4E93      10694          jsr       (A3)
00005BE8  504F      10695          addq.w    #8,A7
00005BEA  5286      10696          addq.l    #1,D6
00005BEC  6002      10697          bra.s     vsprintf_112
                    10698   vsprintf_115:
00005BEE  6002      10699          bra.s     vsprintf_113
                    10700   vsprintf_112:
00005BF0  60B2      10701          bra       vsprintf_110
                    10702   vsprintf_113:
00005BF2  4A2E FFCD 10703          tst.b     -51(A6)
00005BF6  6700 0030 10704          beq       vsprintf_125
00005BFA  4884      10705          ext.w     D4
00005BFC  48C4      10706          ext.l     D4
00005BFE  2004      10707          move.l    D4,D0
00005C00  D0AE FFFC 10708          add.l     -4(A6),D0
00005C04  D087      10709          add.l     D7,D0
00005C06  1D40 FFD1 10710          move.b    D0,-47(A6)
                    10711   vsprintf_123:
00005C0A  102E FFD1 10712          move.b    -47(A6),D0
00005C0E  4880      10713          ext.w     D0
00005C10  48C0      10714          ext.l     D0
00005C12  220D      10715          move.l    A5,D1
00005C14  534D      10716          subq.w    #1,A5
00005C16  B081      10717          cmp.l     D1,D0
00005C18  6C0E      10718          bge.s     vsprintf_125
00005C1A  4878 0020 10719          pea       32
00005C1E  2F0A      10720          move.l    A2,-(A7)
00005C20  4E93      10721          jsr       (A3)
00005C22  504F      10722          addq.w    #8,A7
00005C24  5386      10723          subq.l    #1,D6
00005C26  60E2      10724          bra       vsprintf_123
                    10725   vsprintf_125:
00005C28  6014      10726          bra.s     vsprintf_81
                    10727   vsprintf_80:
00005C2A  206E 000C 10728          move.l    12(A6),A0
00005C2E  1210      10729          move.b    (A0),D1
00005C30  4881      10730          ext.w     D1
00005C32  48C1      10731          ext.l     D1
00005C34  2F01      10732          move.l    D1,-(A7)
00005C36  2F0A      10733          move.l    A2,-(A7)
00005C38  4E93      10734          jsr       (A3)
00005C3A  504F      10735          addq.w    #8,A7
00005C3C  5286      10736          addq.l    #1,D6
                    10737   vsprintf_81:
00005C3E  52AE 000C 10738          addq.l    #1,12(A6)
                    10739   vsprintf_2:
00005C42  6000 F9D6 10740          bra       vsprintf_1
                    10741   vsprintf_3:
00005C46  4A92      10742          tst.l     (A2)
00005C48  6710      10743          beq.s     vsprintf_126
00005C4A  4201      10744          clr.b     D1
00005C4C  C2BC 0000 10745          and.l     #255,D1
00005C50  00FF      
00005C52  2F01      10746          move.l    D1,-(A7)
00005C54  2F0A      10747          move.l    A2,-(A7)
00005C56  4E93      10748          jsr       (A3)
00005C58  504F      10749          addq.w    #8,A7
                    10750   vsprintf_126:
00005C5A  2006      10751          move.l    D6,D0
00005C5C  4CDF 3CFC 10752          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00005C60  4E5E      10753          unlk      A6
00005C62  4E75      10754          rts
                    10755   @itoa_convert:
00005C64  4E56 0000 10756          link      A6,#0
00005C68  48E7 3C00 10757          movem.l   D2/D3/D4/D5,-(A7)
00005C6C  242E 0008 10758          move.l    8(A6),D2
00005C70  262E 0010 10759          move.l    16(A6),D3
00005C74  2A2E 000C 10760          move.l    12(A6),D5
00005C78  2F05      10761          move.l    D5,-(A7)
00005C7A  2F03      10762          move.l    D3,-(A7)
00005C7C  6100 F6B4 10763          bsr       ULDIV
00005C80  202F 0004 10764          move.l    4(A7),D0
00005C84  504F      10765          addq.w    #8,A7
00005C86  2800      10766          move.l    D0,D4
00005C88  BA83      10767          cmp.l     D3,D5
00005C8A  651A      10768          blo.s     @itoa_convert_1
00005C8C  2F03      10769          move.l    D3,-(A7)
00005C8E  2F05      10770          move.l    D5,-(A7)
00005C90  2F03      10771          move.l    D3,-(A7)
00005C92  6100 F69E 10772          bsr       ULDIV
00005C96  2217      10773          move.l    (A7),D1
00005C98  504F      10774          addq.w    #8,A7
00005C9A  2F01      10775          move.l    D1,-(A7)
00005C9C  2F02      10776          move.l    D2,-(A7)
00005C9E  61C4      10777          bsr       @itoa_convert
00005CA0  DEFC 000C 10778          add.w     #12,A7
00005CA4  2400      10779          move.l    D0,D2
                    10780   @itoa_convert_1:
00005CA6  0C84 0000 10781          cmp.l     #9,D4
00005CAA  0009      
00005CAC  6E0A      10782          bgt.s     @itoa_convert_3
00005CAE  2004      10783          move.l    D4,D0
00005CB0  0680 0000 10784          add.l     #48,D0
00005CB4  0030      
00005CB6  600E      10785          bra.s     @itoa_convert_4
                    10786   @itoa_convert_3:
00005CB8  2004      10787          move.l    D4,D0
00005CBA  0680 0000 10788          add.l     #97,D0
00005CBE  0061      
00005CC0  0480 0000 10789          sub.l     #10,D0
00005CC4  000A      
                    10790   @itoa_convert_4:
00005CC6  2042      10791          move.l    D2,A0
00005CC8  1080      10792          move.b    D0,(A0)
00005CCA  2002      10793          move.l    D2,D0
00005CCC  5280      10794          addq.l    #1,D0
00005CCE  4CDF 003C 10795          movem.l   (A7)+,D2/D3/D4/D5
00005CD2  4E5E      10796          unlk      A6
00005CD4  4E75      10797          rts
                    10798   _ltoa:
00005CD6  4E56 0000 10799          link      A6,#0
00005CDA  48E7 3C00 10800          movem.l   D2/D3/D4/D5,-(A7)
00005CDE  242E 0008 10801          move.l    8(A6),D2
00005CE2  262E 000C 10802          move.l    12(A6),D3
00005CE6  2A2E 0010 10803          move.l    16(A6),D5
00005CEA  2803      10804          move.l    D3,D4
00005CEC  0C85 0000 10805          cmp.l     #2,D5
00005CF0  0002      
00005CF2  6D08      10806          blt.s     ltoa_3
00005CF4  0C85 0000 10807          cmp.l     #36,D5
00005CF8  0024      
00005CFA  6F06      10808          ble.s     ltoa_1
                    10809   ltoa_3:
00005CFC  2003      10810          move.l    D3,D0
00005CFE  6000 0052 10811          bra       ltoa_4
                    10812   ltoa_1:
00005D02  0C85 0000 10813          cmp.l     #10,D5
00005D06  000A      
00005D08  6600 0032 10814          bne       ltoa_5
00005D0C  0C82 0000 10815          cmp.l     #0,D2
00005D10  0000      
00005D12  6C28      10816          bge.s     ltoa_5
00005D14  2002      10817          move.l    D2,D0
00005D16  4480      10818          neg.l     D0
00005D18  2400      10819          move.l    D0,D2
00005D1A  0C82 0000 10820          cmp.l     #0,D2
00005D1E  0000      
00005D20  6C12      10821          bge.s     ltoa_7
00005D22  4879 0000 10822          pea       @itoa_1
00005D26  73A4      
00005D28  2F03      10823          move.l    D3,-(A7)
00005D2A  6100 F5F6 10824          bsr       _strcpy
00005D2E  504F      10825          addq.w    #8,A7
00005D30  2003      10826          move.l    D3,D0
00005D32  601E      10827          bra.s     ltoa_4
                    10828   ltoa_7:
00005D34  2044      10829          move.l    D4,A0
00005D36  5284      10830          addq.l    #1,D4
00005D38  10BC 002D 10831          move.b    #45,(A0)
                    10832   ltoa_5:
00005D3C  2F05      10833          move.l    D5,-(A7)
00005D3E  2F02      10834          move.l    D2,-(A7)
00005D40  2F04      10835          move.l    D4,-(A7)
00005D42  6100 FF20 10836          bsr       @itoa_convert
00005D46  DEFC 000C 10837          add.w     #12,A7
00005D4A  2800      10838          move.l    D0,D4
00005D4C  2044      10839          move.l    D4,A0
00005D4E  4210      10840          clr.b     (A0)
00005D50  2003      10841          move.l    D3,D0
                    10842   ltoa_4:
00005D52  4CDF 003C 10843          movem.l   (A7)+,D2/D3/D4/D5
00005D56  4E5E      10844          unlk      A6
00005D58  4E75      10845          rts
                    10846   _ultoa:
00005D5A  4E56 0000 10847          link      A6,#0
00005D5E  48E7 3800 10848          movem.l   D2/D3/D4,-(A7)
00005D62  262E 0010 10849          move.l    16(A6),D3
00005D66  282E 000C 10850          move.l    12(A6),D4
00005D6A  2404      10851          move.l    D4,D2
00005D6C  0C83 0000 10852          cmp.l     #2,D3
00005D70  0002      
00005D72  6D08      10853          blt.s     ultoa_3
00005D74  0C83 0000 10854          cmp.l     #36,D3
00005D78  0024      
00005D7A  6F04      10855          ble.s     ultoa_1
                    10856   ultoa_3:
00005D7C  2004      10857          move.l    D4,D0
00005D7E  6018      10858          bra.s     ultoa_4
                    10859   ultoa_1:
00005D80  2F03      10860          move.l    D3,-(A7)
00005D82  2F2E 0008 10861          move.l    8(A6),-(A7)
00005D86  2F02      10862          move.l    D2,-(A7)
00005D88  6100 FEDA 10863          bsr       @itoa_convert
00005D8C  DEFC 000C 10864          add.w     #12,A7
00005D90  2400      10865          move.l    D0,D2
00005D92  2042      10866          move.l    D2,A0
00005D94  4210      10867          clr.b     (A0)
00005D96  2004      10868          move.l    D4,D0
                    10869   ultoa_4:
00005D98  4CDF 001C 10870          movem.l   (A7)+,D2/D3/D4
00005D9C  4E5E      10871          unlk      A6
00005D9E  4E75      10872          rts
                    10873   _itoa:
00005DA0  4E56 0000 10874          link      A6,#0
00005DA4  2F2E 0010 10875          move.l    16(A6),-(A7)
00005DA8  2F2E 000C 10876          move.l    12(A6),-(A7)
00005DAC  2F2E 0008 10877          move.l    8(A6),-(A7)
00005DB0  6100 FF24 10878          bsr       _ltoa
00005DB4  DEFC 000C 10879          add.w     #12,A7
00005DB8  4E5E      10880          unlk      A6
00005DBA  4E75      10881          rts
                    10882   ULMUL:
00005DBC  4E56 0000 10883          link    A6,#0
00005DC0  48E7 C000 10884          movem.l D0/D1,-(A7)
00005DC4  222E 0008 10885          move.l  8(A6),D1
00005DC8  202E 000C 10886          move.l  12(A6),D0
00005DCC  602C      10887          bra.s   lmul_3
                    10888   LMUL:
00005DCE  4E56 0000 10889          link    A6,#0
00005DD2  48E7 C000 10890          movem.l D0/D1,-(A7)
00005DD6  222E 0008 10891          move.l  8(A6),D1
00005DDA  202E 000C 10892          move.l  12(A6),D0
00005DDE  4A80      10893          tst.l   D0
00005DE0  6A0A      10894          bpl.s   lmul_1
00005DE2  4480      10895          neg.l   D0
00005DE4  4A81      10896          tst.l   D1
00005DE6  6A0A      10897          bpl.s   lmul_2
00005DE8  4481      10898          neg.l   D1
00005DEA  600E      10899          bra.s   lmul_3
                    10900   lmul_1:
00005DEC  4A81      10901          tst.l   D1
00005DEE  6A0A      10902          bpl.s   lmul_3
00005DF0  4481      10903          neg.l   D1
                    10904   lmul_2:
00005DF2  6114      10905          bsr.s   domul
00005DF4  4481      10906          neg.l   D1
00005DF6  4080      10907          negx.l  D0
00005DF8  6002      10908          bra.s   lmul_4
                    10909   lmul_3:
00005DFA  610C      10910          bsr.s   domul
                    10911   lmul_4:
00005DFC  2D41 0008 10912          move.l  D1,8(A6)
00005E00  4CDF 0003 10913          movem.l (A7)+,D0/D1
00005E04  4E5E      10914          unlk    A6
00005E06  4E75      10915          rts
                    10916   domul:
00005E08  0C81 0000 10917          cmpi.l  #$FFFF,D1
00005E0C  FFFF      
00005E0E  620C      10918          bhi.s   domul_1
00005E10  0C80 0000 10919          cmpi.l  #$FFFF,D0
00005E14  FFFF      
00005E16  620E      10920          bhi.s   domul_2
00005E18  C2C0      10921          mulu    D0,D1
00005E1A  4E75      10922          rts
                    10923   domul_1:
00005E1C  0C80 0000 10924          cmpi.l  #$FFFF,D0
00005E20  FFFF      
00005E22  6218      10925          bhi.s   domul_4
00005E24  6002      10926          bra.s   domul_3
                    10927   domul_2
00005E26  C141      10928          exg     D0,D1
                    10929   domul_3:
00005E28  2F02      10930          move.l  D2,-(A7)
00005E2A  2401      10931          move.l  D1,D2
00005E2C  4842      10932          swap    D2
00005E2E  C2C0      10933          mulu    D0,D1
00005E30  C4C0      10934          mulu    D0,D2
00005E32  4842      10935          swap    D2
00005E34  4242      10936          clr.w   D2
00005E36  D282      10937          add.l   D2,D1
00005E38  241F      10938          move.l  (A7)+,D2
00005E3A  4E75      10939          rts
                    10940   domul_4:
00005E3C  48E7 3000 10941          movem.l D2/D3,-(A7)
00005E40  2401      10942          move.l  D1,D2
00005E42  2601      10943          move.l  D1,D3
00005E44  C2C0      10944          mulu    D0,D1
00005E46  4842      10945          swap    D2
00005E48  C4C0      10946          mulu    D0,D2
00005E4A  4840      10947          swap    D0
00005E4C  C6C0      10948          mulu    D0,D3
00005E4E  D483      10949          add.l   D3,D2
00005E50  4842      10950          swap    D2
00005E52  4242      10951          clr.w   D2
00005E54  D282      10952          add.l   D2,D1
00005E56  4CDF 000C 10953          movem.l (A7)+,D2/D3
00005E5A  4E75      10954          rts
                    10955   _strlen:
00005E5C  206F 0004 10956          move.l    (4,A7),A0
00005E60  2248      10957          move.l    A0,A1
                    10958   strlen_1:
00005E62  4A19      10959          tst.b     (A1)+
00005E64  66FC      10960          bne       strlen_1
00005E66  2009      10961          move.l    A1,D0
00005E68  9088      10962          sub.l     A0,D0
00005E6A  5380      10963          subq.l    #1,D0
00005E6C  4E75      10964          rts
                    10965          section   const
                    10966   
                    10967   @m68kde~2_1:
00005E6E  0D0A 00   10968          dc.b      13,10,0
                    10969   @m68kde~2_2:
00005E72  0D53 7769 10970          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
00005E76  7463 6865 
00005E7A  7320 5357 
00005E7E  5B        
00005E7F  372D 305D 10971          dc.b      55,45,48,93,32,61,32,0
00005E83  203D 2000 
                    10972   @m68kde~2_3:
00005E88  3000      10973          dc.b      48,0
                    10974   @m68kde~2_4:
00005E8A  3100      10975          dc.b      49,0
                    10976   @m68kde~2_5:
00005E8C  0D0A 456E 10977          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00005E90  7465 7220 
00005E94  5374 6172 
00005E98  74        
00005E99  2041 6464 10978          dc.b      32,65,100,100,114,101,115,115,58,32,0
00005E9D  7265 7373 
00005EA1  3A20 00   
                    10979   @m68kde~2_6:
00005EA4  0D0A 3C45 10980          dc.b      13,10,60,69,83,67,62,32,61,32,65,98,111,114
00005EA8  5343 3E20 
00005EAC  3D20 4162 
00005EB0  6F72      
00005EB2  742C 2053 10981          dc.b      116,44,32,83,80,65,67,69,32,116,111,32,67,111
00005EB6  5041 4345 
00005EBA  2074 6F20 
00005EBE  436F      
00005EC0  6E74 696E 10982          dc.b      110,116,105,110,117,101,0
00005EC4  7565 00   
                    10983   @m68kde~2_7:
00005EC8  0D0A 2530 10984          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,32,32
00005ECC  3858 2020 
00005ED0  2530 3458 
00005ED4  2020 20   
00005ED7  2020 2020 10985          dc.b      32,32,32,32,32,32,32,32,32,32,32,32,32,32,32
00005EDB  2020 2020 
00005EDF  2020 2020 
00005EE3  2020 20   
00005EE6  2020 2020 10986          dc.b      32,32,32,32,32,32,37,115,0
00005EEA  2020 2573 
00005EEE  00        
                    10987   @m68kde~2_8:
00005EF0  0D0A 2530 10988          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
00005EF4  3858 2020 
00005EF8  2530 3458 
00005EFC  2025 30   
00005EFF  3458 2020 10989          dc.b      52,88,32,32,32,32,32,32,32,32,32,32,32,32,32
00005F03  2020 2020 
00005F07  2020 2020 
00005F0B  2020 20   
00005F0E  2020 2020 10990          dc.b      32,32,32,32,32,32,37,115,0
00005F12  2020 2573 
00005F16  00        
                    10991   @m68kde~2_9:
00005F18  0D0A 2530 10992          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
00005F1C  3858 2020 
00005F20  2530 3458 
00005F24  2025 30   
00005F27  3458 2025 10993          dc.b      52,88,32,37,48,52,88,32,32,32,32,32,32,32,32
00005F2B  3034 5820 
00005F2F  2020 2020 
00005F33  2020 20   
00005F36  2020 2020 10994          dc.b      32,32,32,32,32,32,37,115,0
00005F3A  2020 2573 
00005F3E  00        
                    10995   @m68kde~2_10:
00005F40  0D0A 2530 10996          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
00005F44  3858 2020 
00005F48  2530 3458 
00005F4C  2025 30   
00005F4F  3458 2025 10997          dc.b      52,88,32,37,48,52,88,32,37,48,52,88,32,32,32
00005F53  3034 5820 
00005F57  2530 3458 
00005F5B  2020 20   
00005F5E  2020 2020 10998          dc.b      32,32,32,32,32,32,37,115,0
00005F62  2020 2573 
00005F66  00        
                    10999   @m68kde~2_11:
00005F68  0D0A 2530 11000          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
00005F6C  3858 2020 
00005F70  2530 3458 
00005F74  2025 30   
00005F77  3458 2025 11001          dc.b      52,88,32,37,48,52,88,32,37,48,52,88,32,37,48
00005F7B  3034 5820 
00005F7F  2530 3458 
00005F83  2025 30   
00005F86  3458 2020 11002          dc.b      52,88,32,32,32,32,37,115,0
00005F8A  2020 2573 
00005F8E  00        
                    11003   @m68kde~2_12:
00005F90  0D0A 4475 11004          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
00005F94  6D70 204D 
00005F98  656D 6F72 
00005F9C  79        
00005F9D  2042 6C6F 11005          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00005FA1  636B 3A20 
00005FA5  3C45 5343 
00005FA9  3E20      
00005FAB  746F 2041 11006          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00005FAF  626F 7274 
00005FB3  2C20 3C53 
00005FB7  50        
00005FB8  4143 453E 11007          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00005FBC  2074 6F20 
00005FC0  436F 6E74 
00005FC4  69        
00005FC5  6E75 6500 11008          dc.b      110,117,101,0
                    11009   @m68kde~2_13:
00005FCA  0D0A 2530 11010          dc.b      13,10,37,48,56,120,32,0
00005FCE  3878 2000 
                    11011   @m68kde~2_14:
00005FD2  2530 3258 11012          dc.b      37,48,50,88,0
00005FD6  00        
                    11013   @m68kde~2_15:
00005FD8  2020 00   11014          dc.b      32,32,0
                    11015   @m68kde~2_16:
00005FDC  0D0A 4669 11016          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00005FE0  6C6C 204D 
00005FE4  656D 6F72 
00005FE8  79        
00005FE9  2042 6C6F 11017          dc.b      32,66,108,111,99,107,0
00005FED  636B 00   
                    11018   @m68kde~2_17:
00005FF0  0D0A 456E 11019          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00005FF4  7465 7220 
00005FF8  456E 6420 
00005FFC  41        
00005FFD  6464 7265 11020          dc.b      100,100,114,101,115,115,58,32,0
00006001  7373 3A20 
00006005  00        
                    11021   @m68kde~2_18:
00006006  0D0A 456E 11022          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
0000600A  7465 7220 
0000600E  4669 6C6C 
00006012  20        
00006013  4461 7461 11023          dc.b      68,97,116,97,58,32,0
00006017  3A20 00   
                    11024   @m68kde~2_19:
0000601A  0D0A 4669 11025          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
0000601E  6C6C 696E 
00006022  6720 4164 
00006026  64        
00006027  7265 7373 11026          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
0000602B  6573 205B 
0000602F  2425 3038 
00006033  58        
00006034  202D 2024 11027          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00006038  2530 3858 
0000603C  5D20 7769 
00006040  7468      
00006042  2024 2530 11028          dc.b      32,36,37,48,50,88,0
00006046  3258 00   
                    11029   @m68kde~2_20:
0000604A  0D0A 5573 11030          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
0000604E  6520 4879 
00006052  7065 7254 
00006056  65        
00006057  726D 696E 11031          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
0000605B  616C 2074 
0000605F  6F20 5365 
00006063  6E64 2054 11032          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00006067  6578 7420 
0000606B  4669 6C65 
0000606F  2028 2E68 11033          dc.b      32,40,46,104,101,120,41,13,10,0
00006073  6578 290D 
00006077  0A00      
                    11034   @m68kde~2_21:
0000607A  0D0A 4C6F 11035          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
0000607E  6164 2046 
00006082  6169 6C65 
00006086  64        
00006087  2061 7420 11036          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
0000608B  4164 6472 
0000608F  6573 7320 
00006093  3D        
00006094  205B 2425 11037          dc.b      32,91,36,37,48,56,88,93,13,10,0
00006098  3038 585D 
0000609C  0D0A 00   
                    11038   @m68kde~2_22:
000060A0  0D0A 5375 11039          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
000060A4  6363 6573 
000060A8  733A 2044 
000060AC  6F        
000060AD  776E 6C6F 11040          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
000060B1  6164 6564 
000060B5  2025 6420 
000060B9  6279 7465 11041          dc.b      98,121,116,101,115,13,10,0
000060BD  730D 0A00 
                    11042   @m68kde~2_23:
000060C2  0D0A 4578 11043          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
000060C6  616D 696E 
000060CA  6520 616E 
000060CE  64        
000060CF  2043 6861 11044          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
000060D3  6E67 6520 
000060D7  4D65 6D6F 
000060DB  72        
000060DC  7900      11045          dc.b      121,0
                    11046   @m68kde~2_24:
000060DE  0D0A 3C45 11047          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
000060E2  5343 3E20 
000060E6  746F 2053 
000060EA  746F      
000060EC  702C 203C 11048          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
000060F0  5350 4143 
000060F4  453E 2074 
000060F8  6F20      
000060FA  4164 7661 11049          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
000060FE  6E63 652C 
00006102  2027 2D27 
00006106  2074      
00006108  6F20 476F 11050          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
0000610C  2042 6163 
00006110  6B2C 203C 
00006114  4441      
00006116  5441 3E20 11051          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
0000611A  746F 2063 
0000611E  6861 6E67 
00006122  65        
00006123  00        11052          dc.b      0
                    11053   @m68kde~2_25:
00006124  0D0A 456E 11054          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00006128  7465 7220 
0000612C  4164 6472 
00006130  65        
00006131  7373 3A20 11055          dc.b      115,115,58,32,0
00006135  00        
                    11056   @m68kde~2_26:
00006136  0D0A 5B25 11057          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
0000613A  3038 785D 
0000613E  203A 2025 
00006142  3032 78   
00006145  2020 00   11058          dc.b      32,32,0
                    11059   @m68kde~2_27:
00006148  0D0A 5761 11060          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
0000614C  726E 696E 
00006150  6720 4368 
00006154  61        
00006155  6E67 6520 11061          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
00006159  4661 696C 
0000615D  6564 3A20 
00006161  57        
00006162  726F 7465 11062          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
00006166  205B 2530 
0000616A  3278 5D2C 
0000616E  20        
0000616F  5265 6164 11063          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
00006173  205B 2530 
00006177  3278 5D00 
                    11064   @m68kde~2_28:
0000617C  2425 3038 11065          dc.b      36,37,48,56,88,32,32,0
00006180  5820 2000 
                    11066   @m68kde~2_29:
00006184  2000      11067          dc.b      32,0
                    11068   @m68kde~2_30:
00006186  2E00      11069          dc.b      46,0
                    11070   @m68kde~2_31:
00006188  2563 00   11071          dc.b      37,99,0
                    11072   @m68kde~2_32:
0000618C  00        11073          dc.b      0
                    11074   @m68kde~2_33:
0000618E  0D0A 0D0A 11075          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
00006192  2044 3020 
00006196  3D20 2425 
0000619A  3038 58   
0000619D  2020 4130 11076          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
000061A1  203D 2024 
000061A5  2530 3858 
000061A9  00        
                    11077   @m68kde~2_34:
000061AA  0D0A 2044 11078          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
000061AE  3120 3D20 
000061B2  2425 3038 
000061B6  5820 20   
000061B9  4131 203D 11079          dc.b      65,49,32,61,32,36,37,48,56,88,0
000061BD  2024 2530 
000061C1  3858 00   
                    11080   @m68kde~2_35:
000061C4  0D0A 2044 11081          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
000061C8  3220 3D20 
000061CC  2425 3038 
000061D0  5820 20   
000061D3  4132 203D 11082          dc.b      65,50,32,61,32,36,37,48,56,88,0
000061D7  2024 2530 
000061DB  3858 00   
                    11083   @m68kde~2_36:
000061DE  0D0A 2044 11084          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
000061E2  3320 3D20 
000061E6  2425 3038 
000061EA  5820 20   
000061ED  4133 203D 11085          dc.b      65,51,32,61,32,36,37,48,56,88,0
000061F1  2024 2530 
000061F5  3858 00   
                    11086   @m68kde~2_37:
000061F8  0D0A 2044 11087          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
000061FC  3420 3D20 
00006200  2425 3038 
00006204  5820 20   
00006207  4134 203D 11088          dc.b      65,52,32,61,32,36,37,48,56,88,0
0000620B  2024 2530 
0000620F  3858 00   
                    11089   @m68kde~2_38:
00006212  0D0A 2044 11090          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
00006216  3520 3D20 
0000621A  2425 3038 
0000621E  5820 20   
00006221  4135 203D 11091          dc.b      65,53,32,61,32,36,37,48,56,88,0
00006225  2024 2530 
00006229  3858 00   
                    11092   @m68kde~2_39:
0000622C  0D0A 2044 11093          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
00006230  3620 3D20 
00006234  2425 3038 
00006238  5820 20   
0000623B  4136 203D 11094          dc.b      65,54,32,61,32,36,37,48,56,88,0
0000623F  2024 2530 
00006243  3858 00   
                    11095   @m68kde~2_40:
00006246  0D0A 2044 11096          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
0000624A  3720 3D20 
0000624E  2425 3038 
00006252  5820 20   
00006255  4137 203D 11097          dc.b      65,55,32,61,32,36,37,48,56,88,0
00006259  2024 2530 
0000625D  3858 00   
                    11098   @m68kde~2_41:
00006260  0D0A 0D0A 11099          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
00006264  5553 5020 
00006268  3D20 2425 
0000626C  3038 58   
0000626F  2020 2841 11100          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
00006273  3729 2055 
00006277  7365 7220 
0000627B  5350      
0000627D  00        11101          dc.b      0
                    11102   @m68kde~2_42:
0000627E  0D0A 5353 11103          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
00006282  5020 3D20 
00006286  2425 3038 
0000628A  5820 20   
0000628D  2841 3729 11104          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
00006291  2053 7570 
00006295  6572 7669 
00006299  73        
0000629A  6F72 2053 11105          dc.b      111,114,32,83,80,0
0000629E  5000      
                    11106   @m68kde~2_43:
000062A0  0D0A 2053 11107          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
000062A4  5220 3D20 
000062A8  2425 3034 
000062AC  5820 20   
000062AF  2000      11108          dc.b      32,0
                    11109   @m68kde~2_44:
000062B2  2020 205B 11110          dc.b      32,32,32,91,0
000062B6  00        
                    11111   @m68kde~2_45:
000062B8  0D0A 2050 11112          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
000062BC  4320 3D20 
000062C0  2425 3038 
000062C4  5820 20   
000062C7  00        11113          dc.b      0
                    11114   @m68kde~2_46:
000062C8  2573 00   11115          dc.b      37,115,0
                    11116   @m68kde~2_47:
000062CC  5B42 5245 11117          dc.b      91,66,82,69,65,75,80,79,73,78,84,93,0
000062D0  414B 504F 
000062D4  494E 545D 
000062D8  00        
                    11118   @m68kde~2_48:
000062DA  0D0A 5750 11119          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
000062DE  2564 203D 
000062E2  2025 7300 
                    11120   @m68kde~2_49:
000062E6  0D0A 0D0A 11121          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
000062EA  0D0A 0D0A 
000062EE  0D0A 0D0A 
000062F2  5369 6E   
000062F5  676C 6520 11122          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
000062F9  5374 6570 
000062FD  2020 3A5B 
00006301  4F        
00006302  4E5D 00   11123          dc.b      78,93,0
                    11124   @m68kde~2_50:
00006306  0D0A 4272 11125          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000630A  6561 6B20 
0000630E  506F 696E 
00006312  74        
00006313  7320 3A5B 11126          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
00006317  4469 7361 
0000631B  626C 6564 
0000631F  5D        
00006320  00        11127          dc.b      0
                    11128   @m68kde~2_51:
00006322  0D0A 5072 11129          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
00006326  6573 7320 
0000632A  3C53 5041 
0000632E  4345      
00006330  3E20 746F 11130          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
00006334  2045 7865 
00006338  6375 7465 
0000633C  20        
0000633D  4E65 7874 11131          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
00006341  2049 6E73 
00006345  7472 7563 
00006349  7469 6F6E 11132          dc.b      116,105,111,110,0
0000634D  00        
                    11133   @m68kde~2_52:
0000634E  0D0A 5072 11134          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00006352  6573 7320 
00006356  3C45 5343 
0000635A  3E20      
0000635C  746F 2052 11135          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
00006360  6573 756D 
00006364  6520 5072 
00006368  6F67 7261 11136          dc.b      111,103,114,97,109,0
0000636C  6D00      
                    11137   @m68kde~2_53:
0000636E  0D0A 496C 11138          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
00006372  6C65 6761 
00006376  6C20 4461 
0000637A  74        
0000637B  6120 5265 11139          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
0000637F  6769 7374 
00006383  6572 203A 
00006387  20        
00006388  5573 6520 11140          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
0000638C  4430 2D44 
00006390  372E 2E2E 
00006394  2E2E      
00006396  0D0A 00   11141          dc.b      13,10,0
                    11142   @m68kde~2_54:
0000639A  0D0A 4425 11143          dc.b      13,10,68,37,99,32,61,32,0
0000639E  6320 3D20 
000063A2  00        
                    11144   @m68kde~2_55:
000063A4  0D0A 496C 11145          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
000063A8  6C65 6761 
000063AC  6C20 4164 
000063B0  64        
000063B1  7265 7373 11146          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
000063B5  2052 6567 
000063B9  6973 7465 
000063BD  7220 3A20 11147          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
000063C1  5573 6520 
000063C5  4130 2D41 
000063C9  372E      
000063CB  2E2E 2E2E 11148          dc.b      46,46,46,46,13,10,0
000063CF  0D0A 00   
                    11149   @m68kde~2_56:
000063D2  0D0A 4125 11150          dc.b      13,10,65,37,99,32,61,32,0
000063D6  6320 3D20 
000063DA  00        
                    11151   @m68kde~2_57:
000063DC  0D0A 5573 11152          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
000063E0  6572 2053 
000063E4  5020 3D20 
000063E8  00        
                    11153   @m68kde~2_58:
000063EA  0D0A 496C 11154          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
000063EE  6C65 6761 
000063F2  6C20 5265 
000063F6  67        
000063F7  6973 7465 11155          dc.b      105,115,116,101,114,46,46,46,46,0
000063FB  722E 2E2E 
000063FF  2E00      
                    11156   @m68kde~2_59:
00006402  0D0A 5379 11157          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
00006406  7374 656D 
0000640A  2053 5020 
0000640E  3D        
0000640F  2000      11158          dc.b      32,0
                    11159   @m68kde~2_60:
00006412  0D0A 5043 11160          dc.b      13,10,80,67,32,61,32,0
00006416  203D 2000 
                    11161   @m68kde~2_61:
0000641A  0D0A 5352 11162          dc.b      13,10,83,82,32,61,32,0
0000641E  203D 2000 
                    11163   @m68kde~2_62:
00006422  0D0A 496C 11164          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00006426  6C65 6761 
0000642A  6C20 5265 
0000642E  67        
0000642F  6973 7465 11165          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
00006433  723A 2055 
00006437  7365 2041 
0000643B  30        
0000643C  2D41 372C 11166          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
00006440  2044 302D 
00006444  4437 2C20 
00006448  5353 50   
0000644B  2C20 5553 11167          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
0000644F  502C 2050 
00006453  4320 6F72 
00006457  2053      
00006459  520D 0A00 11168          dc.b      82,13,10,0
                    11169   @m68kde~2_63:
0000645E  0D0A 0D0A 11170          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
00006462  4E75 6D20 
00006466  2020 2020 
0000646A  4164      
0000646C  6472 6573 11171          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
00006470  7320 2020 
00006474  2020 2049 
00006478  6E        
00006479  7374 7275 11172          dc.b      115,116,114,117,99,116,105,111,110,0
0000647D  6374 696F 
00006481  6E00      
                    11173   @m68kde~2_64:
00006484  0D0A 2D2D 11174          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00006488  2D20 2020 
0000648C  2020 2D2D 
00006490  2D2D 2D   
00006493  2D2D 2D2D 11175          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
00006497  2020 2020 
0000649B  2D2D 2D2D 
0000649F  2D2D 2D   
000064A2  2D2D 2D2D 11176          dc.b      45,45,45,45,0
000064A6  00        
                    11177   @m68kde~2_65:
000064A8  0D0A 4E6F 11178          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
000064AC  2042 7265 
000064B0  616B 506F 
000064B4  69        
000064B5  6E74 7320 11179          dc.b      110,116,115,32,83,101,116,0
000064B9  5365 7400 
                    11180   @m68kde~2_66:
000064BE  0D0A 2533 11181          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
000064C2  6420 2020 
000064C6  2020 2425 
000064CA  3038 78   
000064CD  00        11182          dc.b      0
                    11183   @m68kde~2_67:
000064CE  2020 2020 11184          dc.b      32,32,32,32,37,115,0
000064D2  2573 00   
                    11185   @m68kde~2_68:
000064D6  0D0A 4E75 11186          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
000064DA  6D20 2020 
000064DE  2020 4164 
000064E2  6472      
000064E4  6573 7300 11187          dc.b      101,115,115,0
                    11188   @m68kde~2_69:
000064E8  0D0A 2D2D 11189          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
000064EC  2D20 2020 
000064F0  2020 2D2D 
000064F4  2D2D 2D   
000064F7  2D2D 2D2D 11190          dc.b      45,45,45,45,0
000064FB  00        
                    11191   @m68kde~2_70:
000064FC  0D0A 4E6F 11192          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
00006500  2057 6174 
00006504  6368 506F 
00006508  69        
00006509  6E74 7320 11193          dc.b      110,116,115,32,83,101,116,0
0000650D  5365 7400 
                    11194   @m68kde~2_71:
00006512  0D0A 456E 11195          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
00006516  7465 7220 
0000651A  4272 6561 
0000651E  6B        
0000651F  2050 6F69 11196          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00006523  6E74 204E 
00006527  756D 6265 
0000652B  72        
0000652C  3A20 00   11197          dc.b      58,32,0
                    11198   @m68kde~2_72:
00006530  0D0A 496C 11199          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
00006534  6C65 6761 
00006538  6C20 5261 
0000653C  6E        
0000653D  6765 203A 11200          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
00006541  2055 7365 
00006545  2030 202D 
00006549  2037      
0000654B  00        11201          dc.b      0
                    11202   @m68kde~2_73:
0000654C  0D0A 4272 11203          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006550  6561 6B20 
00006554  506F 696E 
00006558  74        
00006559  2043 6C65 11204          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
0000655D  6172 6564 
00006561  2E2E 2E2E 
00006565  2E        
00006566  0D0A 00   11205          dc.b      13,10,0
                    11206   @m68kde~2_74:
0000656A  0D0A 4272 11207          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000656E  6561 6B20 
00006572  506F 696E 
00006576  74        
00006577  2077 6173 11208          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
0000657B  6E27 7420 
0000657F  5365 742E 
00006583  2E        
00006584  2E2E 2E00 11209          dc.b      46,46,46,0
                    11210   @m68kde~2_75:
00006588  0D0A 456E 11211          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
0000658C  7465 7220 
00006590  5761 7463 
00006594  68        
00006595  2050 6F69 11212          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00006599  6E74 204E 
0000659D  756D 6265 
000065A1  72        
000065A2  3A20 00   11213          dc.b      58,32,0
                    11214   @m68kde~2_76:
000065A6  0D0A 5761 11215          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000065AA  7463 6820 
000065AE  506F 696E 
000065B2  74        
000065B3  2043 6C65 11216          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000065B7  6172 6564 
000065BB  2E2E 2E2E 
000065BF  2E        
000065C0  0D0A 00   11217          dc.b      13,10,0
                    11218   @m68kde~2_77:
000065C4  0D0A 5761 11219          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000065C8  7463 6820 
000065CC  506F 696E 
000065D0  74        
000065D1  2057 6173 11220          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
000065D5  206E 6F74 
000065D9  2053 6574 
000065DD  2E        
000065DE  2E2E 2E2E 11221          dc.b      46,46,46,46,0
000065E2  00        
                    11222   @m68kde~2_78:
000065E4  0D0A 4E6F 11223          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
000065E8  2046 5245 
000065EC  4520 4272 
000065F0  6561      
000065F2  6B20 506F 11224          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
000065F6  696E 7473 
000065FA  2E2E 2E2E 
000065FE  2E        
000065FF  00        11225          dc.b      0
                    11226   @m68kde~2_79:
00006600  0D0A 4272 11227          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006604  6561 6B20 
00006608  506F 696E 
0000660C  74        
0000660D  2041 6464 11228          dc.b      32,65,100,100,114,101,115,115,58,32,0
00006611  7265 7373 
00006615  3A20 00   
                    11229   @m68kde~2_80:
00006618  0D0A 4572 11230          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
0000661C  726F 7220 
00006620  3A20 4272 
00006624  65        
00006625  616B 2050 11231          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00006629  6F69 6E74 
0000662D  7320 4341 
00006631  4E        
00006632  4E4F 5420 11232          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00006636  6265 2073 
0000663A  6574 2061 
0000663E  74        
0000663F  204F 4444 11233          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
00006643  2061 6464 
00006647  7265 7373 
0000664B  65        
0000664C  7300      11234          dc.b      115,0
                    11235   @m68kde~2_81:
0000664E  0D0A 4572 11236          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00006652  726F 7220 
00006656  3A20 4272 
0000665A  65        
0000665B  616B 2050 11237          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
0000665F  6F69 6E74 
00006663  7320 4341 
00006667  4E        
00006668  4E4F 5420 11238          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
0000666C  6265 2073 
00006670  6574 2066 
00006674  6F        
00006675  7220 524F 11239          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
00006679  4D20 696E 
0000667D  2052 616E 
00006681  67        
00006682  6520 3A20 11240          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
00006686  5B24 302D 
0000668A  2430 3030 
0000668E  3037 46   
00006691  4646 5D00 11241          dc.b      70,70,93,0
                    11242   @m68kde~2_82:
00006696  0D0A 4572 11243          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
0000669A  726F 723A 
0000669E  2042 7265 
000066A2  61        
000066A3  6B20 506F 11244          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
000066A7  696E 7420 
000066AB  416C 7265 
000066AF  6164 7920 11245          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
000066B3  4578 6973 
000066B7  7473 2061 
000066BB  74        
000066BC  2041 6464 11246          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
000066C0  7265 7373 
000066C4  203A 2025 
000066C8  30        
000066C9  3878 0D0A 11247          dc.b      56,120,13,10,0
000066CD  00        
                    11248   @m68kde~2_83:
000066CE  0D0A 4272 11249          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000066D2  6561 6B20 
000066D6  506F 696E 
000066DA  74        
000066DB  2053 6574 11250          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
000066DF  2061 7420 
000066E3  4164 6472 
000066E7  65        
000066E8  7373 3A20 11251          dc.b      115,115,58,32,91,36,37,48,56,120,93,44,32,73
000066EC  5B24 2530 
000066F0  3878 5D2C 
000066F4  2049      
000066F6  6E73 7472 11252          dc.b      110,115,116,114,117,99,116,105,111,110,32,61
000066FA  7563 7469 
000066FE  6F6E 203D 
00006702  2025 7300 11253          dc.b      32,37,115,0
                    11254   @m68kde~2_84:
00006706  0D0A 4E6F 11255          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
0000670A  2046 5245 
0000670E  4520 5761 
00006712  7463      
00006714  6820 506F 11256          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00006718  696E 7473 
0000671C  2E2E 2E2E 
00006720  2E        
00006721  00        11257          dc.b      0
                    11258   @m68kde~2_85:
00006722  0D0A 5761 11259          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00006726  7463 6820 
0000672A  506F 696E 
0000672E  74        
0000672F  2041 6464 11260          dc.b      32,65,100,100,114,101,115,115,58,32,0
00006733  7265 7373 
00006737  3A20 00   
                    11261   @m68kde~2_86:
0000673A  0D0A 4572 11262          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
0000673E  726F 723A 
00006742  2057 6174 
00006746  63        
00006747  6820 506F 11263          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
0000674B  696E 7420 
0000674F  416C 7265 
00006753  6164 7920 11264          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
00006757  5365 7420 
0000675B  6174 2041 
0000675F  64        
00006760  6472 6573 11265          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
00006764  7320 3A20 
00006768  2530 3878 
0000676C  0D        
0000676D  0A00      11266          dc.b      10,0
                    11267   @m68kde~2_87:
00006770  0D0A 5761 11268          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00006774  7463 6820 
00006778  506F 696E 
0000677C  74        
0000677D  2053 6574 11269          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00006781  2061 7420 
00006785  4164 6472 
00006789  65        
0000678A  7373 3A20 11270          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
0000678E  5B24 2530 
00006792  3878 5D00 
                    11271   @m68kde~2_88:
00006796  0D0A 0D0A 11272          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
0000679A  0D0A 0D0A 
0000679E  4042 5245 
000067A2  414B 50   
000067A5  4F49 4E54 11273          dc.b      79,73,78,84,0
000067A9  00        
                    11274   @m68kde~2_89:
000067AA  0D0A 5369 11275          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000067AE  6E67 6C65 
000067B2  2053 7465 
000067B6  70        
000067B7  203A 205B 11276          dc.b      32,58,32,91,79,78,93,0
000067BB  4F4E 5D00 
                    11277   @m68kde~2_90:
000067C0  0D0A 4272 11278          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
000067C4  6561 6B50 
000067C8  6F69 6E74 
000067CC  73        
000067CD  203A 205B 11279          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
000067D1  456E 6162 
000067D5  6C65 645D 
000067D9  00        
                    11280   @m68kde~2_91:
000067DA  0D0A 5072 11281          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
000067DE  6573 7320 
000067E2  3C45 5343 
000067E6  3E20      
000067E8  746F 2052 11282          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
000067EC  6573 756D 
000067F0  6520 5573 
000067F4  6572 2050 11283          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
000067F8  726F 6772 
000067FC  616D 0D0A 
00006800  00        
                    11284   @m68kde~2_92:
00006802  0D0A 556E 11285          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
00006806  6B6E 6F77 
0000680A  6E20 436F 
0000680E  6D        
0000680F  6D61 6E64 11286          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
00006813  2E2E 2E2E 
00006817  2E0D 0A00 
                    11287   @m68kde~2_93:
0000681C  0D0A 5072 11288          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
00006820  6F67 7261 
00006824  6D20 456E 
00006828  64        
00006829  6564 2028 11289          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
0000682D  5452 4150 
00006831  2023 3135 
00006835  292E      
00006837  2E2E 2E00 11290          dc.b      46,46,46,0
                    11291   @m68kde~2_94:
0000683C  0D0A 4B69 11292          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
00006840  6C6C 2041 
00006844  6C6C 2042 
00006848  72        
00006849  6561 6B20 11293          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
0000684D  506F 696E 
00006851  7473 2E2E 
00006855  2E        
00006856  2879 2F6E 11294          dc.b      40,121,47,110,41,63,0
0000685A  293F 00   
                    11295   @m68kde~2_95:
0000685E  0D0A 4B69 11296          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
00006862  6C6C 2041 
00006866  6C6C 2057 
0000686A  61        
0000686B  7463 6820 11297          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
0000686F  506F 696E 
00006873  7473 2E2E 
00006877  2E        
00006878  2879 2F6E 11298          dc.b      40,121,47,110,41,63,0
0000687C  293F 00   
                    11299   @m68kde~2_96:
00006880  0D0A 2D2D 11300          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
00006884  2D2D 2D2D 
00006888  2D2D 2D2D 
0000688C  2D2D 2D   
0000688F  2D2D 2D2D 11301          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00006893  2D2D 2D2D 
00006897  2D2D 2D2D 
0000689B  2D2D 2D   
0000689E  2D2D 2D2D 11302          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000068A2  2D2D 2D2D 
000068A6  2D2D 2D2D 
000068AA  2D2D 2D   
000068AD  2D2D 2D2D 11303          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000068B1  2D2D 2D2D 
000068B5  2D2D 2D2D 
000068B9  2D2D 2D   
000068BC  2D2D 2D2D 11304          dc.b      45,45,45,45,45,45,0
000068C0  2D2D 00   
                    11305   @m68kde~2_97:
000068C4  0D0A 2020 11306          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
000068C8  4465 6275 
000068CC  6767 6572 
000068D0  20        
000068D1  436F 6D6D 11307          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
000068D5  616E 6420 
000068D9  5375 6D6D 
000068DD  6172 7900 11308          dc.b      97,114,121,0
                    11309   @m68kde~2_98:
000068E2  0D0A 2020 11310          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
000068E6  2E28 7265 
000068EA  6729 2020 
000068EE  2020      
000068F0  2020 202D 11311          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
000068F4  2043 6861 
000068F8  6E67 6520 
000068FC  5265      
000068FE  6769 7374 11312          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
00006902  6572 733A 
00006906  2065 2E67 
0000690A  2041 302D 11313          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
0000690E  4137 2C44 
00006912  302D 4437 
00006916  2C50 43   
00006919  2C53 5350 11314          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
0000691D  2C55 5350 
00006921  2C53 5200 
                    11315   @m68kde~2_99:
00006926  0D0A 2020 11316          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
0000692A  4244 2F42 
0000692E  532F 4243 
00006932  2F42 4B   
00006935  2020 2D20 11317          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00006939  4272 6561 
0000693D  6B20 506F 
00006941  69        
00006942  6E74 3A20 11318          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
00006946  4469 7370 
0000694A  6C61 792F 
0000694E  53        
0000694F  6574 2F43 11319          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
00006953  6C65 6172 
00006957  2F4B 696C 
0000695B  6C        
0000695C  00        11320          dc.b      0
                    11321   @m68kde~2_100:
0000695E  0D0A 2020 11322          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
00006962  4320 2020 
00006966  2020 2020 
0000696A  2020 20   
0000696D  2020 2D20 11323          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
00006971  436F 7079 
00006975  2050 726F 
00006979  67        
0000697A  7261 6D20 11324          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
0000697E  6672 6F6D 
00006982  2046 6C61 
00006986  73        
00006987  6820 746F 11325          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
0000698B  204D 6169 
0000698F  6E20 4D65 
00006993  6D        
00006994  6F72 7900 11326          dc.b      111,114,121,0
                    11327   @m68kde~2_101:
00006998  0D0A 2020 11328          dc.b      13,10,32,32,68,73,32,32,32,32,32,32,32,32,32
0000699C  4449 2020 
000069A0  2020 2020 
000069A4  2020 20   
000069A7  2020 2D20 11329          dc.b      32,32,45,32,68,105,115,97,115,115,101,109,98
000069AB  4469 7361 
000069AF  7373 656D 
000069B3  62        
000069B4  6C65 2050 11330          dc.b      108,101,32,80,114,111,103,114,97,109,0
000069B8  726F 6772 
000069BC  616D 00   
                    11331   @m68kde~2_102:
000069C0  0D0A 2020 11332          dc.b      13,10,32,32,68,85,32,32,32,32,32,32,32,32,32
000069C4  4455 2020 
000069C8  2020 2020 
000069CC  2020 20   
000069CF  2020 2D20 11333          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
000069D3  4475 6D70 
000069D7  204D 656D 
000069DB  6F        
000069DC  7279 2043 11334          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
000069E0  6F6E 7465 
000069E4  6E74 7320 
000069E8  746F 2053 11335          dc.b      116,111,32,83,99,114,101,101,110,0
000069EC  6372 6565 
000069F0  6E00      
                    11336   @m68kde~2_103:
000069F2  0D0A 2020 11337          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
000069F6  4520 2020 
000069FA  2020 2020 
000069FE  2020 20   
00006A01  2020 2D20 11338          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00006A05  456E 7465 
00006A09  7220 5374 
00006A0D  72        
00006A0E  696E 6720 11339          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
00006A12  696E 746F 
00006A16  204D 656D 
00006A1A  6F72 7900 11340          dc.b      111,114,121,0
                    11341   @m68kde~2_104:
00006A1E  0D0A 2020 11342          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00006A22  4620 2020 
00006A26  2020 2020 
00006A2A  2020 20   
00006A2D  2020 2D20 11343          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
00006A31  4669 6C6C 
00006A35  204D 656D 
00006A39  6F        
00006A3A  7279 2077 11344          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
00006A3E  6974 6820 
00006A42  4461 7461 
00006A46  00        
                    11345   @m68kde~2_105:
00006A48  0D0A 2020 11346          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
00006A4C  4720 2020 
00006A50  2020 2020 
00006A54  2020 20   
00006A57  2020 2D20 11347          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
00006A5B  476F 2050 
00006A5F  726F 6772 
00006A63  61        
00006A64  6D20 5374 11348          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
00006A68  6172 7469 
00006A6C  6E67 2061 
00006A70  74        
00006A71  2041 6464 11349          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
00006A75  7265 7373 
00006A79  3A20 2425 
00006A7D  30        
00006A7E  3858 00   11350          dc.b      56,88,0
                    11351   @m68kde~2_106:
00006A82  0D0A 2020 11352          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
00006A86  4C20 2020 
00006A8A  2020 2020 
00006A8E  2020 20   
00006A91  2020 2D20 11353          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
00006A95  4C6F 6164 
00006A99  2050 726F 
00006A9D  67        
00006A9E  7261 6D20 11354          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
00006AA2  282E 4845 
00006AA6  5820 6669 
00006AAA  6C        
00006AAB  6529 2066 11355          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
00006AAF  726F 6D20 
00006AB3  4C61 7074 
00006AB7  6F        
00006AB8  7000      11356          dc.b      112,0
                    11357   @m68kde~2_107:
00006ABA  0D0A 2020 11358          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
00006ABE  4D20 2020 
00006AC2  2020 2020 
00006AC6  2020 20   
00006AC9  2020 2D20 11359          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
00006ACD  4D65 6D6F 
00006AD1  7279 2045 
00006AD5  78        
00006AD6  616D 696E 11360          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
00006ADA  6520 616E 
00006ADE  6420 4368 
00006AE2  61        
00006AE3  6E67 6500 11361          dc.b      110,103,101,0
                    11362   @m68kde~2_108:
00006AE8  0D0A 2020 11363          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
00006AEC  5020 2020 
00006AF0  2020 2020 
00006AF4  2020 20   
00006AF7  2020 2D20 11364          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
00006AFB  5072 6F67 
00006AFF  7261 6D20 
00006B03  46        
00006B04  6C61 7368 11365          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00006B08  204D 656D 
00006B0C  6F72 7920 
00006B10  7769 7468 11366          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00006B14  2055 7365 
00006B18  7220 5072 
00006B1C  6F67 7261 11367          dc.b      111,103,114,97,109,0
00006B20  6D00      
                    11368   @m68kde~2_109:
00006B22  0D0A 2020 11369          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00006B26  5220 2020 
00006B2A  2020 2020 
00006B2E  2020 20   
00006B31  2020 2D20 11370          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00006B35  4469 7370 
00006B39  6C61 7920 
00006B3D  36        
00006B3E  3830 3030 11371          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
00006B42  2052 6567 
00006B46  6973 7465 
00006B4A  72        
00006B4B  7300      11372          dc.b      115,0
                    11373   @m68kde~2_110:
00006B4E  0D0A 2020 11374          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
00006B52  5320 2020 
00006B56  2020 2020 
00006B5A  2020 20   
00006B5D  2020 2D20 11375          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
00006B61  546F 6767 
00006B65  6C65 204F 
00006B69  4E        
00006B6A  2F4F 4646 11376          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
00006B6E  2053 696E 
00006B72  676C 6520 
00006B76  53        
00006B77  7465 7020 11377          dc.b      116,101,112,32,77,111,100,101,0
00006B7B  4D6F 6465 
00006B7F  00        
                    11378   @m68kde~2_111:
00006B80  0D0A 2020 11379          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
00006B84  544D 2020 
00006B88  2020 2020 
00006B8C  2020 20   
00006B8F  2020 2D20 11380          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
00006B93  5465 7374 
00006B97  204D 656D 
00006B9B  6F        
00006B9C  7279 00   11381          dc.b      114,121,0
                    11382   @m68kde~2_112:
00006BA0  0D0A 2020 11383          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00006BA4  5453 2020 
00006BA8  2020 2020 
00006BAC  2020 20   
00006BAF  2020 2D20 11384          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00006BB3  5465 7374 
00006BB7  2053 7769 
00006BBB  74        
00006BBC  6368 6573 11385          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
00006BC0  3A20 5357 
00006BC4  372D 3000 
                    11386   @m68kde~2_113:
00006BC8  0D0A 2020 11387          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
00006BCC  5444 2020 
00006BD0  2020 2020 
00006BD4  2020 20   
00006BD7  2020 2D20 11388          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
00006BDB  5465 7374 
00006BDF  2044 6973 
00006BE3  70        
00006BE4  6C61 7973 11389          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
00006BE8  3A20 4C45 
00006BEC  4473 2061 
00006BF0  6E        
00006BF1  6420 372D 11390          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00006BF5  5365 676D 
00006BF9  656E 7400 
                    11391   @m68kde~2_114:
00006BFE  0D0A 2020 11392          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00006C02  5744 2F57 
00006C06  532F 5743 
00006C0A  2F57 4B   
00006C0D  2020 2D20 11393          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00006C11  5761 7463 
00006C15  6820 506F 
00006C19  696E      
00006C1B  743A 2044 11394          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00006C1F  6973 706C 
00006C23  6179 2F53 
00006C27  65        
00006C28  742F 436C 11395          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00006C2C  6561 722F 
00006C30  4B69 6C6C 
00006C34  00        
                    11396   @m68kde~2_115:
00006C36  0D0A 2300 11397          dc.b      13,10,35,0
                    11398   @m68kde~2_116:
00006C3A  0D0A 5072 11399          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
00006C3E  6F67 7261 
00006C42  6D20 5275 
00006C46  6E        
00006C47  6E69 6E67 11400          dc.b      110,105,110,103,46,46,46,46,46,0
00006C4B  2E2E 2E2E 
00006C4F  2E00      
                    11401   @m68kde~2_117:
00006C52  0D0A 5072 11402          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
00006C56  6573 7320 
00006C5A  3C52 4553 
00006C5E  4554      
00006C60  3E20 6275 11403          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
00006C64  7474 6F6E 
00006C68  203C 4B65 
00006C6C  79        
00006C6D  303E 206F 11404          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
00006C71  6E20 4445 
00006C75  3120 746F 
00006C79  2073      
00006C7B  746F 7000 11405          dc.b      116,111,112,0
                    11406   @m68kde~2_118:
00006C80  0D0A 4572 11407          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
00006C84  726F 723A 
00006C88  2050 7265 
00006C8C  73        
00006C8D  7320 2747 11408          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
00006C91  2720 6669 
00006C95  7273 7420 
00006C99  74        
00006C9A  6F20 7374 11409          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
00006C9E  6172 7420 
00006CA2  7072 6F67 
00006CA6  7261 6D00 11410          dc.b      114,97,109,0
                    11411   @m68kde~2_119:
00006CAA  0D0A 5369 11412          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00006CAE  6E67 6C65 
00006CB2  2053 7465 
00006CB6  70        
00006CB7  2020 3A5B 11413          dc.b      32,32,58,91,79,78,93,0
00006CBB  4F4E 5D00 
                    11414   @m68kde~2_120:
00006CC0  0D0A 5072 11415          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00006CC4  6573 7320 
00006CC8  2747 2720 
00006CCC  74        
00006CCD  6F20 5472 11416          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00006CD1  6163 6520 
00006CD5  5072 6F67 
00006CD9  72        
00006CDA  616D 2066 11417          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00006CDE  726F 6D20 
00006CE2  6164 6472 
00006CE6  6573 7320 11418          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
00006CEA  2425 582E 
00006CEE  2E2E 2E2E 
00006CF2  00        
                    11419   @m68kde~2_121:
00006CF4  0D0A 5075 11420          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00006CF8  7368 203C 
00006CFC  5245 5345 
00006D00  5420      
00006D02  4275 7474 11421          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00006D06  6F6E 3E20 
00006D0A  746F 2053 
00006D0E  74        
00006D0F  6F70 2E2E 11422          dc.b      111,112,46,46,46,46,46,0
00006D13  2E2E 2E00 
                    11423   @m68kde~2_122:
00006D18  0D0A 5369 11424          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00006D1C  6E67 6C65 
00006D20  2053 7465 
00006D24  70        
00006D25  203A 205B 11425          dc.b      32,58,32,91,79,70,70,93,0
00006D29  4F46 465D 
00006D2D  00        
                    11426   @m68kde~2_123:
00006D2E  0D0A 4272 11427          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006D32  6561 6B20 
00006D36  506F 696E 
00006D3A  74        
00006D3B  7320 3A5B 11428          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
00006D3F  456E 6162 
00006D43  6C65 645D 
00006D47  00        
                    11429   @m68kde~2_124:
00006D48  0D0A 5072 11430          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00006D4C  6573 7320 
00006D50  3C45 5343 
00006D54  3E20      
00006D56  746F 2052 11431          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00006D5A  6573 756D 
00006D5E  6520 5573 
00006D62  6572 2050 11432          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
00006D66  726F 6772 
00006D6A  616D 2E2E 
00006D6E  2E        
00006D6F  2E2E 00   11433          dc.b      46,46,0
                    11434   @m68kde~2_125:
00006D72  0D0A 5369 11435          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00006D76  6E67 6C65 
00006D7A  2053 7465 
00006D7E  70        
00006D7F  2020 3A5B 11436          dc.b      32,32,58,91,79,70,70,93,0
00006D83  4F46 465D 
00006D87  00        
                    11437   @m68kde~2_126:
00006D88  0D0A 0D0A 11438          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00006D8C  5072 6F67 
00006D90  7261 6D20 
00006D94  41        
00006D95  424F 5254 11439          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
00006D99  2021 2121 
00006D9D  2121 210D 
00006DA1  0A00      
                    11440   @m68kde~2_127:
00006DA4  2573 0D0A 11441          dc.b      37,115,13,10,0
00006DA8  00        
                    11442   @m68kde~2_128:
00006DAA  0D0A 0D0A 11443          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00006DAE  5072 6F67 
00006DB2  7261 6D20 
00006DB6  41        
00006DB7  424F 5254 11444          dc.b      66,79,82,84,32,33,33,33,33,33,0
00006DBB  2021 2121 
00006DBF  2121 00   
                    11445   @m68kde~2_129:
00006DC2  0D0A 556E 11446          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00006DC6  6861 6E64 
00006DCA  6C65 6420 
00006DCE  49        
00006DCF  6E74 6572 11447          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00006DD3  7275 7074 
00006DD7  3A20 4952 
00006DDB  5125 6420 11448          dc.b      81,37,100,32,33,33,33,33,33,0
00006DDF  2121 2121 
00006DE3  2100      
                    11449   @m68kde~2_130:
00006DE6  4144 4452 11450          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
00006DEA  4553 5320 
00006DEE  4552 524F 
00006DF2  523A 20   
00006DF5  3136 206F 11451          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00006DF9  7220 3332 
00006DFD  2042 6974 
00006E01  2054      
00006E03  7261 6E73 11452          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00006E07  6665 7220 
00006E0B  746F 2F66 
00006E0F  726F 6D20 11453          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00006E13  616E 204F 
00006E17  4444 2041 
00006E1B  64        
00006E1C  6472 6573 11454          dc.b      100,114,101,115,115,46,46,46,46,0
00006E20  732E 2E2E 
00006E24  2E00      
                    11455   @m68kde~2_131:
00006E26  556E 6861 11456          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
00006E2A  6E64 6C65 
00006E2E  6420 5472 
00006E32  6170 2021 11457          dc.b      97,112,32,33,33,33,33,33,0
00006E36  2121 2121 
00006E3A  00        
                    11458   @m68kde~2_132:
00006E3C  4255 5320 11459          dc.b      66,85,83,32,69,114,114,111,114,33,0
00006E40  4572 726F 
00006E44  7221 00   
                    11460   @m68kde~2_133:
00006E48  4144 4452 11461          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
00006E4C  4553 5320 
00006E50  4572 726F 
00006E54  7221      
00006E56  00        11462          dc.b      0
                    11463   @m68kde~2_134:
00006E58  494C 4C45 11464          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
00006E5C  4741 4C20 
00006E60  494E 5354 
00006E64  5255 43   
00006E67  5449 4F4E 11465          dc.b      84,73,79,78,0
00006E6B  00        
                    11466   @m68kde~2_135:
00006E6C  4449 5649 11467          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
00006E70  4445 2042 
00006E74  5920 5A45 
00006E78  524F 00   
                    11468   @m68kde~2_136:
00006E7C  2743 484B 11469          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
00006E80  2720 494E 
00006E84  5354 5255 
00006E88  4354 49   
00006E8B  4F4E 00   11470          dc.b      79,78,0
                    11471   @m68kde~2_137:
00006E8E  5452 4150 11472          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
00006E92  5620 494E 
00006E96  5354 5255 
00006E9A  4354 49   
00006E9D  4F4E 00   11473          dc.b      79,78,0
                    11474   @m68kde~2_138:
00006EA0  5052 4956 11475          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00006EA4  494C 4547 
00006EA8  4520 5649 
00006EAC  4F4C 41   
00006EAF  5449 4F4E 11476          dc.b      84,73,79,78,0
00006EB3  00        
                    11477   @m68kde~2_139:
00006EB4  554E 494E 11478          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00006EB8  4954 4941 
00006EBC  4C49 5345 
00006EC0  4420 49   
00006EC3  5251 00   11479          dc.b      82,81,0
                    11480   @m68kde~2_140:
00006EC6  5350 5552 11481          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
00006ECA  494F 5553 
00006ECE  2049 5251 
00006ED2  00        
                    11482   @m68kde~2_141:
00006ED4  0D0A 5374 11483          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00006ED8  6172 7420 
00006EDC  4164 6472 
00006EE0  65        
00006EE1  7373 2069 11484          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00006EE5  6E20 4D65 
00006EE9  6D6F 7279 
00006EED  3A20 00   11485          dc.b      58,32,0
                    11486   @m68kde~2_142:
00006EF0  0D0A 456E 11487          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00006EF4  7465 7220 
00006EF8  5374 7269 
00006EFC  6E        
00006EFD  6720 2845 11488          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00006F01  5343 2074 
00006F05  6F20 656E 
00006F09  64        
00006F0A  2920 3A00 11489          dc.b      41,32,58,0
                    11490   @m68kde~2_143:
00006F0E  4350 454E 11491          dc.b      67,80,69,78,32,52,49,50,32,65,115,115,105,103
00006F12  2034 3132 
00006F16  2041 7373 
00006F1A  6967      
00006F1C  6E6D 656E 11492          dc.b      110,109,101,110,116,32,52,97,0
00006F20  7420 3461 
00006F24  00        
                    11493   @m68kde~2_144:
00006F26  426F 6220 11494          dc.b      66,111,98,32,66,97,111,32,49,56,57,56,49,51
00006F2A  4261 6F20 
00006F2E  3138 3938 
00006F32  3133      
00006F34  3635 00   11495          dc.b      54,53,0
                    11496   @m68kde~2_145:
00006F38  0D0A 5275 11497          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
00006F3C  6E6E 696E 
00006F40  672E 2E2E 
00006F44  2E        
00006F45  2E00      11498          dc.b      46,0
                    11499   @m68kde~2_146:
00006F48  5275 6E6E 11500          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
00006F4C  696E 672E 
00006F50  2E2E 2E2E 
00006F54  00        
                    11501   @m68kde~2_147:
00006F56  4279 3A20 11502          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
00006F5A  504A 2044 
00006F5E  6176 6965 
00006F62  73        
00006F63  00        11503          dc.b      0
                    11504   @m68kde~2_148:
00006F64  0D0A 2573 11505          dc.b      13,10,37,115,0
00006F68  00        
                    11506   @m68kde~2_149:
00006F6A  2E42 2000 11507          dc.b      46,66,32,0
                    11508   @m68kde~2_150:
00006F6E  2E57 2000 11509          dc.b      46,87,32,0
                    11510   @m68kde~2_151:
00006F72  2E4C 2000 11511          dc.b      46,76,32,0
                    11512   @m68kde~2_152:
00006F76  2324 2558 11513          dc.b      35,36,37,88,0
00006F7A  00        
                    11514   @m68kde~2_153:
00006F7C  2800      11515          dc.b      40,0
                    11516   @m68kde~2_154:
00006F7E  2900      11517          dc.b      41,0
                    11518   @m68kde~2_155:
00006F80  292B 00   11519          dc.b      41,43,0
                    11520   @m68kde~2_156:
00006F84  2D28 00   11521          dc.b      45,40,0
                    11522   @m68kde~2_157:
00006F88  2564 2841 11523          dc.b      37,100,40,65,37,100,41,0
00006F8C  2564 2900 
                    11524   @m68kde~2_158:
00006F90  2564 2841 11525          dc.b      37,100,40,65,37,100,44,0
00006F94  2564 2C00 
                    11526   @m68kde~2_159:
00006F98  4400      11527          dc.b      68,0
                    11528   @m68kde~2_160:
00006F9A  4100      11529          dc.b      65,0
                    11530   @m68kde~2_161:
00006F9C  2564 00   11531          dc.b      37,100,0
                    11532   @m68kde~2_162:
00006FA0  2E57 2900 11533          dc.b      46,87,41,0
                    11534   @m68kde~2_163:
00006FA4  2E4C 2900 11535          dc.b      46,76,41,0
                    11536   @m68kde~2_164:
00006FA8  2425 5800 11537          dc.b      36,37,88,0
                    11538   @m68kde~2_165:
00006FAC  2564 2850 11539          dc.b      37,100,40,80,67,41,0
00006FB0  4329 00   
                    11540   @m68kde~2_166:
00006FB4  2564 2850 11541          dc.b      37,100,40,80,67,44,0
00006FB8  432C 00   
                    11542   @m68kde~2_167:
00006FBC  2C00      11543          dc.b      44,0
                    11544   @m68kde~2_168:
00006FBE  4343 00   11545          dc.b      67,67,0
                    11546   @m68kde~2_169:
00006FC2  4353 00   11547          dc.b      67,83,0
                    11548   @m68kde~2_170:
00006FC6  4551 00   11549          dc.b      69,81,0
                    11550   @m68kde~2_171:
00006FCA  4745 00   11551          dc.b      71,69,0
                    11552   @m68kde~2_172:
00006FCE  4754 00   11553          dc.b      71,84,0
                    11554   @m68kde~2_173:
00006FD2  4849 00   11555          dc.b      72,73,0
                    11556   @m68kde~2_174:
00006FD6  4C45 00   11557          dc.b      76,69,0
                    11558   @m68kde~2_175:
00006FDA  4C53 00   11559          dc.b      76,83,0
                    11560   @m68kde~2_176:
00006FDE  4C54 00   11561          dc.b      76,84,0
                    11562   @m68kde~2_177:
00006FE2  4D49 00   11563          dc.b      77,73,0
                    11564   @m68kde~2_178:
00006FE6  4E45 00   11565          dc.b      78,69,0
                    11566   @m68kde~2_179:
00006FEA  504C 00   11567          dc.b      80,76,0
                    11568   @m68kde~2_180:
00006FEE  5653 00   11569          dc.b      86,83,0
                    11570   @m68kde~2_181:
00006FF2  5643 00   11571          dc.b      86,67,0
                    11572   @m68kde~2_182:
00006FF6  5241 00   11573          dc.b      82,65,0
                    11574   @m68kde~2_183:
00006FFA  5352 00   11575          dc.b      83,82,0
                    11576   @m68kde~2_184:
00006FFE  556E 6B6E 11577          dc.b      85,110,107,110,111,119,110,0
00007002  6F77 6E00 
                    11578   @m68kde~2_185:
00007006  4142 4344 11579          dc.b      65,66,67,68,32,68,37,100,44,68,37,100,0
0000700A  2044 2564 
0000700E  2C44 2564 
00007012  00        
                    11580   @m68kde~2_186:
00007014  4142 4344 11581          dc.b      65,66,67,68,32,45,40,65,37,100,41,44,45,40,65
00007018  202D 2841 
0000701C  2564 292C 
00007020  2D28 41   
00007023  2564 2900 11582          dc.b      37,100,41,0
                    11583   @m68kde~2_187:
00007028  4144 4441 11584          dc.b      65,68,68,65,46,87,32,0
0000702C  2E57 2000 
                    11585   @m68kde~2_188:
00007030  4144 4441 11586          dc.b      65,68,68,65,46,76,32,0
00007034  2E4C 2000 
                    11587   @m68kde~2_189:
00007038  2C41 2558 11588          dc.b      44,65,37,88,0
0000703C  00        
                    11589   @m68kde~2_190:
0000703E  4144 4400 11590          dc.b      65,68,68,0
                    11591   @m68kde~2_191:
00007042  4144 4449 11592          dc.b      65,68,68,73,0
00007046  00        
                    11593   @m68kde~2_192:
00007048  414E 4449 11594          dc.b      65,78,68,73,0
0000704C  00        
                    11595   @m68kde~2_193:
0000704E  434D 5049 11596          dc.b      67,77,80,73,0
00007052  00        
                    11597   @m68kde~2_194:
00007054  454F 5249 11598          dc.b      69,79,82,73,0
00007058  00        
                    11599   @m68kde~2_195:
0000705A  4F52 4900 11600          dc.b      79,82,73,0
                    11601   @m68kde~2_196:
0000705E  5355 4249 11602          dc.b      83,85,66,73,0
00007062  00        
                    11603   @m68kde~2_197:
00007064  414E 4449 11604          dc.b      65,78,68,73,32,35,36,37,88,44,83,82,0
00007068  2023 2425 
0000706C  582C 5352 
00007070  00        
                    11605   @m68kde~2_198:
00007072  4144 4451 11606          dc.b      65,68,68,81,0
00007076  00        
                    11607   @m68kde~2_199:
00007078  2325 3158 11608          dc.b      35,37,49,88,44,0
0000707C  2C00      
                    11609   @m68kde~2_200:
0000707E  4144 4458 11610          dc.b      65,68,68,88,0
00007082  00        
                    11611   @m68kde~2_201:
00007084  4425 582C 11612          dc.b      68,37,88,44,68,37,88,0
00007088  4425 5800 
                    11613   @m68kde~2_202:
0000708C  2D28 4125 11614          dc.b      45,40,65,37,88,41,44,45,40,65,37,88,41,0
00007090  5829 2C2D 
00007094  2841 2558 
00007098  2900      
                    11615   @m68kde~2_203:
0000709A  414E 4400 11616          dc.b      65,78,68,0
                    11617   @m68kde~2_204:
0000709E  414E 4449 11618          dc.b      65,78,68,73,32,35,36,37,50,88,44,67,67,82,0
000070A2  2023 2425 
000070A6  3258 2C43 
000070AA  4352 00   
                    11619   @m68kde~2_205:
000070AE  4153 4C00 11620          dc.b      65,83,76,0
                    11621   @m68kde~2_206:
000070B2  4153 5200 11622          dc.b      65,83,82,0
                    11623   @m68kde~2_207:
000070B6  4C53 4C00 11624          dc.b      76,83,76,0
                    11625   @m68kde~2_208:
000070BA  4C53 5200 11626          dc.b      76,83,82,0
                    11627   @m68kde~2_209:
000070BE  524F 4C00 11628          dc.b      82,79,76,0
                    11629   @m68kde~2_210:
000070C2  524F 5200 11630          dc.b      82,79,82,0
                    11631   @m68kde~2_211:
000070C6  524F 584C 11632          dc.b      82,79,88,76,0
000070CA  00        
                    11633   @m68kde~2_212:
000070CC  524F 5852 11634          dc.b      82,79,88,82,0
000070D0  00        
                    11635   @m68kde~2_213:
000070D2  2324 2558 11636          dc.b      35,36,37,88,44,68,37,88,0
000070D6  2C44 2558 
000070DA  00        
                    11637   @m68kde~2_214:
000070DC  4200      11638          dc.b      66,0
                    11639   @m68kde~2_215:
000070DE  4243 4847 11640          dc.b      66,67,72,71,32,0
000070E2  2000      
                    11641   @m68kde~2_216:
000070E4  4425 642C 11642          dc.b      68,37,100,44,0
000070E8  00        
                    11643   @m68kde~2_217:
000070EA  2324 2558 11644          dc.b      35,36,37,88,44,0
000070EE  2C00      
                    11645   @m68kde~2_218:
000070F0  4243 4C52 11646          dc.b      66,67,76,82,32,0
000070F4  2000      
                    11647   @m68kde~2_219:
000070F6  4253 4554 11648          dc.b      66,83,69,84,32,0
000070FA  2000      
                    11649   @m68kde~2_220:
000070FC  4254 5354 11650          dc.b      66,84,83,84,32,0
00007100  2000      
                    11651   @m68kde~2_221:
00007102  4348 4B20 11652          dc.b      67,72,75,32,0
00007106  00        
                    11653   @m68kde~2_222:
00007108  2C44 2564 11654          dc.b      44,68,37,100,0
0000710C  00        
                    11655   @m68kde~2_223:
0000710E  434C 5200 11656          dc.b      67,76,82,0
                    11657   @m68kde~2_224:
00007112  434D 5041 11658          dc.b      67,77,80,65,46,87,32,0
00007116  2E57 2000 
                    11659   @m68kde~2_225:
0000711A  434D 5041 11660          dc.b      67,77,80,65,46,76,32,0
0000711E  2E4C 2000 
                    11661   @m68kde~2_226:
00007122  2C41 2564 11662          dc.b      44,65,37,100,0
00007126  00        
                    11663   @m68kde~2_227:
00007128  434D 5000 11664          dc.b      67,77,80,0
                    11665   @m68kde~2_228:
0000712C  434D 504D 11666          dc.b      67,77,80,77,0
00007130  00        
                    11667   @m68kde~2_229:
00007132  2841 2564 11668          dc.b      40,65,37,100,41,43,44,40,65,37,100,41,43,0
00007136  292B 2C28 
0000713A  4125 6429 
0000713E  2B00      
                    11669   @m68kde~2_230:
00007140  4442 00   11670          dc.b      68,66,0
                    11671   @m68kde~2_231:
00007144  4425 642C 11672          dc.b      68,37,100,44,37,43,100,40,80,67,41,32,116,111
00007148  252B 6428 
0000714C  5043 2920 
00007150  746F      
00007152  2041 6464 11673          dc.b      32,65,100,100,114,58,36,37,88,0
00007156  723A 2425 
0000715A  5800      
                    11674   @m68kde~2_232:
0000715C  4449 5653 11675          dc.b      68,73,86,83,32,0
00007160  2000      
                    11676   @m68kde~2_233:
00007162  4449 5655 11677          dc.b      68,73,86,85,32,0
00007166  2000      
                    11678   @m68kde~2_234:
00007168  454F 5200 11679          dc.b      69,79,82,0
                    11680   @m68kde~2_235:
0000716C  454F 5249 11681          dc.b      69,79,82,73,32,35,36,37,50,88,44,67,67,82,0
00007170  2023 2425 
00007174  3258 2C43 
00007178  4352 00   
                    11682   @m68kde~2_236:
0000717C  454F 5249 11683          dc.b      69,79,82,73,32,35,36,37,88,44,83,82,0
00007180  2023 2425 
00007184  582C 5352 
00007188  00        
                    11684   @m68kde~2_237:
0000718A  4558 4720 11685          dc.b      69,88,71,32,68,37,100,44,68,37,100,0
0000718E  4425 642C 
00007192  4425 6400 
                    11686   @m68kde~2_238:
00007196  4558 4720 11687          dc.b      69,88,71,32,65,37,100,44,65,37,100,0
0000719A  4125 642C 
0000719E  4125 6400 
                    11688   @m68kde~2_239:
000071A2  4558 4720 11689          dc.b      69,88,71,32,68,37,100,44,65,37,100,0
000071A6  4425 642C 
000071AA  4125 6400 
                    11690   @m68kde~2_240:
000071AE  4558 5400 11691          dc.b      69,88,84,0
                    11692   @m68kde~2_241:
000071B2  494C 4C45 11693          dc.b      73,76,76,69,71,65,76,32,40,36,52,65,70,67,41
000071B6  4741 4C20 
000071BA  2824 3441 
000071BE  4643 29   
000071C1  00        11694          dc.b      0
                    11695   @m68kde~2_242:
000071C2  4A4D 5020 11696          dc.b      74,77,80,32,0
000071C6  00        
                    11697   @m68kde~2_243:
000071C8  4A53 5220 11698          dc.b      74,83,82,32,0
000071CC  00        
                    11699   @m68kde~2_244:
000071CE  4C45 4120 11700          dc.b      76,69,65,32,0
000071D2  00        
                    11701   @m68kde~2_245:
000071D4  4C49 4E4B 11702          dc.b      76,73,78,75,32,0
000071D8  2000      
                    11703   @m68kde~2_246:
000071DA  4125 642C 11704          dc.b      65,37,100,44,35,37,100,0
000071DE  2325 6400 
                    11705   @m68kde~2_247:
000071E2  4D4F 5645 11706          dc.b      77,79,86,69,46,66,32,0
000071E6  2E42 2000 
                    11707   @m68kde~2_248:
000071EA  4D4F 5645 11708          dc.b      77,79,86,69,46,76,32,0
000071EE  2E4C 2000 
                    11709   @m68kde~2_249:
000071F2  4D4F 5645 11710          dc.b      77,79,86,69,46,87,32,0
000071F6  2E57 2000 
                    11711   @m68kde~2_250:
000071FA  4D4F 5645 11712          dc.b      77,79,86,69,32,0
000071FE  2000      
                    11713   @m68kde~2_251:
00007200  2C43 4352 11714          dc.b      44,67,67,82,0
00007204  00        
                    11715   @m68kde~2_252:
00007206  4D4F 5645 11716          dc.b      77,79,86,69,32,83,82,44,0
0000720A  2053 522C 
0000720E  00        
                    11717   @m68kde~2_253:
00007210  2C53 5200 11718          dc.b      44,83,82,0
                    11719   @m68kde~2_254:
00007214  4D4F 5645 11720          dc.b      77,79,86,69,32,85,83,80,44,65,37,100,0
00007218  2055 5350 
0000721C  2C41 2564 
00007220  00        
                    11721   @m68kde~2_255:
00007222  4D4F 5645 11722          dc.b      77,79,86,69,32,65,37,100,44,85,83,80,0
00007226  2041 2564 
0000722A  2C55 5350 
0000722E  00        
                    11723   @m68kde~2_256:
00007230  4D4F 5645 11724          dc.b      77,79,86,69,77,0
00007234  4D00      
                    11725   @m68kde~2_257:
00007236  4425 6400 11726          dc.b      68,37,100,0
                    11727   @m68kde~2_258:
0000723A  2F44 2564 11728          dc.b      47,68,37,100,0
0000723E  00        
                    11729   @m68kde~2_259:
00007240  4125 6400 11730          dc.b      65,37,100,0
                    11731   @m68kde~2_260:
00007244  2F41 2564 11732          dc.b      47,65,37,100,0
00007248  00        
                    11733   @m68kde~2_261:
0000724A  4D4F 5645 11734          dc.b      77,79,86,69,80,46,87,32,36,37,88,40,65,37,100
0000724E  502E 5720 
00007252  2425 5828 
00007256  4125 64   
00007259  292C 4425 11735          dc.b      41,44,68,37,100,0
0000725D  6400      
                    11736   @m68kde~2_262:
00007260  4D4F 5645 11737          dc.b      77,79,86,69,80,46,76,32,36,37,88,40,65,37,100
00007264  502E 4C20 
00007268  2425 5828 
0000726C  4125 64   
0000726F  292C 4425 11738          dc.b      41,44,68,37,100,0
00007273  6400      
                    11739   @m68kde~2_263:
00007276  4D4F 5645 11740          dc.b      77,79,86,69,80,46,87,32,68,37,100,44,36,37,88
0000727A  502E 5720 
0000727E  4425 642C 
00007282  2425 58   
00007285  2841 2564 11741          dc.b      40,65,37,100,41,0
00007289  2900      
                    11742   @m68kde~2_264:
0000728C  4D4F 5645 11743          dc.b      77,79,86,69,80,46,76,32,68,37,100,44,36,37,88
00007290  502E 4C20 
00007294  4425 642C 
00007298  2425 58   
0000729B  2841 2564 11744          dc.b      40,65,37,100,41,0
0000729F  2900      
                    11745   @m68kde~2_265:
000072A2  4D4F 5645 11746          dc.b      77,79,86,69,81,32,35,36,37,88,44,68,37,100,0
000072A6  5120 2324 
000072AA  2558 2C44 
000072AE  2564 00   
                    11747   @m68kde~2_266:
000072B2  4D55 4C53 11748          dc.b      77,85,76,83,32,0
000072B6  2000      
                    11749   @m68kde~2_267:
000072B8  4D55 4C55 11750          dc.b      77,85,76,85,32,0
000072BC  2000      
                    11751   @m68kde~2_268:
000072BE  4E42 4344 11752          dc.b      78,66,67,68,32,0
000072C2  2000      
                    11753   @m68kde~2_269:
000072C4  4E45 4700 11754          dc.b      78,69,71,0
                    11755   @m68kde~2_270:
000072C8  4E45 4758 11756          dc.b      78,69,71,88,0
000072CC  00        
                    11757   @m68kde~2_271:
000072CE  4E4F 5000 11758          dc.b      78,79,80,0
                    11759   @m68kde~2_272:
000072D2  4E4F 5400 11760          dc.b      78,79,84,0
                    11761   @m68kde~2_273:
000072D6  4F52 00   11762          dc.b      79,82,0
                    11763   @m68kde~2_274:
000072DA  4F52 4920 11764          dc.b      79,82,73,32,35,36,37,50,88,44,67,67,82,0
000072DE  2324 2532 
000072E2  582C 4343 
000072E6  5200      
                    11765   @m68kde~2_275:
000072E8  4F52 4920 11766          dc.b      79,82,73,32,32,35,36,37,88,44,83,82,0
000072EC  2023 2425 
000072F0  582C 5352 
000072F4  00        
                    11767   @m68kde~2_276:
000072F6  5045 4120 11768          dc.b      80,69,65,32,0
000072FA  00        
                    11769   @m68kde~2_277:
000072FC  5245 5345 11770          dc.b      82,69,83,69,84,0
00007300  5400      
                    11771   @m68kde~2_278:
00007302  5254 4500 11772          dc.b      82,84,69,0
                    11773   @m68kde~2_279:
00007306  5254 5200 11774          dc.b      82,84,82,0
                    11775   @m68kde~2_280:
0000730A  5254 5300 11776          dc.b      82,84,83,0
                    11777   @m68kde~2_281:
0000730E  5354 4F50 11778          dc.b      83,84,79,80,32,35,36,37,88,0
00007312  2023 2425 
00007316  5800      
                    11779   @m68kde~2_282:
00007318  5342 4344 11780          dc.b      83,66,67,68,32,68,37,100,44,68,37,100,0
0000731C  2044 2564 
00007320  2C44 2564 
00007324  00        
                    11781   @m68kde~2_283:
00007326  5342 4344 11782          dc.b      83,66,67,68,32,45,40,65,37,100,41,44,45,40,65
0000732A  202D 2841 
0000732E  2564 292C 
00007332  2D28 41   
00007335  2564 2900 11783          dc.b      37,100,41,0
                    11784   @m68kde~2_284:
0000733A  5300      11785          dc.b      83,0
                    11786   @m68kde~2_285:
0000733C  5355 4241 11787          dc.b      83,85,66,65,46,87,32,0
00007340  2E57 2000 
                    11788   @m68kde~2_286:
00007344  5355 4241 11789          dc.b      83,85,66,65,46,76,32,0
00007348  2E4C 2000 
                    11790   @m68kde~2_287:
0000734C  5355 4200 11791          dc.b      83,85,66,0
                    11792   @m68kde~2_288:
00007350  5355 4251 11793          dc.b      83,85,66,81,0
00007354  00        
                    11794   @m68kde~2_289:
00007356  5355 4258 11795          dc.b      83,85,66,88,0
0000735A  00        
                    11796   @m68kde~2_290:
0000735C  4425 3158 11797          dc.b      68,37,49,88,44,68,37,49,88,0
00007360  2C44 2531 
00007364  5800      
                    11798   @m68kde~2_291:
00007366  2D28 4125 11799          dc.b      45,40,65,37,49,88,41,44,45,40,65,37,49,88,41
0000736A  3158 292C 
0000736E  2D28 4125 
00007372  3158 29   
00007375  00        11800          dc.b      0
                    11801   @m68kde~2_292:
00007376  5357 4150 11802          dc.b      83,87,65,80,32,68,37,100,0
0000737A  2044 2564 
0000737E  00        
                    11803   @m68kde~2_293:
00007380  5441 5320 11804          dc.b      84,65,83,32,0
00007384  00        
                    11805   @m68kde~2_294:
00007386  5452 4150 11806          dc.b      84,82,65,80,32,35,37,100,0
0000738A  2023 2564 
0000738E  00        
                    11807   @m68kde~2_295:
00007390  5452 4150 11808          dc.b      84,82,65,80,86,0
00007394  5600      
                    11809   @m68kde~2_296:
00007396  5453 5400 11810          dc.b      84,83,84,0
                    11811   @m68kde~2_297:
0000739A  554E 4C4B 11812          dc.b      85,78,76,75,32,65,37,100,0
0000739E  2041 2564 
000073A2  00        
                    11813          section   data
000073A4            11814                   align
          0000 73A4 11815   DataStart       equ       *
                    11816   
                    11817   *********************************************************************************************************
                    11818   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    11819   * to ram as part of the CStart routine in this file
                    11820   *********************************************************************************************************
                    11821   
                    11822   @itoa_1:
000073A4  2D32 3134 11823          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
000073A8  3734 3833 
000073AC  3634 3800 
                    11824          section   bss
000073B0            11825                   align
          0000 73B0 11826   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    11827   
                    11828   *********************************************************************************************************
                    11829   * Section for Uninitialised Data held in ROM as constants
                    11830   *********************************************************************************************************
                    11831   
0B000000            11832                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 000C 11833   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    11834   
                    11835   
0B000000            11836   bss             org       bss
                    11837   
                    11838   *********************************************************************************************************
                    11839   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    11840   * install the exception handler using the C function InstallExceptionHandler()
                    11841   *********************************************************************************************************
                    11842   
                    11843   
                    11844   
0B000000            11845   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            11846   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            11847   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            11848   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            11849   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            11850   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            11851   VCheck           ds.l    1      ditto
0B00001C            11852   VTrapV           ds.l    1      ditto
0B000020            11853   VPrivilege       ds.l    1      ditto
0B000024            11854   VTrace           ds.l    1
0B000028            11855   VLine1010emul    ds.l    1
0B00002C            11856   VLine1111emul    ds.l    1
0B000030            11857   VUnassigned1     ds.l    1
0B000034            11858   VUnassigned2     ds.l    1
0B000038            11859   VUnassigned3     ds.l    1
0B00003C            11860   VUninit_IRQ      ds.l    1
0B000040            11861   VUnassigned4     ds.l    1
0B000044            11862   VUnassigned5     ds.l    1
0B000048            11863   VUnassigned6     ds.l    1
0B00004C            11864   VUnassigned7     ds.l    1
0B000050            11865   VUnassigned8     ds.l    1
0B000054            11866   VUnassigned9     ds.l    1
0B000058            11867   VUnassigned10    ds.l    1
0B00005C            11868   VUnassigned11    ds.l    1
0B000060            11869   VSpuriousIRQ     ds.l    1
                    11870   
                    11871   * Interrupt handlers Vector 25-31
0B000064            11872   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            11873   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            11874   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            11875   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            11876   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            11877   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            11878   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    11879   
                    11880   * Trap Handler vectors 32-47
0B000080            11881   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            11882   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            11883   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            11884   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            11885   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            11886   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            11887   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            11888   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            11889   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            11890   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            11891   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            11892   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            11893   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            11894   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            11895   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            11896   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    11897   
                    11898   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    11899   
                    11900   ***********************************************************************************************************
                    11901   * Other Variables
                    11902   ***********************************************************************************************************
                    11903   *__DebugA5       ds.l    1
                    11904   *__UserA5        ds.l    1
                    11905   
                    11906   ***********************************************************************************************************
0B0000C0            11907   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            11908   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            11909   __heap:         ds.l    0       ; pointers for malloc functions
                    11910   
                    11911   *__himem:       ds.l    himem            ; highest memory location + 1
                    11912   *__stklen:      ds.l    stklen           ; default stack size
                    11913   
                    11914   *********************************************************************************************************
                    11915   * Section for Heap
                    11916   *********************************************************************************************************
                    11917   
                    11918   _i:
0B0000C4            11919          ds.b      4
                    11920   _x:
0B0000C8            11921          ds.b      4
                    11922   _y:
0B0000CC            11923          ds.b      4
                    11924   _z:
0B0000D0            11925          ds.b      4
                    11926   _PortA_Count:
0B0000D4            11927          ds.b      4
                    11928   _Trace:
0B0000D8            11929          ds.b      4
                    11930   _GoFlag:
0B0000DC            11931          ds.b      4
                    11932   _Echo:
0B0000E0            11933          ds.b      4
                    11934   _d0:
0B0000E4            11935          ds.b      4
                    11936   _d1:
0B0000E8            11937          ds.b      4
                    11938   _d2:
0B0000EC            11939          ds.b      4
                    11940   _d3:
0B0000F0            11941          ds.b      4
                    11942   _d4:
0B0000F4            11943          ds.b      4
                    11944   _d5:
0B0000F8            11945          ds.b      4
                    11946   _d6:
0B0000FC            11947          ds.b      4
                    11948   _d7:
0B000100            11949          ds.b      4
                    11950   _a0:
0B000104            11951          ds.b      4
                    11952   _a1:
0B000108            11953          ds.b      4
                    11954   _a2:
0B00010C            11955          ds.b      4
                    11956   _a3:
0B000110            11957          ds.b      4
                    11958   _a4:
0B000114            11959          ds.b      4
                    11960   _a5:
0B000118            11961          ds.b      4
                    11962   _a6:
0B00011C            11963          ds.b      4
                    11964   _PC:
0B000120            11965          ds.b      4
                    11966   _SSP:
0B000124            11967          ds.b      4
                    11968   _USP:
0B000128            11969          ds.b      4
                    11970   _SR:
0B00012C            11971          ds.b      2
                    11972   _BreakPointAddress:
0B00012E            11973          ds.b      32
                    11974   _BreakPointInstruction:
0B00014E            11975          ds.b      16
                    11976   _BreakPointSetOrCleared:
0B00015E            11977          ds.b      32
                    11978   _InstructionSize:
0B00017E            11979          ds.b      4
                    11980   _WatchPointAddress:
0B000182            11981          ds.b      32
                    11982   _WatchPointSetOrCleared:
0B0001A2            11983          ds.b      32
                    11984   _WatchPointString:
0B0001C2            11985          ds.b      800
                    11986   _Instruction:
0B0004E2            11987          ds.b      100
                    11988   _TempString:
0B000546            11989          ds.b      100
                    11990          section   heap
0B0005AA            11991                   align
          0B00 05AA 11992   bssEnd          equ *                   end of storage space for unitialised variables
                    11993   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 05AA 11994   heap   equ       *
0B0005AA            11995                    align
          0000 0000

Assembly errors: 0
